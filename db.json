{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/fonts/LXGWWenKaiGBScreen.ttf","path":"fonts/LXGWWenKaiGBScreen.ttf","modified":0,"renderable":0},{"_id":"source/img/2025-01-17-14-00-36.png","path":"img/2025-01-17-14-00-36.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-16-23-58-21.png","path":"img/2025-01-16-23-58-21.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-11-41-54.png","path":"img/2025-01-18-11-41-54.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-11-45-41.png","path":"img/2025-01-18-11-45-41.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-12-58-38.png","path":"img/2025-01-18-12-58-38.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-13-01-29.png","path":"img/2025-01-18-13-01-29.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-13-03-21.png","path":"img/2025-01-18-13-03-21.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-13-09-11.png","path":"img/2025-01-18-13-09-11.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-13-15-38.png","path":"img/2025-01-18-13-15-38.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-13-23-22.png","path":"img/2025-01-18-13-23-22.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-17-06-50.png","path":"img/2025-01-18-17-06-50.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-17-11-36.png","path":"img/2025-01-18-17-11-36.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-17-13-45.png","path":"img/2025-01-18-17-13-45.png","modified":0,"renderable":0},{"_id":"source/img/2025-01-18-17-14-29.png","path":"img/2025-01-18-17-14-29.png","modified":0,"renderable":0},{"_id":"source/img/Aniya.png","path":"img/Aniya.png","modified":0,"renderable":0},{"_id":"source/img/Aniya_放大镜.jpg","path":"img/Aniya_放大镜.jpg","modified":0,"renderable":0},{"_id":"source/img/JS.png","path":"img/JS.png","modified":0,"renderable":0},{"_id":"source/img/bgImg.png","path":"img/bgImg.png","modified":0,"renderable":0},{"_id":"source/img/find-2025-01-22-11-58-20.png","path":"img/find-2025-01-22-11-58-20.png","modified":0,"renderable":0},{"_id":"source/img/great.jpg","path":"img/great.jpg","modified":0,"renderable":0},{"_id":"source/img/legend-2025-01-21-21-19-51.png","path":"img/legend-2025-01-21-21-19-51.png","modified":0,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":0,"renderable":0},{"_id":"source/img/re0-2025-01-18-17-16-53.png","path":"img/re0-2025-01-18-17-16-53.png","modified":0,"renderable":0},{"_id":"source/img/re0-2025-01-18-17-40-27.png","path":"img/re0-2025-01-18-17-40-27.png","modified":0,"renderable":0},{"_id":"source/img/sun.png","path":"img/sun.png","modified":0,"renderable":0},{"_id":"source/img/不死鸟.jpg","path":"img/不死鸟.jpg","modified":0,"renderable":0},{"_id":"source/img/倦鸟.png","path":"img/倦鸟.png","modified":0,"renderable":0},{"_id":"source/img/料理的加护.jpg","path":"img/料理的加护.jpg","modified":0,"renderable":0},{"_id":"source/img/晚霞.jpg","path":"img/晚霞.jpg","modified":0,"renderable":0},{"_id":"source/img/校长帕克.jpg","path":"img/校长帕克.jpg","modified":0,"renderable":0},{"_id":"source/img/哭哭帕克.jpg","path":"img/哭哭帕克.jpg","modified":0,"renderable":0},{"_id":"source/img/照镜子.jpg","path":"img/照镜子.jpg","modified":0,"renderable":0},{"_id":"source/img/猫猫-2025-01-20-22-47-27.png","path":"img/猫猫-2025-01-20-22-47-27.png","modified":0,"renderable":0},{"_id":"source/img/社会心理学.png","path":"img/社会心理学.png","modified":0,"renderable":0},{"_id":"source/img/跨域共享.jpg","path":"img/跨域共享.jpg","modified":0,"renderable":0},{"_id":"source/img/闪光拉姆.jpg","path":"img/闪光拉姆.jpg","modified":0,"renderable":0},{"_id":"source/img/闪耀pack.jpg","path":"img/闪耀pack.jpg","modified":0,"renderable":0},{"_id":"source/img/雪国.jpg","path":"img/雪国.jpg","modified":0,"renderable":0},{"_id":"source/img/雷姆拉姆.jpg","path":"img/雷姆拉姆.jpg","modified":0,"renderable":0},{"_id":"source/img/db_index.png","path":"img/db_index.png","modified":0,"renderable":0},{"_id":"source/img/crypt_index.png","path":"img/crypt_index.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_drafts/my-fisrt-draft.md","hash":"e142445800a90b2f3e176061f51fc052d41c884e","modified":1737287194121},{"_id":"source/_posts/建站第一天.md","hash":"228bb16a2d4a2d8de018e34e36dbe4a078db6526","modified":1737287194125},{"_id":"source/_posts/Re0.md","hash":"1e47dbad0740c7a6fe264833bcfe530243331a7d","modified":1737287194123},{"_id":"source/.DS_Store","hash":"3de76e36729329aad9cb8e3a160d9e9d1ef9bfe5","modified":1740727421406},{"_id":"source/_posts/社会心理学.md","hash":"39314923e47e10c118940dd360e1bf4c607babe7","modified":1737287194126},{"_id":"source/css/custom.css","hash":"7f5d5c8adb574802894d2d78e2653cd270669f9b","modified":1740727417818},{"_id":"source/about/index.md","hash":"51db98c8124ff2a7c6297aa8a8cfc4bd04303bc0","modified":1737287194126},{"_id":"source/js/duration.js","hash":"feffbc1f875e5df4e5799175ade39ae6b8a756ec","modified":1737287194208},{"_id":"source/img/2025-01-17-14-00-36.png","hash":"eacdd40a31bb3f4ccec48b38aa01d9e4f4a000d5","modified":1737287194173},{"_id":"source/_posts/关系数据库.md","hash":"0ff9fef4ee2efa84c2e00c80a13d8b65d7209025","modified":1737521247121},{"_id":"source/img/JS.png","hash":"a115cbbec848dea5824181ef22411d8efc6dbfa8","modified":1737287194185},{"_id":"source/img/find-2025-01-22-11-58-20.png","hash":"a889d1dd151686eb085de78836a2cc7e59a43606","modified":1737518306563},{"_id":"source/img/.DS_Store","hash":"59ebd94a9104958e024c18dc6d7c0472a173ab02","modified":1740377259468},{"_id":"source/img/legend-2025-01-21-21-19-51.png","hash":"c56fc82db2388050164829230deac64751c69ea6","modified":1737465596946},{"_id":"source/img/猫猫-2025-01-20-22-47-27.png","hash":"91d8cfe3cb9673a851c50fc6351c91b9cb54bb60","modified":1737464245792},{"_id":"source/_posts/poets/bird.md","hash":"6dab2c86bb85c964c1182c5c2776b68ee27f2f4f","modified":1737287194125},{"_id":"source/_posts/poets/晚霞.md","hash":"345f349aedfb990ae09a394abee4d21ff657a365","modified":1737700546868},{"_id":"source/_posts/AI/AI-beginner.md","hash":"2a89fc29a172cede57bf73d89374de5b71fd52a7","modified":1739604039548},{"_id":"source/_posts/前后端/响应式设计.md","hash":"4fbedebc6df907a8482eed1e6140edf24109a13b","modified":1738914471269},{"_id":"source/_posts/前后端/CORS.md","hash":"c9b26c4ef559cd7c93fee12afca523e7c6275c33","modified":1737287194122},{"_id":"source/_posts/其他/SSH隧道.md","hash":"21d084e11ea2583dcb2009b0cbed8c707fe4bf7b","modified":1737287194124},{"_id":"source/_posts/其他/媒体查询.md","hash":"9b196dfde66daae3b555d0018f7df5c3a3d89a56","modified":1737287194125},{"_id":"source/_posts/其他/pip-tools.md","hash":"84734fdbbef7b8782ae4eba48cd3f273fd244f97","modified":1737287194124},{"_id":"source/_posts/其他/认证配置.md","hash":"284a65ff1554ac90e36f4e8372589b10dc09cf3b","modified":1737287194126},{"_id":"source/_posts/其他/Tmux.md","hash":"7270b94efe83ff6a65be8cc4981f6b144c9fa8b3","modified":1737287194124},{"_id":"source/_posts/编程语言/css笔记.md","hash":"a7f92a6fd6680a4bd6ba5259b6bffb5e0f785869","modified":1737287194124},{"_id":"source/_posts/编程语言/JavaScript.md","hash":"773ac9d0471801a59c3a968efc277350fcad94a7","modified":1738912862402},{"_id":"source/_posts/前后端/跨组件渲染.md","hash":"bad907a80f73903f4f72e3e39240bd7e7ca39c97","modified":1739691645188},{"_id":"source/_posts/编程语言/cpp学习记录.md","hash":"4b5563360459ec2716194b984379ca5e5f2fc8ae","modified":1740726632491},{"_id":"source/_posts/其他/themechange.md","hash":"62cf020f3ebc14a820ad732a52f9cc31161dba2c","modified":1738914529024},{"_id":"source/_posts/其他/makefile.md","hash":"698fa57402c8b31b7bf00d32f1eebe048882d1ed","modified":1739846563132},{"_id":"source/img/2025-01-16-23-58-21.png","hash":"3707c7284cdeaada1b82a50889d6bc5b66cfab69","modified":1737287194172},{"_id":"source/img/2025-01-18-12-58-38.png","hash":"cf5073b3f0fcc5f8e8b013927dc633cdb0eb478b","modified":1737287194174},{"_id":"source/img/2025-01-18-13-01-29.png","hash":"6dbe8216f8848a8f202de965f4313dbb2eecdd58","modified":1737287194174},{"_id":"source/img/2025-01-18-11-41-54.png","hash":"1d85d673eebe40136f7058b03e7d4aa3d2760b14","modified":1737287194173},{"_id":"source/img/great.jpg","hash":"ad40b86f9b500d362074fe888853c2536ba6e834","modified":1737287194192},{"_id":"source/img/2025-01-18-13-03-21.png","hash":"25abaf57c0e17909b165180aaf9d390fe09d6c5a","modified":1737287194175},{"_id":"source/img/2025-01-18-13-09-11.png","hash":"47c213fc9292190467b8b6f0e19b9408dbe6824f","modified":1737287194176},{"_id":"source/img/Aniya_放大镜.jpg","hash":"538ff8e7ac38f341c0166820d43617d73675cc86","modified":1737287194184},{"_id":"source/img/晚霞.jpg","hash":"c89abcb798ddb518b6e8ce08e8afd144b00e8a54","modified":1737287194201},{"_id":"source/img/不死鸟.jpg","hash":"0baad7c3a94594079f49165c91f061d0689c1035","modified":1737287194197},{"_id":"source/img/2025-01-18-11-45-41.png","hash":"f9cf4255cce7bad9cfbe29c5264b022933a64c30","modified":1737287194173},{"_id":"source/img/2025-01-18-17-13-45.png","hash":"b4d0e8077ffe69dfd61db955e869126b24c76ce0","modified":1737287194182},{"_id":"source/img/me.jpg","hash":"bdfdab38c41980cff966c08ea26ca8699948cbd6","modified":1737287194192},{"_id":"source/img/料理的加护.jpg","hash":"6364a3389f2ac52ad1ec33c254ebde8740b257cc","modified":1737287194201},{"_id":"source/img/闪光拉姆.jpg","hash":"8e818cc9cee33324fb15a8d52fc69b1262cf87e2","modified":1737036254195},{"_id":"source/img/哭哭帕克.jpg","hash":"e20aa94b2a43c0194fb3d3a5d0762b6404458003","modified":1737287194200},{"_id":"source/img/闪耀pack.jpg","hash":"470edf49958168295976933a0135d5517954cdba","modified":1737287194208},{"_id":"source/img/雪国.jpg","hash":"e1cc8027328cbc55de92496f1e7c90d3812923b7","modified":1737464245793},{"_id":"source/img/2025-01-18-17-14-29.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1737287194183},{"_id":"source/img/re0-2025-01-18-17-16-53.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1737287194193},{"_id":"source/img/re0-2025-01-18-17-40-27.png","hash":"0f759367f3fa09abcf03a7e92ec340f38e133142","modified":1737287194194},{"_id":"source/img/跨域共享.jpg","hash":"438d4dda0d2271203947bb461416275504601355","modified":1737287194207},{"_id":"source/img/雷姆拉姆.jpg","hash":"a3360d4afcc99266225d67003a06a133a2a8ecc7","modified":1737022344062},{"_id":"source/img/2025-01-18-13-15-38.png","hash":"a5774370c2e3ac61a14b5847c2c77ea69afecbfe","modified":1737287194177},{"_id":"source/img/2025-01-18-13-23-22.png","hash":"0c9345d1f0c9af7bc07f7bbf7a15153d4b16aea7","modified":1737287194178},{"_id":"source/img/2025-01-18-17-11-36.png","hash":"404b6f149798b76095753ac52d034516b37c1555","modified":1737287194182},{"_id":"source/img/照镜子.jpg","hash":"204a3b9a70ad3381fc5c2b78d3fc9afdecc2d995","modified":1737287194205},{"_id":"source/img/校长帕克.jpg","hash":"dbc8efb5b99bf953032dac803a4ea7ac1166974e","modified":1737287194204},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1737287194229},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1737287194211},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1737287194211},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1737287194210},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1737287194212},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1737287194210},{"_id":"themes/fluid/package.json","hash":"d56f9287f8d95211c592fb8ffd27e9f409b96f61","modified":1737287194220},{"_id":"themes/fluid/README_en.md","hash":"4094caaa0e438ebb74064f1583c7eebb6685edba","modified":1737287194213},{"_id":"themes/fluid/README.md","hash":"0f60b4293ffbe773a375d5acbdd9b9d6fd522655","modified":1737287194212},{"_id":"themes/fluid/_config.yml","hash":"01997c93736a63c64d7651ea23d86d479d7675d8","modified":1737464245794},{"_id":"themes/fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1737287194213},{"_id":"themes/fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1737287194213},{"_id":"themes/fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1737287194213},{"_id":"themes/fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1737287194213},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1737287194213},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1737287194213},{"_id":"themes/fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1737287194213},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1737287194214},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1737287194214},{"_id":"themes/fluid/layout/index.ejs","hash":"e46d610f256a9ec48f10530b08764431819d9ca3","modified":1737287194219},{"_id":"themes/fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1737287194218},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1737287194218},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1737287194218},{"_id":"themes/fluid/layout/layout.ejs","hash":"cbc82ac02e6cb978a7d8d342da7613067e3817cd","modified":1739843504626},{"_id":"themes/fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1737287194213},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1737287194218},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1737287194219},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1737287194220},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1737287194219},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1737287194219},{"_id":"themes/fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1737287194219},{"_id":"themes/fluid/layout/_partials/antd-icons.ejs","hash":"68dedd6f5f57e612a294386714fcab4d5d390123","modified":1737287194214},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"b80ee3cf3ffe95b5cfb9502071de7f56a63ce2d3","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"028abcad53bf9d9ee660b1c6434fc17739d91376","modified":1737716920493},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1737287194214},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1737287194218},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1737287194216},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1737287194220},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1737287194222},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1737287194221},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1737287194222},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1737287194222},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1737287194222},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1737287194223},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1737287194224},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1737287194223},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1737287194218},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1737287194216},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1737287194222},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1737287194223},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1737287194223},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1737287194224},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1737287194224},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"e2c5ad258db47d4c1ef9dcd448f05194cbf75c6b","modified":1737287194223},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1737287194224},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1737287194224},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1737287194222},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1737287194224},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1737287194223},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1737287194224},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1737287194223},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1737287194223},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1737287194230},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1737287194223},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1737287194229},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1737287194229},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1737287194229},{"_id":"themes/fluid/source/css/main.styl","hash":"ff1a17fcfbee8c80bdb586046c0e788e64b31e66","modified":1737287194230},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1737287194230},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1737287194231},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1737287194230},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1737287194230},{"_id":"themes/fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1737287194231},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1737287194231},{"_id":"themes/fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1737287194231},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1737287194231},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1737287194231},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1737287194231},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1737287194232},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1737287194232},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1737287194215},{"_id":"themes/fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1737287194231},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1737287194215},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1737287194216},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1737287194218},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1737287194218},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1737287194218},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"be1155c955904c8d91251d9270eee4482e5f0536","modified":1737716982016},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1737287194217},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1737287194218},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1737287194221},{"_id":"themes/fluid/scripts/events/lib/antd-icons.js","hash":"f8e2f9df089f6d7287c06233d84284a8b872420f","modified":1737287194220},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1737287194221},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1737287194221},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1737287194221},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1737287194217},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1737287194221},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1737287194221},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1737287194217},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1737287194229},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1737287194229},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1737287194221},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1737287194225},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1737287194228},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1737287194228},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1737287194228},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1737287194228},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1737287194228},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1737287194229},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1737287194229},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1737287194229},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1737287194229},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"d8eb7c7b76b70547d96701e9f4f5fb15f2fab907","modified":1737288708287},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1737287194225},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1737287194226},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1737287194227},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1737287194227},{"_id":"source/img/社会心理学.png","hash":"c9c128c4eec5c43793b46f64bbe65c4c3e248913","modified":1737287194206},{"_id":"source/img/2025-01-18-17-06-50.png","hash":"876ab15e17ea9dcea496b762bca7caf19c89fdec","modified":1737287194181},{"_id":"source/img/倦鸟.png","hash":"3d1326ddaa360899150a6857a8c96b50ea6c5e80","modified":1737287194198},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1737287194230},{"_id":"source/img/Aniya.png","hash":"97b6ac6164cda9614d8a8abdcc1eb78c3bb38f41","modified":1737287194184},{"_id":"source/img/sun.png","hash":"fea6d5ddff389d6bc7e3cfb0ef1f8d768fdaf202","modified":1737287194197},{"_id":"source/img/bgImg.png","hash":"8869c9029beef9c1240289e9fefc394972af5f64","modified":1737287194191},{"_id":"source/fonts/LXGWWenKaiGBScreen.ttf","hash":"e2139681d643e07e2ffb498fa3d656f6cba75afa","modified":1737287194171},{"_id":"public/css/custom.css","hash":"9394c276ecae6a9eb30237cc625002db76c263a0","modified":1739843490057},{"_id":"public/js/duration.js","hash":"feffbc1f875e5df4e5799175ade39ae6b8a756ec","modified":1739843490057},{"_id":"public/local-search.xml","hash":"d11ab753e7c66f55478fadcc4050ce10b4254239","modified":1740486637846},{"_id":"public/about/index.html","hash":"d6d662919c2d70554dac5425cf85297c2b48de7d","modified":1739848379104},{"_id":"public/2025/02/16/前后端/跨组件渲染/index.html","hash":"17331b7d5712785db8715fec08ee581454c71009","modified":1740486637846},{"_id":"public/2025/02/15/AI/AI-beginner/index.html","hash":"4c991a8fc1bd40288009e767f49fc9c622b36f35","modified":1739848379104},{"_id":"public/2025/02/14/编程语言/cpp学习记录/index.html","hash":"22e76c4874d05d336bd8b2c469de60b9ad74d7d5","modified":1740486637846},{"_id":"public/2025/02/12/其他/makefile/index.html","hash":"207dac063ebae0c5d9f321beab1dd51b9a77a90a","modified":1739848379104},{"_id":"public/2025/01/23/其他/themechange/index.html","hash":"ae26f776f2e75d22aa4fed231133278af6349cd1","modified":1739848379104},{"_id":"public/2025/01/22/关系数据库/index.html","hash":"d40ed34c03688bd74138f5572cd078a094b4fe39","modified":1739848379104},{"_id":"public/2025/01/20/前后端/响应式设计/index.html","hash":"e72bcb45580728c06002a3abfd88cf2ec34f5f96","modified":1739848379104},{"_id":"public/2025/01/18/Re0/index.html","hash":"4db46b47f2948c99596991c4eab866386664a42c","modified":1739848379104},{"_id":"public/2025/01/18/其他/认证配置/index.html","hash":"111d4e9c48102fd36c06e682b92bf2f6da05bf30","modified":1739848379104},{"_id":"public/2025/01/17/其他/Tmux/index.html","hash":"fc3fc86fe3f5b312e18d5a7b1ff554e0f969262e","modified":1739848379104},{"_id":"public/2025/01/17/其他/SSH隧道/index.html","hash":"0fee65c29cd6487a5aff4923e0a7c60cece8a045","modified":1739848379104},{"_id":"public/2025/01/16/前后端/CORS/index.html","hash":"53ccf08e2bbf2d8b8b77dc48e381b666d2e291a1","modified":1739848379104},{"_id":"public/2025/01/15/其他/pip-tools/index.html","hash":"cf5711918ccbb643a8f60f9291bf99fd983fb1c6","modified":1739848379104},{"_id":"public/2025/01/09/poets/晚霞/index.html","hash":"a202933afc5da9a2758474d2d5c572c7406a64c4","modified":1739848379104},{"_id":"public/2025/01/09/编程语言/JavaScript/index.html","hash":"2a1cfe2854395e289834aecc66bee721aa1deefa","modified":1739848379104},{"_id":"public/2025/01/09/社会心理学/index.html","hash":"a09c76c5a937ec1069b6099eccb48eb9c7b3ed59","modified":1739848379104},{"_id":"public/2025/01/08/其他/媒体查询/index.html","hash":"f5411fa7abfbbf92adec4b9613c1b18c11ff5a12","modified":1739848379104},{"_id":"public/2025/01/08/编程语言/css笔记/index.html","hash":"0ab80e3fc8f101f84417beb93e442b64f4711d1d","modified":1739848379104},{"_id":"public/2025/01/08/poets/bird/index.html","hash":"8f7a00204729eddabec1a42353a3a6a077f2f3ed","modified":1739848379104},{"_id":"public/2025/01/08/建站第一天/index.html","hash":"56b6552274766f15a5a33bfbc0f3ee4812a233be","modified":1739848379104},{"_id":"public/archives/index.html","hash":"fb4dbbd464849a05f19998f96a4599a440209c6a","modified":1740486637846},{"_id":"public/archives/page/2/index.html","hash":"6b5827cb95868c7e17c1a4fdb0bec6ee7ef92990","modified":1740486637846},{"_id":"public/archives/2025/index.html","hash":"4f8b8110af051cf168cb72f70e44f6243d8fe676","modified":1740486637846},{"_id":"public/archives/2025/page/2/index.html","hash":"b08f4f1bd8cafa2cb4102c117dfb4bf254c17551","modified":1740486637846},{"_id":"public/archives/2025/01/index.html","hash":"7196f2f672a773466c2476c86b99ecf8cf5e6cc1","modified":1740486637846},{"_id":"public/archives/2025/01/page/2/index.html","hash":"082855ea18a53bda92a628db472c788851c8c449","modified":1740486637846},{"_id":"public/archives/2025/02/index.html","hash":"ec285a6db4f07bb5a6adf41072aff9b9aa26a00c","modified":1740486637846},{"_id":"public/categories/生活碎碎念/index.html","hash":"1490cc95e684d5876914ebe4abfbadd3983f0005","modified":1739848379104},{"_id":"public/categories/兴趣阅读/index.html","hash":"09527df7d7bb17a4082d44e744466a65a3ee56df","modified":1739848379104},{"_id":"public/categories/随机掉落的文字碎片/index.html","hash":"712d55f7d15e38cb620fc836af3e338fc95437a0","modified":1739848379104},{"_id":"public/categories/学习笔记/index.html","hash":"1fec209ae0663738879daaac74f5408eb954c927","modified":1739848379104},{"_id":"public/categories/通用技能/index.html","hash":"1fd1c77a3d8f908c53b3c68b8ee4697b503404b5","modified":1739848379104},{"_id":"public/index.html","hash":"4fd59603a85728d04d92b19bedb5ed0616c9c9ba","modified":1740486637846},{"_id":"public/page/2/index.html","hash":"99dbc4ee1428dd62f9453c32ff7f499701a7036a","modified":1740486637846},{"_id":"public/tags/追番/index.html","hash":"0a1de5a01721dc5941893612f4bb6714f93dc3cf","modified":1739848379104},{"_id":"public/tags/心理学/index.html","hash":"7fe27f01d99e0c9c072800f1b1df70179d3464b2","modified":1739848379104},{"_id":"public/tags/杂记/index.html","hash":"c397bf45a4260aee58d91c94ae5ef231615af1f3","modified":1739848379104},{"_id":"public/tags/短诗/index.html","hash":"747308594188921ae4cd6a7be282b18b5d2f4d21","modified":1739848379104},{"_id":"public/tags/她/index.html","hash":"aaa46551df421d3cfb9ec4eb9fdd8bea08403749","modified":1739848379104},{"_id":"public/tags/自然/index.html","hash":"133960420238f704104bf082ae7b27cce550cbf2","modified":1739848379104},{"_id":"public/tags/前后端交互/index.html","hash":"44983062d8cde7fbcdf2d292b9602f00358e4b62","modified":1739848379104},{"_id":"public/tags/网站开发/index.html","hash":"7cafd8a7191b1f77204f16efebefa84aff12a9c6","modified":1739848379104},{"_id":"public/tags/ssh/index.html","hash":"b5dbc5b73e133eb97ea1891a848463b2cdaea693","modified":1739848379104},{"_id":"public/tags/前端/index.html","hash":"5c52e7e9a1a6cd6c70d775ba9531d520cf70315b","modified":1739848379104},{"_id":"public/tags/服务器/index.html","hash":"8ae376ac7ab886735daab70530442b6323ddaeed","modified":1739848379104},{"_id":"public/tags/CSS/index.html","hash":"50eec55b794b1b18ba424b4f399ada7b62b132be","modified":1739848379104},{"_id":"public/tags/多会话管理/index.html","hash":"3ad71192f8c07175e368998325a53166a1321c01","modified":1739848379104},{"_id":"public/tags/python/index.html","hash":"a894e68919b183cda998befcda601003698105de","modified":1739848379104},{"_id":"public/tags/环境配置/index.html","hash":"1859458311b044574a341f079652be1e730a4e55","modified":1739848379104},{"_id":"public/tags/PAT/index.html","hash":"d1acaa6bab37ef40981584325540ebfabac9ca64","modified":1739848379104},{"_id":"public/tags/JS/index.html","hash":"cb202eec7bf53d4985722a1120db9a16b1308545","modified":1739848379104},{"_id":"public/404.html","hash":"b94503fda1502e2fcdb7569494b2395f383c771a","modified":1739848379104},{"_id":"public/tags/index.html","hash":"da124c2c987110666deebdaac0b394d35228f7c4","modified":1740486637846},{"_id":"public/categories/index.html","hash":"7249292ce463ba4ffbf5e3f1aa37480c8c80acff","modified":1740486637846},{"_id":"public/links/index.html","hash":"5201739333de854cbea4bd9f7a0802df19ae1d13","modified":1739848379104},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1739843490057},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1739843490057},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1739843490057},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1739843490057},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1739843490057},{"_id":"public/img/2025-01-17-14-00-36.png","hash":"eacdd40a31bb3f4ccec48b38aa01d9e4f4a000d5","modified":1739843490057},{"_id":"public/img/JS.png","hash":"a115cbbec848dea5824181ef22411d8efc6dbfa8","modified":1739843490057},{"_id":"public/img/find-2025-01-22-11-58-20.png","hash":"a889d1dd151686eb085de78836a2cc7e59a43606","modified":1739843490057},{"_id":"public/img/legend-2025-01-21-21-19-51.png","hash":"c56fc82db2388050164829230deac64751c69ea6","modified":1739843490057},{"_id":"public/img/猫猫-2025-01-20-22-47-27.png","hash":"91d8cfe3cb9673a851c50fc6351c91b9cb54bb60","modified":1739843490057},{"_id":"public/img/2025-01-16-23-58-21.png","hash":"3707c7284cdeaada1b82a50889d6bc5b66cfab69","modified":1739843490057},{"_id":"public/img/2025-01-18-11-41-54.png","hash":"1d85d673eebe40136f7058b03e7d4aa3d2760b14","modified":1739843490057},{"_id":"public/img/2025-01-18-13-01-29.png","hash":"6dbe8216f8848a8f202de965f4313dbb2eecdd58","modified":1739843490057},{"_id":"public/img/2025-01-18-12-58-38.png","hash":"cf5073b3f0fcc5f8e8b013927dc633cdb0eb478b","modified":1739843490057},{"_id":"public/img/great.jpg","hash":"ad40b86f9b500d362074fe888853c2536ba6e834","modified":1739843490057},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1739843490057},{"_id":"public/css/highlight-dark.css","hash":"fccb2ef611250f9f5a38f3a2506ded52309e13ce","modified":1739843490057},{"_id":"public/css/main.css","hash":"c0a15af485b1cae62e9188ecd86f95e5e9ffe5a6","modified":1739843490057},{"_id":"public/css/highlight.css","hash":"fccb2ef611250f9f5a38f3a2506ded52309e13ce","modified":1739843490057},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1739843490057},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1739843490057},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1739843490057},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1739843490057},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1739843490057},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1739843490057},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1739843490057},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1739843490057},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1739843490057},{"_id":"public/img/2025-01-18-13-03-21.png","hash":"25abaf57c0e17909b165180aaf9d390fe09d6c5a","modified":1739843490057},{"_id":"public/img/2025-01-18-13-09-11.png","hash":"47c213fc9292190467b8b6f0e19b9408dbe6824f","modified":1739843490057},{"_id":"public/img/Aniya_放大镜.jpg","hash":"538ff8e7ac38f341c0166820d43617d73675cc86","modified":1739843490057},{"_id":"public/img/不死鸟.jpg","hash":"0baad7c3a94594079f49165c91f061d0689c1035","modified":1739843490057},{"_id":"public/img/晚霞.jpg","hash":"c89abcb798ddb518b6e8ce08e8afd144b00e8a54","modified":1739843490057},{"_id":"public/img/2025-01-18-11-45-41.png","hash":"f9cf4255cce7bad9cfbe29c5264b022933a64c30","modified":1739843490057},{"_id":"public/img/2025-01-18-17-13-45.png","hash":"b4d0e8077ffe69dfd61db955e869126b24c76ce0","modified":1739843490057},{"_id":"public/img/me.jpg","hash":"bdfdab38c41980cff966c08ea26ca8699948cbd6","modified":1739843490057},{"_id":"public/img/料理的加护.jpg","hash":"6364a3389f2ac52ad1ec33c254ebde8740b257cc","modified":1739843490057},{"_id":"public/img/闪光拉姆.jpg","hash":"8e818cc9cee33324fb15a8d52fc69b1262cf87e2","modified":1739843490057},{"_id":"public/img/哭哭帕克.jpg","hash":"e20aa94b2a43c0194fb3d3a5d0762b6404458003","modified":1739843490057},{"_id":"public/img/雪国.jpg","hash":"e1cc8027328cbc55de92496f1e7c90d3812923b7","modified":1739843490057},{"_id":"public/img/闪耀pack.jpg","hash":"470edf49958168295976933a0135d5517954cdba","modified":1739843490057},{"_id":"public/img/2025-01-18-17-14-29.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1739843490057},{"_id":"public/img/re0-2025-01-18-17-40-27.png","hash":"0f759367f3fa09abcf03a7e92ec340f38e133142","modified":1739843490057},{"_id":"public/img/re0-2025-01-18-17-16-53.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1739843490057},{"_id":"public/img/跨域共享.jpg","hash":"438d4dda0d2271203947bb461416275504601355","modified":1739843490057},{"_id":"public/img/雷姆拉姆.jpg","hash":"a3360d4afcc99266225d67003a06a133a2a8ecc7","modified":1739843490057},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1739843490057},{"_id":"public/img/2025-01-18-13-15-38.png","hash":"a5774370c2e3ac61a14b5847c2c77ea69afecbfe","modified":1739843490057},{"_id":"public/img/2025-01-18-13-23-22.png","hash":"0c9345d1f0c9af7bc07f7bbf7a15153d4b16aea7","modified":1739843490057},{"_id":"public/img/2025-01-18-17-11-36.png","hash":"404b6f149798b76095753ac52d034516b37c1555","modified":1739843490057},{"_id":"public/img/照镜子.jpg","hash":"204a3b9a70ad3381fc5c2b78d3fc9afdecc2d995","modified":1739843490057},{"_id":"public/img/校长帕克.jpg","hash":"dbc8efb5b99bf953032dac803a4ea7ac1166974e","modified":1739843490057},{"_id":"public/img/社会心理学.png","hash":"c9c128c4eec5c43793b46f64bbe65c4c3e248913","modified":1739843490057},{"_id":"public/img/2025-01-18-17-06-50.png","hash":"876ab15e17ea9dcea496b762bca7caf19c89fdec","modified":1739843490057},{"_id":"public/img/倦鸟.png","hash":"3d1326ddaa360899150a6857a8c96b50ea6c5e80","modified":1739843490057},{"_id":"public/img/Aniya.png","hash":"97b6ac6164cda9614d8a8abdcc1eb78c3bb38f41","modified":1739843490057},{"_id":"public/img/sun.png","hash":"fea6d5ddff389d6bc7e3cfb0ef1f8d768fdaf202","modified":1739843490057},{"_id":"public/img/bgImg.png","hash":"8869c9029beef9c1240289e9fefc394972af5f64","modified":1739843490057},{"_id":"public/fonts/LXGWWenKaiGBScreen.ttf","hash":"e2139681d643e07e2ffb498fa3d656f6cba75afa","modified":1739843490057},{"_id":"source/_posts/cryptography.md","hash":"49c4baef183477838ecba1a0ef0de1a48660eb0e","modified":1739951220833},{"_id":"source/_posts/大二春夏/数据库系统.md","hash":"a3f956c7bac0b9d103763ff715db4bc78d304a0a","modified":1740367171057},{"_id":"source/_posts/latex.md","hash":"11723baf720a3c2e9300f6ed8365d6973e920730","modified":1740207335810},{"_id":"source/_posts/大二春夏/cryptography.md","hash":"22b26d015ae0f9f5091e000fb4a94aa91ff248bf","modified":1740362068795},{"_id":"source/img/2025-02-22-17-31-07.png","hash":"871d6685b8e56a17c70fd61c593069028c921c89","modified":1740216669405},{"_id":"source/_posts/.DS_Store","hash":"e0c5cbfba8e822e0a972d2ccc2ea218341200d92","modified":1740726621038},{"_id":"source/img/2025-02-22-17-32-24.png","hash":"bbee779d7e09ccdc3fbea15aae942f996a3ffd19","modified":1740216745950},{"_id":"source/img/2025-02-22-17-27-31.png","hash":"e2bc35ebd8fa8c880eeab874c6618a50834a85b2","modified":1740216459444},{"_id":"source/img/db_index.png","hash":"a93dad5a557fbb0869d1570638b4d2aa00474ec8","modified":1740289288918},{"_id":"source/_posts/编程语言/cpp学习记录.assets/image-20250225160042809.png","hash":"4a02128e5a8f5b793b812ae89ea54ab0f4e9912e","modified":1740470442809},{"_id":"source/_posts/编程语言/cpp学习记录.assets/image-20250225160652522.png","hash":"046e675e218efdf36cb967256f7a25e52508f8a6","modified":1740470812523},{"_id":"source/img/crypt_index.png","hash":"cbdb5c4cf5938dfb15001186a76e20e25e498122","modified":1740289983404},{"_id":"public/2025/02/20/大二春夏/数据库系统/index.html","hash":"90595a7f3301bb43f6fc49124db8592187a8cf1d","modified":1740486637846},{"_id":"public/2025/02/19/大二春夏/cryptography/index.html","hash":"1c407ef603a852fb8833cf72ed0a1ed49cc9e408","modified":1740486637846},{"_id":"public/2025/02/19/latex/index.html","hash":"2084ee1db85d3491eaee6ef16affc8a204f5cf80","modified":1740486637846},{"_id":"public/categories/备忘录/index.html","hash":"081afc4506e1bf028fa572136e4fb5d3fd25f5e5","modified":1740486637846},{"_id":"public/categories/课程笔记/index.html","hash":"8177c52256e31e3bf5036e841a6db43d2f443800","modified":1740486637846},{"_id":"public/archives/page/3/index.html","hash":"1b80aa6091b6854f7e9832eb65efe05e7e21c3d1","modified":1740486637846},{"_id":"public/archives/2025/page/3/index.html","hash":"c65d6bf77f958165cf27369dfbea88f8cdf06cb4","modified":1740486637846},{"_id":"public/tags/latex/index.html","hash":"28cf7c9e3306f06d6d597c5bbe9d12c309e07850","modified":1740486637846},{"_id":"public/img/crypt_index.png","hash":"cbdb5c4cf5938dfb15001186a76e20e25e498122","modified":1740486637846},{"_id":"public/img/db_index.png","hash":"a93dad5a557fbb0869d1570638b4d2aa00474ec8","modified":1740486637846},{"_id":"source/_posts/temp_notes/.gitattributes","hash":"ba3dfe345280bdcc5e817bb02cf49b8b8d8e1c4c","modified":1740367039345},{"_id":"source/_posts/temp_notes/体系结构随笔.md","hash":"09186d8ebf15e8e35220a188eb566b8975ea4e31","modified":1740366803946},{"_id":"source/_posts/temp_notes/汇编基础.md","hash":"8c6abd904235f5cf135f76b913bbd671245aee2b","modified":1740497406822},{"_id":"source/_posts/temp_notes/.git/HEAD","hash":"9f1df7eea4156be8a871c292b549b3325e425aa2","modified":1740367039092},{"_id":"source/_posts/temp_notes/数据库系统.md","hash":"9a16cdfe10ef08eae136d965c20c56ff6d155107","modified":1740457407448},{"_id":"source/_posts/temp_notes/.git/config","hash":"a86fa3917ad19be73cf8faeba658d72542a64a97","modified":1740497542877},{"_id":"source/_posts/temp_notes/.DS_Store","hash":"1c54e947002a532eb478c2d4b0ded137de1ba279","modified":1740497431048},{"_id":"source/_posts/temp_notes/.git/index","hash":"480b7bfd6dee41566cb5ffa900f1913381efadd7","modified":1740377430904},{"_id":"source/_posts/temp_notes/.git/FETCH_HEAD","hash":"0dcac349c669b191463cb3d59f01c2c6c5e5643e","modified":1740497459408},{"_id":"source/_posts/temp_notes/cryptography.md","hash":"cf4229d8802be5c304f0d9e538d993742f68fe14","modified":1740398940664},{"_id":"source/_posts/temp_notes/lab1_report.md","hash":"a372e80b0b5a9c5f77cd6abbc6ffb93fe5c40fa3","modified":1740389076554},{"_id":"source/_posts/temp_notes/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1740367039087},{"_id":"source/_posts/temp_notes/.git/COMMIT_EDITMSG","hash":"3781966d574854610daa942c778e93f8b3768629","modified":1740377430905},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250224214646008.png","hash":"b1e1be8039bcad27b63b029020b01bba6eeaf722","modified":1740404806009},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250224223816689.png","hash":"ee57fd6e5f070eebedbb6f70753db52f351a2e02","modified":1740407896689},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250224221730846.png","hash":"a025ac877d607d9de27589662a836c4951671439","modified":1740406650846},{"_id":"source/_posts/temp_notes/assets/2025-02-22-17-31-07.png","hash":"871d6685b8e56a17c70fd61c593069028c921c89","modified":1740216669405},{"_id":"source/_posts/temp_notes/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1740367039087},{"_id":"source/_posts/temp_notes/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1740367039087},{"_id":"source/_posts/temp_notes/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1740367039088},{"_id":"source/_posts/temp_notes/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1740367039087},{"_id":"source/_posts/temp_notes/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1740367039089},{"_id":"source/_posts/temp_notes/.git/objects/21/6042c2843e5ead8f3ebe503229bd21292d02c6","hash":"159ab6d8de127a5fc522e3f9761d71611753abc0","modified":1740377430897},{"_id":"source/_posts/temp_notes/.git/refs/heads/main","hash":"03222969e3433da9e873b8979d6d898da4f7f387","modified":1740377430906},{"_id":"source/_posts/temp_notes/.git/objects/2b/51135219333e371aba9b5a879b53c2c39f136e","hash":"8ceccadd846566f443969112228e311667fe586f","modified":1740377193375},{"_id":"source/_posts/temp_notes/.git/objects/37/0d41c41a94e4cdfd1c9a1ffe0bb0806a6620f8","hash":"50c822220c102a002949eff37c7d1271b7afb2bc","modified":1740377430904},{"_id":"source/_posts/temp_notes/.git/logs/HEAD","hash":"ed8a04cc8ba5de8e01b43da28d65cac4d7f4a2e2","modified":1740377430906},{"_id":"source/_posts/temp_notes/.git/objects/39/c4018732912c9bd6ec20aca571e62eb81329d1","hash":"77fea3c5215a487740799784139a65326c31166b","modified":1740377193367},{"_id":"source/_posts/temp_notes/.git/objects/36/cf6431283125fe6e16c1843dd0caa4977643fb","hash":"02d58ebfbb2935cb4e5969c1deefc6918799bd6d","modified":1740377193305},{"_id":"source/_posts/temp_notes/.git/objects/5a/8602581b3e9f54780caa8e893d579231ff9b2d","hash":"999ae6f959ba0c07b32d855892ae26ce107ac2e4","modified":1740377193366},{"_id":"source/_posts/temp_notes/.git/objects/6f/9509c88bed7080d496fc5e1d87a9315e30549d","hash":"e6f8cccbb220f1b344f9df0de6a7297195d4e3f0","modified":1740367039365},{"_id":"source/_posts/temp_notes/.git/objects/a5/6c9098773cf107b5c1b171e603a2a71f291a93","hash":"9eaea30c3b087dad1a73f0f36d379fdfb73ff82a","modified":1740377430904},{"_id":"source/_posts/temp_notes/.git/objects/c2/dd7981dace189712ba7b0857ff1ad959a8c584","hash":"2d8d4262c2b98a63530b62eabde010d8f1608f7d","modified":1740377193373},{"_id":"source/_posts/temp_notes/.git/objects/e3/a3da01bef08cb3508b4380c2b3ae234ed67b49","hash":"63b39ab683021d8087cade2c8d674625ac99c337","modified":1740367039367},{"_id":"source/_posts/temp_notes/.git/objects/df/e0770424b2a19faf507a501ebfc23be8f54e7b","hash":"558bc46f3351b99c9cca96307eb4af519e2a6f4d","modified":1740367039361},{"_id":"source/_posts/temp_notes/.git/objects/eb/7a86517a294a616ba977bd0691b117649c7754","hash":"26d38cce45b95a53446e6faa2b901332ee7e3d98","modified":1740377193292},{"_id":"source/_posts/temp_notes/.git/objects/c8/d5d66dbfc82e1312c4ebde64ac866fe21d2550","hash":"3d4f1b1c92ec5aee7f56e4d7d561e74de64fadfd","modified":1740377193367},{"_id":"source/_posts/temp_notes/.git/objects/f6/db7ea67f0ed40a1c95c3ddc5b9d1c6d91a1595","hash":"25f28c0e8bbfdebdf06cdbee719901ea7cc2e700","modified":1740377430905},{"_id":"source/_posts/temp_notes/.git/refs/remotes/origin/HEAD","hash":"5ae7c22895c35af5f56ba1891a4dd62b4dc1f955","modified":1740497461102},{"_id":"source/_posts/temp_notes/.git/objects/e8/6b332959c9f1758017c55691a220d4e1972067","hash":"d8bd52df1d7c2ac2599347dc5723c2b441f1b7aa","modified":1740377430847},{"_id":"source/_posts/temp_notes/.git/logs/refs/remotes/origin/HEAD","hash":"2064f74c90f0565d75a89f942add3fec3bb7e897","modified":1740497461101},{"_id":"source/_posts/temp_notes/.git/refs/remotes/origin/main","hash":"03222969e3433da9e873b8979d6d898da4f7f387","modified":1740377435538},{"_id":"source/_posts/temp_notes/.git/logs/refs/heads/main","hash":"ed8a04cc8ba5de8e01b43da28d65cac4d7f4a2e2","modified":1740377430906},{"_id":"source/_posts/temp_notes/.git/objects/39/0d720e4f240ff2ecb836ae67e285a17fa29064","hash":"40892fbd38213f69f899eaec64e86b8659183532","modified":1740377193373},{"_id":"source/_posts/temp_notes/.git/logs/refs/remotes/origin/main","hash":"6418a24661499fed520c0668fbdab44b861582c9","modified":1740377435540},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250225121938529.png","hash":"e2a609f94bc8f109c878cf118df4f24815ca10a3","modified":1740457178529},{"_id":"source/_posts/temp_notes/assets/image-20250223145841793.png","hash":"0b3769027fd77f6ef6bfb85821870c360ddda21b","modified":1740293921793},{"_id":"source/_posts/temp_notes/.git/objects/57/6cf2ad4c0d0d812c23c55efe904cdba27402d3","hash":"753073c243038cc1a4f8a184620c64baf99811ae","modified":1740377193298},{"_id":"source/_posts/temp_notes/.git/objects/b1/c065f9610e3ecd4f762acb83b40d0be9b88a50","hash":"321aaa67c9892a99804e7d377053439a56bf6084","modified":1740377430872},{"_id":"source/_posts/temp_notes/.git/objects/d8/f45c568e463c69eea0b5cbd76679881195356a","hash":"106d7d71756f50ccb9c5f204765ae5a93cc4b616","modified":1740377430876},{"_id":"source/_posts/temp_notes/.git/objects/e5/d520c6f3c84ac76c4cfde62baa190de2606f95","hash":"f8388b8d417c93cc2f6801c7bdf5e4820888ff4d","modified":1740377430862},{"_id":"source/_posts/temp_notes/cryptography.assets/image-20250224195809124.png","hash":"150dc4650756d5703da94ed2b45470930bede8ea","modified":1740398289125},{"_id":"source/_posts/temp_notes/cryptography.assets/image-20250224195821189.png","hash":"b5975fe4d2be13c72ed6b3fff09c273d9f655cf7","modified":1740398301190},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250224220313846.png","hash":"f1171027e221f51f2805fbe82d631ab4be038dec","modified":1740405793846},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224165720059.png","hash":"3d94fb9eadf7ccb20a480fd55f765ae8f9d79cdd","modified":1740387440060},{"_id":"source/_posts/temp_notes/assets/2025-02-22-17-27-31.png","hash":"e2bc35ebd8fa8c880eeab874c6618a50834a85b2","modified":1740216459444},{"_id":"source/_posts/temp_notes/assets/2025-02-22-17-32-24.png","hash":"bbee779d7e09ccdc3fbea15aae942f996a3ffd19","modified":1740216745950},{"_id":"source/_posts/temp_notes/assets/image-20250223113231052.png","hash":"ef1b451e0525c6241a0ab3a94b8862030ec731ff","modified":1740281551052},{"_id":"source/_posts/temp_notes/assets/image-20250223114642120.png","hash":"485f38e9b6090953c3e7a2615878433f68d9e14b","modified":1740282402120},{"_id":"source/_posts/temp_notes/assets/image-20250223144526402.png","hash":"28dd003e883dd47fd64df43e7c930d9e8dcf49a4","modified":1740293126402},{"_id":"source/_posts/temp_notes/assets/image-20250223204007274.png","hash":"2f0b5fdae20ce0b18b0b9ac95eff487b8cead177","modified":1740314407275},{"_id":"source/_posts/temp_notes/assets/image-20250224085632929.png","hash":"2c49a72f65802eeb2c05cba28ce4e792fd9c9e0a","modified":1740358592930},{"_id":"source/_posts/temp_notes/assets/image-20250224084543612.png","hash":"aa58bfd7868ad2beae3c3ada33fc60b729b7466a","modified":1740357943613},{"_id":"source/_posts/temp_notes/assets/image-20250224090508036.png","hash":"1e7b862b9912d60c9c419c1bd7dd14f9e2a7f617","modified":1740359108037},{"_id":"source/_posts/temp_notes/assets/image-20250224090500018.png","hash":"1e7b862b9912d60c9c419c1bd7dd14f9e2a7f617","modified":1740359100019},{"_id":"source/_posts/temp_notes/assets/image-20250223114458272.png","hash":"485f38e9b6090953c3e7a2615878433f68d9e14b","modified":1740282298272},{"_id":"source/_posts/temp_notes/.git/objects/27/dc462dfd8c2255d7ffd37fd3a079b6099a6fe2","hash":"e082bdccade5ddd78157addb3e064d7e019ee33d","modified":1740377430889},{"_id":"source/_posts/temp_notes/.git/objects/02/9217fa556bdbdeb4e49eb96c63bdaa7657824f","hash":"a376e52dd559bad49b500bb47cae8c597080d294","modified":1740377430897},{"_id":"source/_posts/temp_notes/.git/objects/51/108fe82c984171dc1296d2d44388cc4f8c757f","hash":"efd4f104ebeba4466a9f7e769b76e9e061807cee","modified":1740377430882},{"_id":"source/_posts/temp_notes/.git/objects/ba/46298db971c4e65e73061ea0505c216ecbe521","hash":"a137d7de00ee1a38d8dfc1b54c83fb21060450c0","modified":1740377430867},{"_id":"source/_posts/temp_notes/.git/objects/bf/ea866bfa91f186e3c8b73b30f56816ba04d20b","hash":"1feecf0fb5dc9c0d19b2fc39c3304ff19e974dfc","modified":1740377193312},{"_id":"source/_posts/temp_notes/.git/objects/ef/b21c0f62a6078dafd1a5d7a8fbfd9fdc5c72c0","hash":"421c3cbd22fdf32b491db4832509984fdfb1a07c","modified":1740377430855},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250224224824019.png","hash":"b4a16d64c5c3fd83e8da40d75205b206d6553a5d","modified":1740408504019},{"_id":"source/_posts/temp_notes/assets/image-20250224111232739.png","hash":"09fdc63b8d33744a37ec706b7985c9cb3f2985be","modified":1740366752740},{"_id":"source/_posts/temp_notes/.git/objects/c6/26d24f860c3b47c7317421ebb1d88756428173","hash":"a1c8f706ffb8c1f86215213621dba1f4562b3904","modified":1740377193366},{"_id":"source/_posts/temp_notes/assets/image-20250224110839544.png","hash":"fde5fa1076e1991242d109b41374b4dfccc8aab9","modified":1740366519545},{"_id":"source/_posts/temp_notes/.git/objects/6f/6a67d710822fcdefaaf6cac332bb6ab0ef74b6","hash":"7b8a965bc0af94a94d0142a380a9333103e759a1","modified":1740377193351},{"_id":"source/_posts/temp_notes/数据库系统.assets/image-20250225103821388.png","hash":"c0e9de81ffa2084da570fae4c4bd14109e159759","modified":1740451101388},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224164548855.png","hash":"f998b44186da2794c49b114bc24e5083a168f684","modified":1740386748855},{"_id":"source/_posts/temp_notes/assets/image-20250224110830461.png","hash":"9deee8351d190b0441cf95445557835c30d5047b","modified":1740366510462},{"_id":"source/_posts/temp_notes/.git/objects/99/c8c99d3776812c9e1a2ce0ed1ef109caa35c2b","hash":"0d708138804d186ce0ec509abb396a02ce6a1a58","modified":1740377193334},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224162025072.png","hash":"c231450c1e63915bf525dd11b6c68c01f5dc9080","modified":1740385225072},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224163759935.png","hash":"a45ca4ef472891efc37ab65dade0f829d8a5cefc","modified":1740386279936},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224162724537.png","hash":"c9022b5c68a00583e52a3feaf972c2ce1f540529","modified":1740385644537},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224170529795.png","hash":"b0cb2087d496141c3e7e5603ec0f657e99f20229","modified":1740387929798},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224170548503.png","hash":"c18788d237798c512c99d63a171ab2b766a1c083","modified":1740387948505},{"_id":"source/_posts/temp_notes/lab1_report.assets/image-20250224170505856.png","hash":"1f49f7b47b3d3c6540a9a59946e54c3a22adde3d","modified":1740387905858},{"_id":"source/_drafts/temp_notes/assets/2025-02-22-17-31-07.png","hash":"871d6685b8e56a17c70fd61c593069028c921c89","modified":1740216669405},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250224214646008.png","hash":"b1e1be8039bcad27b63b029020b01bba6eeaf722","modified":1740404806009},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250224221730846.png","hash":"a025ac877d607d9de27589662a836c4951671439","modified":1740406650846},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250224223816689.png","hash":"ee57fd6e5f070eebedbb6f70753db52f351a2e02","modified":1740407896689},{"_id":"source/_drafts/temp_notes/assets/image-20250223145841793.png","hash":"0b3769027fd77f6ef6bfb85821870c360ddda21b","modified":1740293921793},{"_id":"source/_drafts/temp_notes/assets/image-20250223114458272.png","hash":"485f38e9b6090953c3e7a2615878433f68d9e14b","modified":1740282298272},{"_id":"source/_drafts/temp_notes/assets/image-20250223113231052.png","hash":"ef1b451e0525c6241a0ab3a94b8862030ec731ff","modified":1740281551052},{"_id":"source/_drafts/temp_notes/assets/2025-02-22-17-27-31.png","hash":"e2bc35ebd8fa8c880eeab874c6618a50834a85b2","modified":1740216459444},{"_id":"source/_drafts/temp_notes/assets/2025-02-22-17-32-24.png","hash":"bbee779d7e09ccdc3fbea15aae942f996a3ffd19","modified":1740216745950},{"_id":"source/_drafts/temp_notes/assets/image-20250223114642120.png","hash":"485f38e9b6090953c3e7a2615878433f68d9e14b","modified":1740282402120},{"_id":"source/_drafts/temp_notes/assets/image-20250223144526402.png","hash":"28dd003e883dd47fd64df43e7c930d9e8dcf49a4","modified":1740293126402},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250225121938529.png","hash":"e2a609f94bc8f109c878cf118df4f24815ca10a3","modified":1740457178529},{"_id":"source/_drafts/temp_notes/assets/image-20250223204007274.png","hash":"2f0b5fdae20ce0b18b0b9ac95eff487b8cead177","modified":1740314407275},{"_id":"source/_drafts/temp_notes/assets/image-20250224085632929.png","hash":"2c49a72f65802eeb2c05cba28ce4e792fd9c9e0a","modified":1740358592930},{"_id":"source/_drafts/temp_notes/assets/image-20250224084543612.png","hash":"aa58bfd7868ad2beae3c3ada33fc60b729b7466a","modified":1740357943613},{"_id":"source/_drafts/temp_notes/assets/image-20250224090500018.png","hash":"1e7b862b9912d60c9c419c1bd7dd14f9e2a7f617","modified":1740359100019},{"_id":"source/_drafts/temp_notes/assets/image-20250224090508036.png","hash":"1e7b862b9912d60c9c419c1bd7dd14f9e2a7f617","modified":1740359108037},{"_id":"source/_drafts/temp_notes/cryptography.assets/image-20250224195821189.png","hash":"b5975fe4d2be13c72ed6b3fff09c273d9f655cf7","modified":1740398301190},{"_id":"source/_drafts/temp_notes/cryptography.assets/image-20250224195809124.png","hash":"150dc4650756d5703da94ed2b45470930bede8ea","modified":1740398289125},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224165720059.png","hash":"3d94fb9eadf7ccb20a480fd55f765ae8f9d79cdd","modified":1740387440060},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250224220313846.png","hash":"f1171027e221f51f2805fbe82d631ab4be038dec","modified":1740405793846},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250224224824019.png","hash":"b4a16d64c5c3fd83e8da40d75205b206d6553a5d","modified":1740408504019},{"_id":"source/_drafts/temp_notes/assets/image-20250224111232739.png","hash":"09fdc63b8d33744a37ec706b7985c9cb3f2985be","modified":1740366752740},{"_id":"source/_drafts/temp_notes/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1740367039087},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1740367039089},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1740367039089},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1740367039089},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1740367039087},{"_id":"source/_drafts/temp_notes/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1740367039089},{"_id":"source/_drafts/temp_notes/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1740367039089},{"_id":"source/_drafts/temp_notes/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1740367039088},{"_id":"source/_drafts/temp_notes/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1740367039087},{"_id":"source/_drafts/temp_notes/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1740367039089},{"_id":"source/_drafts/temp_notes/assets/image-20250224110839544.png","hash":"fde5fa1076e1991242d109b41374b4dfccc8aab9","modified":1740366519545},{"_id":"source/_drafts/temp_notes/.git/refs/heads/main","hash":"03222969e3433da9e873b8979d6d898da4f7f387","modified":1740377430906},{"_id":"source/_drafts/temp_notes/.git/objects/21/6042c2843e5ead8f3ebe503229bd21292d02c6","hash":"159ab6d8de127a5fc522e3f9761d71611753abc0","modified":1740377430897},{"_id":"source/_drafts/temp_notes/.git/objects/2b/51135219333e371aba9b5a879b53c2c39f136e","hash":"8ceccadd846566f443969112228e311667fe586f","modified":1740377193375},{"_id":"source/_drafts/temp_notes/.git/objects/36/cf6431283125fe6e16c1843dd0caa4977643fb","hash":"02d58ebfbb2935cb4e5969c1deefc6918799bd6d","modified":1740377193305},{"_id":"source/_drafts/temp_notes/.git/objects/37/0d41c41a94e4cdfd1c9a1ffe0bb0806a6620f8","hash":"50c822220c102a002949eff37c7d1271b7afb2bc","modified":1740377430904},{"_id":"source/_drafts/temp_notes/.git/objects/39/0d720e4f240ff2ecb836ae67e285a17fa29064","hash":"40892fbd38213f69f899eaec64e86b8659183532","modified":1740377193373},{"_id":"source/_drafts/temp_notes/.git/objects/5a/8602581b3e9f54780caa8e893d579231ff9b2d","hash":"999ae6f959ba0c07b32d855892ae26ce107ac2e4","modified":1740377193366},{"_id":"source/_drafts/temp_notes/.git/objects/6f/9509c88bed7080d496fc5e1d87a9315e30549d","hash":"e6f8cccbb220f1b344f9df0de6a7297195d4e3f0","modified":1740367039365},{"_id":"source/_drafts/temp_notes/.git/objects/a5/6c9098773cf107b5c1b171e603a2a71f291a93","hash":"9eaea30c3b087dad1a73f0f36d379fdfb73ff82a","modified":1740377430904},{"_id":"source/_drafts/temp_notes/.git/objects/c2/dd7981dace189712ba7b0857ff1ad959a8c584","hash":"2d8d4262c2b98a63530b62eabde010d8f1608f7d","modified":1740377193373},{"_id":"source/_drafts/temp_notes/.git/objects/39/c4018732912c9bd6ec20aca571e62eb81329d1","hash":"77fea3c5215a487740799784139a65326c31166b","modified":1740377193367},{"_id":"source/_drafts/temp_notes/.git/objects/c8/d5d66dbfc82e1312c4ebde64ac866fe21d2550","hash":"3d4f1b1c92ec5aee7f56e4d7d561e74de64fadfd","modified":1740377193367},{"_id":"source/_drafts/temp_notes/.git/objects/e3/a3da01bef08cb3508b4380c2b3ae234ed67b49","hash":"63b39ab683021d8087cade2c8d674625ac99c337","modified":1740367039367},{"_id":"source/_drafts/temp_notes/.git/objects/eb/7a86517a294a616ba977bd0691b117649c7754","hash":"26d38cce45b95a53446e6faa2b901332ee7e3d98","modified":1740377193292},{"_id":"source/_drafts/temp_notes/.git/objects/e8/6b332959c9f1758017c55691a220d4e1972067","hash":"d8bd52df1d7c2ac2599347dc5723c2b441f1b7aa","modified":1740377430847},{"_id":"source/_drafts/temp_notes/.git/objects/f6/db7ea67f0ed40a1c95c3ddc5b9d1c6d91a1595","hash":"25f28c0e8bbfdebdf06cdbee719901ea7cc2e700","modified":1740377430905},{"_id":"source/_drafts/temp_notes/assets/image-20250224110830461.png","hash":"9deee8351d190b0441cf95445557835c30d5047b","modified":1740366510462},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224164548855.png","hash":"f998b44186da2794c49b114bc24e5083a168f684","modified":1740386748855},{"_id":"source/_drafts/temp_notes/.git/objects/df/e0770424b2a19faf507a501ebfc23be8f54e7b","hash":"558bc46f3351b99c9cca96307eb4af519e2a6f4d","modified":1740367039361},{"_id":"source/_drafts/temp_notes/.git/objects/57/6cf2ad4c0d0d812c23c55efe904cdba27402d3","hash":"753073c243038cc1a4f8a184620c64baf99811ae","modified":1740377193298},{"_id":"source/_drafts/temp_notes/.git/objects/b1/c065f9610e3ecd4f762acb83b40d0be9b88a50","hash":"321aaa67c9892a99804e7d377053439a56bf6084","modified":1740377430872},{"_id":"source/_drafts/temp_notes/.git/objects/d8/f45c568e463c69eea0b5cbd76679881195356a","hash":"106d7d71756f50ccb9c5f204765ae5a93cc4b616","modified":1740377430876},{"_id":"source/_drafts/temp_notes/.git/objects/e5/d520c6f3c84ac76c4cfde62baa190de2606f95","hash":"f8388b8d417c93cc2f6801c7bdf5e4820888ff4d","modified":1740377430862},{"_id":"source/_drafts/temp_notes/.git/objects/27/dc462dfd8c2255d7ffd37fd3a079b6099a6fe2","hash":"e082bdccade5ddd78157addb3e064d7e019ee33d","modified":1740377430889},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250225103821388.png","hash":"c0e9de81ffa2084da570fae4c4bd14109e159759","modified":1740451101388},{"_id":"source/_drafts/temp_notes/.git/objects/02/9217fa556bdbdeb4e49eb96c63bdaa7657824f","hash":"a376e52dd559bad49b500bb47cae8c597080d294","modified":1740377430897},{"_id":"source/_drafts/temp_notes/.git/HEAD","hash":"9f1df7eea4156be8a871c292b549b3325e425aa2","modified":1740367039092},{"_id":"source/_drafts/temp_notes/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1740367039087},{"_id":"source/_drafts/temp_notes/.git/FETCH_HEAD","hash":"0dcac349c669b191463cb3d59f01c2c6c5e5643e","modified":1740497459408},{"_id":"source/_drafts/temp_notes/.git/COMMIT_EDITMSG","hash":"3781966d574854610daa942c778e93f8b3768629","modified":1740377430905},{"_id":"source/_drafts/temp_notes/.git/index","hash":"480b7bfd6dee41566cb5ffa900f1913381efadd7","modified":1740377430904},{"_id":"source/_drafts/temp_notes/.git/logs/HEAD","hash":"ed8a04cc8ba5de8e01b43da28d65cac4d7f4a2e2","modified":1740377430906},{"_id":"source/_drafts/temp_notes/.git/config","hash":"a86fa3917ad19be73cf8faeba658d72542a64a97","modified":1740497542877},{"_id":"source/_drafts/temp_notes/.git/logs/refs/heads/main","hash":"ed8a04cc8ba5de8e01b43da28d65cac4d7f4a2e2","modified":1740377430906},{"_id":"source/_drafts/temp_notes/.git/logs/refs/remotes/origin/HEAD","hash":"f5e156668bdeab944949c0eb472cb5e50e68576b","modified":1740657146849},{"_id":"source/_drafts/temp_notes/.git/refs/remotes/origin/main","hash":"03222969e3433da9e873b8979d6d898da4f7f387","modified":1740377435538},{"_id":"source/_drafts/temp_notes/.git/refs/remotes/origin/HEAD","hash":"5ae7c22895c35af5f56ba1891a4dd62b4dc1f955","modified":1740497461102},{"_id":"source/_drafts/temp_notes/.git/logs/refs/remotes/origin/main","hash":"6418a24661499fed520c0668fbdab44b861582c9","modified":1740377435540},{"_id":"source/_drafts/temp_notes/.git/objects/51/108fe82c984171dc1296d2d44388cc4f8c757f","hash":"efd4f104ebeba4466a9f7e769b76e9e061807cee","modified":1740377430882},{"_id":"source/_drafts/temp_notes/.git/objects/ba/46298db971c4e65e73061ea0505c216ecbe521","hash":"a137d7de00ee1a38d8dfc1b54c83fb21060450c0","modified":1740377430867},{"_id":"source/_drafts/temp_notes/.git/objects/bf/ea866bfa91f186e3c8b73b30f56816ba04d20b","hash":"1feecf0fb5dc9c0d19b2fc39c3304ff19e974dfc","modified":1740377193312},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224162025072.png","hash":"c231450c1e63915bf525dd11b6c68c01f5dc9080","modified":1740385225072},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224163759935.png","hash":"a45ca4ef472891efc37ab65dade0f829d8a5cefc","modified":1740386279936},{"_id":"source/_drafts/temp_notes/.git/objects/ef/b21c0f62a6078dafd1a5d7a8fbfd9fdc5c72c0","hash":"421c3cbd22fdf32b491db4832509984fdfb1a07c","modified":1740377430855},{"_id":"source/_drafts/temp_notes/cryptography.md","hash":"cf4229d8802be5c304f0d9e538d993742f68fe14","modified":1740398940664},{"_id":"source/_drafts/temp_notes/lab1_report.md","hash":"a372e80b0b5a9c5f77cd6abbc6ffb93fe5c40fa3","modified":1740389076554},{"_id":"source/_drafts/temp_notes/体系结构随笔.md","hash":"09186d8ebf15e8e35220a188eb566b8975ea4e31","modified":1740366803946},{"_id":"source/_drafts/temp_notes/.gitattributes","hash":"ba3dfe345280bdcc5e817bb02cf49b8b8d8e1c4c","modified":1740367039345},{"_id":"source/_drafts/temp_notes/数据库系统.md","hash":"4b285b02a03f5c9d90f58e615cfe10e274c1d365","modified":1740715760997},{"_id":"source/_drafts/temp_notes/汇编基础.md","hash":"8c6abd904235f5cf135f76b913bbd671245aee2b","modified":1740497406822},{"_id":"source/_drafts/temp_notes/.DS_Store","hash":"60ff611d72aec59ac810ec4ac3298e65bc57282b","modified":1740712775948},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224162724537.png","hash":"c9022b5c68a00583e52a3feaf972c2ce1f540529","modified":1740385644537},{"_id":"source/_drafts/temp_notes/.git/objects/c6/26d24f860c3b47c7317421ebb1d88756428173","hash":"a1c8f706ffb8c1f86215213621dba1f4562b3904","modified":1740377193366},{"_id":"source/_drafts/temp_notes/.git/objects/6f/6a67d710822fcdefaaf6cac332bb6ab0ef74b6","hash":"7b8a965bc0af94a94d0142a380a9333103e759a1","modified":1740377193351},{"_id":"source/_drafts/temp_notes/.git/objects/99/c8c99d3776812c9e1a2ce0ed1ef109caa35c2b","hash":"0d708138804d186ce0ec509abb396a02ce6a1a58","modified":1740377193334},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224170505856.png","hash":"1f49f7b47b3d3c6540a9a59946e54c3a22adde3d","modified":1740387905858},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224170529795.png","hash":"b0cb2087d496141c3e7e5603ec0f657e99f20229","modified":1740387929798},{"_id":"source/_drafts/temp_notes/lab1_report.assets/image-20250224170548503.png","hash":"c18788d237798c512c99d63a171ab2b766a1c083","modified":1740387948505},{"_id":"source/_drafts/.DS_Store","hash":"9aa7e21767848338215326960c1c62fb55eb80ab","modified":1740721745266},{"_id":"source/_posts/编程语言/.DS_Store","hash":"f96cb934b3f765c380c7170814817754617f9989","modified":1740621252860},{"_id":"source/_drafts/temp_notes/图像信息处理.md","hash":"9d50eb9675b534608b4f56795025f8588b271263","modified":1740552945122},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250228111447627.png","hash":"d31d36f4a13bd72ff84f4588fc616acf92e89ec4","modified":1740712487627},{"_id":"source/_drafts/temp_notes/调试.md","hash":"3c9e0da9c3173de87c749ba9401da8f92db89b24","modified":1740575483897},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250228111935730.png","hash":"5938d024f3c14e229df72af45d558dc81ae4dcb6","modified":1740712775730},{"_id":"source/_drafts/temp_notes/数据库系统.assets/image-20250225233624768.png","hash":"8c017253bd47a7c678328f84adf5cd42567aa4d8","modified":1740497784768}],"Category":[{"name":"生活碎碎念","_id":"cm79tw4vv0006dwqg9zul4ljj"},{"name":"兴趣阅读","_id":"cm79tw4vw000bdwqgdqoyd7p9"},{"name":"随机掉落的文字碎片","_id":"cm79tw4vw000hdwqgb1l3bw3i"},{"name":"学习笔记","_id":"cm79tw4vx000tdwqgdwp170vg"},{"name":"通用技能","_id":"cm79tw4vy0014dwqgcn005bi6"},{"name":"备忘录","_id":"cm7ct9xz80001cpqgdvxvg02f"},{"name":"课程笔记","_id":"cm7ct9xze0007cpqg8tl73k35"}],"Data":[],"Page":[{"_content":"@font-face {\n    font-family: \"wenkai\";\n    src: url(\"/fonts/LXGWWenKaiGBScreen.ttf\") format(\"truetype\");\n    font-display: swap;\n}\n\nbody, .markdown-body {\n    font-family: \"wenkai\", sans-serif;\n}\n\n\ncode {\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, \"Apple Color Emoji\", Arial, sans-serif, \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n\n\tfont-size: 1em;\n\tbackground-color: #f0f0f0; /* 设置背景颜色为浅灰色 */\n\tcolor: #dc3545; /* 设置文字颜色为红色 (可以使用你喜欢的红色) */\n\tpadding: 2px 4px; /* 添加一些内边距，使背景更明显 */\n\tborder-radius: 6px; /* 可选：添加圆角 */\n\tpadding: 0.3em !important;\n\tmargin-left: 0.2em;\n\tmargin-right: 0.2em;\n\tpadding-left: 0.3em;\n\tpadding-right: 0.3em;\n  }\n\n\n\n/* Timeline styles */\n.timeline-container {\n    position: relative;\n    padding-left: 30px;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .timeline-item {\n    position: relative;\n    padding-left: 10px;\n    margin-bottom: 0px;\n  }\n  \n  .timeline-line {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background: var(--line-color);\n  }\n  \n  .timeline-dot {\n    position: absolute;\n    left: -0.15rem;\n    top: 45%;\n    transform: translateY(-50%);\n    width: 0.3rem;\n    height: 0.3rem;\n    border-radius: 50%;\n    background: #8e8c8c;\n    border: 0px solid white;\n    z-index: 1;\n    transition: all 0.3s ease;\n  }\n  \n  .timeline-item:hover .timeline-dot {\n    transform: scale(1.3);\n    background: var(--link-hover-color);\n  }\n  \n  .timeline-item:hover .list-group-item {\n    color: var(--link-hover-color);\n    transform: translateX(5px);\n  }\n  \n  .timeline-year {\n    position: relative;\n    margin-right: auto;\n    padding: 10px 0;\n    font-weight: bold;\n    border:none;\n    background: var(--board-color);\n    padding: 5px 15px;\n    border-radius: 20px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  \n  .list-group-item {\n    margin-bottom: 0px;\n    margin-left: 10px;\n    transition: all 0.3s ease;\n  }\n  \n  .list-group-item:hover {\n    box-shadow: 0 4px 15px rgba(33,150,243,0.2);\n    border-color: var(--post-link-color);\n  }\n  \n  .list-group-item-title {\n    font-size: 1rem;\n    font-weight: 500;\n  }\n  \n  .badge.bg-primary {\n    font-weight: 400;\n    font-size: 0.8rem;\n    padding: 4px 8px;\n  }\n  \n  .text-muted {\n    color: var(--sec-text-color) !important;\n    font-size: 0.9rem;\n    line-height: 1.5;\n  }\n  \n  @media (max-width: 768px) {\n    .timeline-container {\n      padding-left: 20px;\n    }\n    .timeline-item {\n      padding-left: 15px;\n    }\n  }\n  \n\n  .category-item, \n.category-subitem {\n  display: flex;\n  align-items: center;\n}\n\n.category-count {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  padding-right: 15px;\n}\n\n.category-count i,\n.category-count span {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.category-count i {\n  margin-right: 5px;\n}\n","source":"css/custom.css","raw":"@font-face {\n    font-family: \"wenkai\";\n    src: url(\"/fonts/LXGWWenKaiGBScreen.ttf\") format(\"truetype\");\n    font-display: swap;\n}\n\nbody, .markdown-body {\n    font-family: \"wenkai\", sans-serif;\n}\n\n\ncode {\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, \"Apple Color Emoji\", Arial, sans-serif, \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n\n\tfont-size: 1em;\n\tbackground-color: #f0f0f0; /* 设置背景颜色为浅灰色 */\n\tcolor: #dc3545; /* 设置文字颜色为红色 (可以使用你喜欢的红色) */\n\tpadding: 2px 4px; /* 添加一些内边距，使背景更明显 */\n\tborder-radius: 6px; /* 可选：添加圆角 */\n\tpadding: 0.3em !important;\n\tmargin-left: 0.2em;\n\tmargin-right: 0.2em;\n\tpadding-left: 0.3em;\n\tpadding-right: 0.3em;\n  }\n\n\n\n/* Timeline styles */\n.timeline-container {\n    position: relative;\n    padding-left: 30px;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .timeline-item {\n    position: relative;\n    padding-left: 10px;\n    margin-bottom: 0px;\n  }\n  \n  .timeline-line {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background: var(--line-color);\n  }\n  \n  .timeline-dot {\n    position: absolute;\n    left: -0.15rem;\n    top: 45%;\n    transform: translateY(-50%);\n    width: 0.3rem;\n    height: 0.3rem;\n    border-radius: 50%;\n    background: #8e8c8c;\n    border: 0px solid white;\n    z-index: 1;\n    transition: all 0.3s ease;\n  }\n  \n  .timeline-item:hover .timeline-dot {\n    transform: scale(1.3);\n    background: var(--link-hover-color);\n  }\n  \n  .timeline-item:hover .list-group-item {\n    color: var(--link-hover-color);\n    transform: translateX(5px);\n  }\n  \n  .timeline-year {\n    position: relative;\n    margin-right: auto;\n    padding: 10px 0;\n    font-weight: bold;\n    border:none;\n    background: var(--board-color);\n    padding: 5px 15px;\n    border-radius: 20px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  \n  .list-group-item {\n    margin-bottom: 0px;\n    margin-left: 10px;\n    transition: all 0.3s ease;\n  }\n  \n  .list-group-item:hover {\n    box-shadow: 0 4px 15px rgba(33,150,243,0.2);\n    border-color: var(--post-link-color);\n  }\n  \n  .list-group-item-title {\n    font-size: 1rem;\n    font-weight: 500;\n  }\n  \n  .badge.bg-primary {\n    font-weight: 400;\n    font-size: 0.8rem;\n    padding: 4px 8px;\n  }\n  \n  .text-muted {\n    color: var(--sec-text-color) !important;\n    font-size: 0.9rem;\n    line-height: 1.5;\n  }\n  \n  @media (max-width: 768px) {\n    .timeline-container {\n      padding-left: 20px;\n    }\n    .timeline-item {\n      padding-left: 15px;\n    }\n  }\n  \n\n  .category-item, \n.category-subitem {\n  display: flex;\n  align-items: center;\n}\n\n.category-count {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  padding-right: 15px;\n}\n\n.category-count i,\n.category-count span {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.category-count i {\n  margin-right: 5px;\n}\n","date":"2025-02-28T07:23:39.501Z","updated":"2025-02-28T07:23:37.818Z","path":"css/custom.css","layout":"false","_id":"cm79tw4vr0000dwqg1j9ehhqq","title":"","comments":1,"content":"@font-face {\n    font-family: \"wenkai\";\n    src: url(\"/fonts/LXGWWenKaiGBScreen.ttf\") format(\"truetype\");\n    font-display: swap;\n}\n\nbody, .markdown-body {\n    font-family: \"wenkai\", sans-serif;\n}\n\n\ncode {\n\tfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, \"Apple Color Emoji\", Arial, sans-serif, \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n\n\tfont-size: 1em;\n\tbackground-color: #f0f0f0; /* 设置背景颜色为浅灰色 */\n\tcolor: #dc3545; /* 设置文字颜色为红色 (可以使用你喜欢的红色) */\n\tpadding: 2px 4px; /* 添加一些内边距，使背景更明显 */\n\tborder-radius: 6px; /* 可选：添加圆角 */\n\tpadding: 0.3em !important;\n\tmargin-left: 0.2em;\n\tmargin-right: 0.2em;\n\tpadding-left: 0.3em;\n\tpadding-right: 0.3em;\n  }\n\n\n\n/* Timeline styles */\n.timeline-container {\n    position: relative;\n    padding-left: 30px;\n    max-width: 800px;\n    margin: 0 auto;\n  }\n  \n  .timeline-item {\n    position: relative;\n    padding-left: 10px;\n    margin-bottom: 0px;\n  }\n  \n  .timeline-line {\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background: var(--line-color);\n  }\n  \n  .timeline-dot {\n    position: absolute;\n    left: -0.15rem;\n    top: 45%;\n    transform: translateY(-50%);\n    width: 0.3rem;\n    height: 0.3rem;\n    border-radius: 50%;\n    background: #8e8c8c;\n    border: 0px solid white;\n    z-index: 1;\n    transition: all 0.3s ease;\n  }\n  \n  .timeline-item:hover .timeline-dot {\n    transform: scale(1.3);\n    background: var(--link-hover-color);\n  }\n  \n  .timeline-item:hover .list-group-item {\n    color: var(--link-hover-color);\n    transform: translateX(5px);\n  }\n  \n  .timeline-year {\n    position: relative;\n    margin-right: auto;\n    padding: 10px 0;\n    font-weight: bold;\n    border:none;\n    background: var(--board-color);\n    padding: 5px 15px;\n    border-radius: 20px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n  }\n  \n  .list-group-item {\n    margin-bottom: 0px;\n    margin-left: 10px;\n    transition: all 0.3s ease;\n  }\n  \n  .list-group-item:hover {\n    box-shadow: 0 4px 15px rgba(33,150,243,0.2);\n    border-color: var(--post-link-color);\n  }\n  \n  .list-group-item-title {\n    font-size: 1rem;\n    font-weight: 500;\n  }\n  \n  .badge.bg-primary {\n    font-weight: 400;\n    font-size: 0.8rem;\n    padding: 4px 8px;\n  }\n  \n  .text-muted {\n    color: var(--sec-text-color) !important;\n    font-size: 0.9rem;\n    line-height: 1.5;\n  }\n  \n  @media (max-width: 768px) {\n    .timeline-container {\n      padding-left: 20px;\n    }\n    .timeline-item {\n      padding-left: 15px;\n    }\n  }\n  \n\n  .category-item, \n.category-subitem {\n  display: flex;\n  align-items: center;\n}\n\n.category-count {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  padding-right: 15px;\n}\n\n.category-count i,\n.category-count span {\n  display: inline-block;\n  vertical-align: middle;\n}\n\n.category-count i {\n  margin-right: 5px;\n}\n"},{"title":"about","layout":"about","date":"2025-01-08T06:42:30.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2025-01-08 14:42:30\n---\n","updated":"2025-01-19T11:46:34.126Z","path":"about/index.html","comments":1,"_id":"cm79tw4vt0002dwqg3jkx5x14","content":"","excerpt":"","more":""},{"_content":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2025/01/08 14:00:00\");\n  \n    function update() {\n      var now = new Date();\n      now.setTime(now.getTime()+250);\n      days = (now - start) / 1000 / 60 / 60 / 24;\n      dnum = Math.floor(days);\n      hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n      hnum = Math.floor(hours);\n      if(String(hnum).length === 1 ){\n        hnum = \"0\" + hnum;\n      }\n      minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n      mnum = Math.floor(minutes);\n      if(String(mnum).length === 1 ){\n        mnum = \"0\" + mnum;\n      }\n      seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n      snum = Math.round(seconds);\n      if(String(snum).length === 1 ){\n        snum = \"0\" + snum;\n      }\n      document.getElementById(\"timeDate\").innerHTML = \"本站已运行&nbsp\"+dnum+\"&nbsp天\";\n      document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n    }\n  \n    update();\n    setInterval(update, 1000);\n  })();","source":"js/duration.js","raw":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2025/01/08 14:00:00\");\n  \n    function update() {\n      var now = new Date();\n      now.setTime(now.getTime()+250);\n      days = (now - start) / 1000 / 60 / 60 / 24;\n      dnum = Math.floor(days);\n      hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n      hnum = Math.floor(hours);\n      if(String(hnum).length === 1 ){\n        hnum = \"0\" + hnum;\n      }\n      minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n      mnum = Math.floor(minutes);\n      if(String(mnum).length === 1 ){\n        mnum = \"0\" + mnum;\n      }\n      seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n      snum = Math.round(seconds);\n      if(String(snum).length === 1 ){\n        snum = \"0\" + snum;\n      }\n      document.getElementById(\"timeDate\").innerHTML = \"本站已运行&nbsp\"+dnum+\"&nbsp天\";\n      document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n    }\n  \n    update();\n    setInterval(update, 1000);\n  })();","date":"2025-01-19T11:46:34.208Z","updated":"2025-01-19T11:46:34.208Z","path":"js/duration.js","layout":"false","title":"","comments":1,"_id":"cm79tw4vu0004dwqg0v40ehct","content":"!(function() {\n    /** 计时起始时间，自行修改 **/\n    var start = new Date(\"2025/01/08 14:00:00\");\n  \n    function update() {\n      var now = new Date();\n      now.setTime(now.getTime()+250);\n      days = (now - start) / 1000 / 60 / 60 / 24;\n      dnum = Math.floor(days);\n      hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);\n      hnum = Math.floor(hours);\n      if(String(hnum).length === 1 ){\n        hnum = \"0\" + hnum;\n      }\n      minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);\n      mnum = Math.floor(minutes);\n      if(String(mnum).length === 1 ){\n        mnum = \"0\" + mnum;\n      }\n      seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);\n      snum = Math.round(seconds);\n      if(String(snum).length === 1 ){\n        snum = \"0\" + snum;\n      }\n      document.getElementById(\"timeDate\").innerHTML = \"本站已运行&nbsp\"+dnum+\"&nbsp天\";\n      document.getElementById(\"times\").innerHTML = hnum + \"&nbsp小时&nbsp\" + mnum + \"&nbsp分&nbsp\" + snum + \"&nbsp秒\";\n    }\n  \n    update();\n    setInterval(update, 1000);\n  })();"}],"Post":[{"title":"my-fisrt-draft","_content":"","source":"_drafts/my-fisrt-draft.md","raw":"---\ntitle: my-fisrt-draft\ntags:\n---\n","slug":"my-fisrt-draft","published":0,"date":"2025-01-19T11:46:34.121Z","updated":"2025-01-19T11:46:34.121Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vs0001dwqgdlrkhnka","content":"","excerpt":"","more":""},{"title":"Re0!","date":"2025-01-18T09:05:18.000Z","excerpt":"好好看!","hide":false,"archive":true,"_content":"\n\n为了寻找合适的封面，用一天半从零开始刷了Re0新编集的13话+ OVA1 + 16集的sp\n\n真是辛苦自己了😳（）\n\n<img src = \"/img/2025-01-18-17-06-50.png\" width = \"30%\" class = \"smallImg\">\n\n<br>\n刚出宅邸篇的时候看得是真坐牢😥——感觉486真是自信过头、又完全没有脑袋, 真是太弱了.\n于是本打算转而去玩铲铲, 但是恰好遇到铲铲要更新😬, ~~勉为其难~~再看几话吧.\n\n终于到了白鲸篇, 看着486从一次次的死亡打击中逐渐崩溃:\n![](/img/2025-01-18-17-13-45.png)\n> ~~这不是熬夜熬多了的我吗~~\n\n\n到最后与雷姆的“私奔”对话中完成心态的转变:\n![](/img/re0-2025-01-18-17-16-53.png)\n也是为男主的 **增强** 感到十分的欣慰.😌\n![](/img/2025-01-18-17-11-36.png)\n\n<p style = \"\n    font-size: 0.9em;  \n    color: grey;\n    text-align : center;\n\">\n当然 不是这种增强🤭 \n</p>\n\n<hr>\n<p style = \" font-size : 1.3em; text-align: center;\">\n但是我的雷姆呢!🤬😐 感觉都没有动力追第二季了🙃\n</p>\n\n![](/img/re0-2025-01-18-17-40-27.png)\n\n<style>\n.post-content img:not(.smallImg){\n    width: 70%;\n    height: auto;\n    display: block;\n    margin: 1rem auto;\n}\n</style>","source":"_posts/Re0.md","raw":"---\ntitle: Re0!\ndate: 2025-01-18 17:05:18\ntags:\n- 追番\ncategories: 生活碎碎念\nexcerpt: 好好看!\nhide: false\narchive: true\n---\n\n\n为了寻找合适的封面，用一天半从零开始刷了Re0新编集的13话+ OVA1 + 16集的sp\n\n真是辛苦自己了😳（）\n\n<img src = \"/img/2025-01-18-17-06-50.png\" width = \"30%\" class = \"smallImg\">\n\n<br>\n刚出宅邸篇的时候看得是真坐牢😥——感觉486真是自信过头、又完全没有脑袋, 真是太弱了.\n于是本打算转而去玩铲铲, 但是恰好遇到铲铲要更新😬, ~~勉为其难~~再看几话吧.\n\n终于到了白鲸篇, 看着486从一次次的死亡打击中逐渐崩溃:\n![](/img/2025-01-18-17-13-45.png)\n> ~~这不是熬夜熬多了的我吗~~\n\n\n到最后与雷姆的“私奔”对话中完成心态的转变:\n![](/img/re0-2025-01-18-17-16-53.png)\n也是为男主的 **增强** 感到十分的欣慰.😌\n![](/img/2025-01-18-17-11-36.png)\n\n<p style = \"\n    font-size: 0.9em;  \n    color: grey;\n    text-align : center;\n\">\n当然 不是这种增强🤭 \n</p>\n\n<hr>\n<p style = \" font-size : 1.3em; text-align: center;\">\n但是我的雷姆呢!🤬😐 感觉都没有动力追第二季了🙃\n</p>\n\n![](/img/re0-2025-01-18-17-40-27.png)\n\n<style>\n.post-content img:not(.smallImg){\n    width: 70%;\n    height: auto;\n    display: block;\n    margin: 1rem auto;\n}\n</style>","slug":"Re0","published":1,"updated":"2025-01-19T11:46:34.123Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vu0003dwqgd3zr8i0p","content":"<p>为了寻找合适的封面，用一天半从零开始刷了Re0新编集的13话+ OVA1 + 16集的sp</p>\n<p>真是辛苦自己了😳（）</p>\n<p><img src = \"/img/2025-01-18-17-06-50.png\" width = \"30%\" class = \"smallImg\"></p>\n<p><br><br>刚出宅邸篇的时候看得是真坐牢😥——感觉486真是自信过头、又完全没有脑袋, 真是太弱了.<br>于是本打算转而去玩铲铲, 但是恰好遇到铲铲要更新😬, <del>勉为其难</del>再看几话吧.</p>\n<p>终于到了白鲸篇, 看着486从一次次的死亡打击中逐渐崩溃:<br><img src=\"/img/2025-01-18-17-13-45.png\" alt=\"\"></p>\n<blockquote>\n<p><del>这不是熬夜熬多了的我吗</del></p>\n</blockquote>\n<p>到最后与雷姆的“私奔”对话中完成心态的转变:<br><img src=\"/img/re0-2025-01-18-17-16-53.png\" alt=\"\"><br>也是为男主的 <strong>增强</strong> 感到十分的欣慰.😌<br><img src=\"/img/2025-01-18-17-11-36.png\" alt=\"\"></p>\n<p style = \"\n    font-size: 0.9em;  \n    color: grey;\n    text-align : center;\n\">\n当然 不是这种增强🤭 \n</p>\n\n<p><hr></p>\n<p style = \" font-size : 1.3em; text-align: center;\">\n但是我的雷姆呢!🤬😐 感觉都没有动力追第二季了🙃\n</p>\n\n<p><img src=\"/img/re0-2025-01-18-17-40-27.png\" alt=\"\"></p>\n<style>\n.post-content img:not(.smallImg){\n    width: 70%;\n    height: auto;\n    display: block;\n    margin: 1rem auto;\n}\n</style>","more":"<p>为了寻找合适的封面，用一天半从零开始刷了Re0新编集的13话+ OVA1 + 16集的sp</p>\n<p>真是辛苦自己了😳（）</p>\n<p><img src = \"/img/2025-01-18-17-06-50.png\" width = \"30%\" class = \"smallImg\"></p>\n<p><br><br>刚出宅邸篇的时候看得是真坐牢😥——感觉486真是自信过头、又完全没有脑袋, 真是太弱了.<br>于是本打算转而去玩铲铲, 但是恰好遇到铲铲要更新😬, <del>勉为其难</del>再看几话吧.</p>\n<p>终于到了白鲸篇, 看着486从一次次的死亡打击中逐渐崩溃:<br><img src=\"/img/2025-01-18-17-13-45.png\" alt=\"\"></p>\n<blockquote>\n<p><del>这不是熬夜熬多了的我吗</del></p>\n</blockquote>\n<p>到最后与雷姆的“私奔”对话中完成心态的转变:<br><img src=\"/img/re0-2025-01-18-17-16-53.png\" alt=\"\"><br>也是为男主的 <strong>增强</strong> 感到十分的欣慰.😌<br><img src=\"/img/2025-01-18-17-11-36.png\" alt=\"\"></p>\n<p style = \"\n    font-size: 0.9em;  \n    color: grey;\n    text-align : center;\n\">\n当然 不是这种增强🤭 \n</p>\n\n<p><hr></p>\n<p style = \" font-size : 1.3em; text-align: center;\">\n但是我的雷姆呢!🤬😐 感觉都没有动力追第二季了🙃\n</p>\n\n<p><img src=\"/img/re0-2025-01-18-17-40-27.png\" alt=\"\"></p>\n<style>\n.post-content img:not(.smallImg){\n    width: 70%;\n    height: auto;\n    display: block;\n    margin: 1rem auto;\n}\n</style>"},{"title":"社会心理学","date":"2025-01-09T01:23:32.000Z","excerpt":"在专业基础课_社会心理学的教学内容基础上, 摘录个人感兴趣的部分, 同时补充了部分相关理论.","math":true,"index_img":"/img/社会心理学.png","banner_img":"/img/社会心理学.png","_content":"# 社会知觉\n## 非语言线索\n**面部表情反馈假设**: 人为表现某种面部表情, 可以导致相应情绪体验的产生或增强;\n\n## 印象形成\n顺序效应\n- 首因效应: 最初获得的信息影响更大, 即第一印象效应;\n- 近因效应: 后来获得的信息影响更大, 即新颖效应;\n\n晕轮效应\n- 对一个人的某种特征 **形成** 好或坏的印象 **之后**, 据此推论其他方面的特征;\n- 与首因效应的区别: \n> 前者发生在初步印象形成之后, 后者发生在初步印象形成之前;\n\n投射效应\n- 在认知和形成他人印象时，认为他人与自己具有**相似**的特性;\n- 将自己的情感、特性投射到他人身上并强加于他人;\n\n### 期望效应\n***Self-fulfilling prophecy***\n> 自我实现预言 \n\n- “预测”或期待某事的社会心理现象，而这种“预测”或期望之所以成真，只是因为该人相信或预期它会发生;\n- 人们的信念会影响他们的行为;\n\n可见迹象,感知和信念共同影响自我实现预言成为现实的可能性. \n\n## 归因 \n> Attribution theory\n\n**归因**, 指观察者从他人的行为推论出行为原因、因果关系。\n\n**归因理论**, 指研究人们如何做出归因，以及为何在某情况做出某种归因，在另一情况做出另种归因的理论。\n- $\\underline{情境归因}$: 将行为发生解释为情境（环境）因素使然者 --外因\n- $\\underline{性格归因}$: 指个体将行为之发生解释为自己性格使然 --内因\n\n### 归因偏差\n**基本归因错误**: 解释他人行为时, 高估特质和态度的作用, 而低估情境的影响;\n\n**行为者-观察者偏差**: \n- 归因他人的行为时, 倾向于内部归因;归因自身行为时, 倾向于外部归因;\n- 为什么会产生上述区别?\n  - 对于行为的信息数量和类型, 因自身和他人的区别在了解程度上存在差异;\n  - 人们倾向于利用 **可得性** 高的信息来处理问题\n> 根据$\\underline{格式塔原理}$, 可得性高,即与背景形成 **鲜明对比**;\n> 对于行为者,它代表着外部环境; 对于观察者, 他人的行为则构成了注意的中心.\n---\n**错误共识效应**(False consensus effect): \n- 也称为 **虚假一致性效应**;\n- 指倾向于认为自己的观点、信念、特征或行为比实际情况更广泛地被认同, 从而倾向于根据自己的信念进行推论;\n- 这同时导致人们倾向于与自己 **相似** 的个体交往;\n---\n**公平世界信念**: 指的是相信\"善有善报,恶有恶报\"而导致的归因偏差.\n- 认为每个人都应该为自己的行为负责;\n- 分析行为的原因时, 倾向于追溯个人自身的原因;\n---\n**动机性归因偏差**: \n- 倾向于将自己的成功归因于内在因素、失败归因于外在因素;\n- 而观察和评价他人的行为时，倾向于将成功归因于外在因素，将失败归因于内在因素;\n\n\n# 自我\n## 自我概念\n- $\\underline{自我知觉}$: 对自己持有的信念之集合;\n- $\\underline{自我中心思维}$: 对自我的感觉处于意识的核心;\n- $\\underline{虚假一致性效应}$: \n\n\n","source":"_posts/社会心理学.md","raw":"---\ntitle: 社会心理学\ndate: 2025-01-09 09:23:32\ntags: \n- 心理学\ncategories: 兴趣阅读\nexcerpt: 在专业基础课_社会心理学的教学内容基础上, 摘录个人感兴趣的部分, 同时补充了部分相关理论.\nmath: true\nindex_img: /img/社会心理学.png\nbanner_img: /img/社会心理学.png\n---\n# 社会知觉\n## 非语言线索\n**面部表情反馈假设**: 人为表现某种面部表情, 可以导致相应情绪体验的产生或增强;\n\n## 印象形成\n顺序效应\n- 首因效应: 最初获得的信息影响更大, 即第一印象效应;\n- 近因效应: 后来获得的信息影响更大, 即新颖效应;\n\n晕轮效应\n- 对一个人的某种特征 **形成** 好或坏的印象 **之后**, 据此推论其他方面的特征;\n- 与首因效应的区别: \n> 前者发生在初步印象形成之后, 后者发生在初步印象形成之前;\n\n投射效应\n- 在认知和形成他人印象时，认为他人与自己具有**相似**的特性;\n- 将自己的情感、特性投射到他人身上并强加于他人;\n\n### 期望效应\n***Self-fulfilling prophecy***\n> 自我实现预言 \n\n- “预测”或期待某事的社会心理现象，而这种“预测”或期望之所以成真，只是因为该人相信或预期它会发生;\n- 人们的信念会影响他们的行为;\n\n可见迹象,感知和信念共同影响自我实现预言成为现实的可能性. \n\n## 归因 \n> Attribution theory\n\n**归因**, 指观察者从他人的行为推论出行为原因、因果关系。\n\n**归因理论**, 指研究人们如何做出归因，以及为何在某情况做出某种归因，在另一情况做出另种归因的理论。\n- $\\underline{情境归因}$: 将行为发生解释为情境（环境）因素使然者 --外因\n- $\\underline{性格归因}$: 指个体将行为之发生解释为自己性格使然 --内因\n\n### 归因偏差\n**基本归因错误**: 解释他人行为时, 高估特质和态度的作用, 而低估情境的影响;\n\n**行为者-观察者偏差**: \n- 归因他人的行为时, 倾向于内部归因;归因自身行为时, 倾向于外部归因;\n- 为什么会产生上述区别?\n  - 对于行为的信息数量和类型, 因自身和他人的区别在了解程度上存在差异;\n  - 人们倾向于利用 **可得性** 高的信息来处理问题\n> 根据$\\underline{格式塔原理}$, 可得性高,即与背景形成 **鲜明对比**;\n> 对于行为者,它代表着外部环境; 对于观察者, 他人的行为则构成了注意的中心.\n---\n**错误共识效应**(False consensus effect): \n- 也称为 **虚假一致性效应**;\n- 指倾向于认为自己的观点、信念、特征或行为比实际情况更广泛地被认同, 从而倾向于根据自己的信念进行推论;\n- 这同时导致人们倾向于与自己 **相似** 的个体交往;\n---\n**公平世界信念**: 指的是相信\"善有善报,恶有恶报\"而导致的归因偏差.\n- 认为每个人都应该为自己的行为负责;\n- 分析行为的原因时, 倾向于追溯个人自身的原因;\n---\n**动机性归因偏差**: \n- 倾向于将自己的成功归因于内在因素、失败归因于外在因素;\n- 而观察和评价他人的行为时，倾向于将成功归因于外在因素，将失败归因于内在因素;\n\n\n# 自我\n## 自我概念\n- $\\underline{自我知觉}$: 对自己持有的信念之集合;\n- $\\underline{自我中心思维}$: 对自我的感觉处于意识的核心;\n- $\\underline{虚假一致性效应}$: \n\n\n","slug":"社会心理学","published":1,"updated":"2025-01-19T11:46:34.126Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vu0005dwqg8u0z9cdd","content":"<h1 id=\"社会知觉\"><a href=\"#社会知觉\" class=\"headerlink\" title=\"社会知觉\"></a>社会知觉</h1><h2 id=\"非语言线索\"><a href=\"#非语言线索\" class=\"headerlink\" title=\"非语言线索\"></a>非语言线索</h2><p><strong>面部表情反馈假设</strong>: 人为表现某种面部表情, 可以导致相应情绪体验的产生或增强;</p>\n<h2 id=\"印象形成\"><a href=\"#印象形成\" class=\"headerlink\" title=\"印象形成\"></a>印象形成</h2><p>顺序效应</p>\n<ul>\n<li>首因效应: 最初获得的信息影响更大, 即第一印象效应;</li>\n<li>近因效应: 后来获得的信息影响更大, 即新颖效应;</li>\n</ul>\n<p>晕轮效应</p>\n<ul>\n<li>对一个人的某种特征 <strong>形成</strong> 好或坏的印象 <strong>之后</strong>, 据此推论其他方面的特征;</li>\n<li>与首因效应的区别: <blockquote>\n<p>前者发生在初步印象形成之后, 后者发生在初步印象形成之前;</p>\n</blockquote>\n</li>\n</ul>\n<p>投射效应</p>\n<ul>\n<li>在认知和形成他人印象时，认为他人与自己具有<strong>相似</strong>的特性;</li>\n<li>将自己的情感、特性投射到他人身上并强加于他人;</li>\n</ul>\n<h3 id=\"期望效应\"><a href=\"#期望效应\" class=\"headerlink\" title=\"期望效应\"></a>期望效应</h3><p><strong><em>Self-fulfilling prophecy</em></strong></p>\n<blockquote>\n<p>自我实现预言 </p>\n</blockquote>\n<ul>\n<li>“预测”或期待某事的社会心理现象，而这种“预测”或期望之所以成真，只是因为该人相信或预期它会发生;</li>\n<li>人们的信念会影响他们的行为;</li>\n</ul>\n<p>可见迹象,感知和信念共同影响自我实现预言成为现实的可能性. </p>\n<h2 id=\"归因\"><a href=\"#归因\" class=\"headerlink\" title=\"归因\"></a>归因</h2><blockquote>\n<p>Attribution theory</p>\n</blockquote>\n<p><strong>归因</strong>, 指观察者从他人的行为推论出行为原因、因果关系。</p>\n<p><strong>归因理论</strong>, 指研究人们如何做出归因，以及为何在某情况做出某种归因，在另一情况做出另种归因的理论。</p>\n<ul>\n<li>$\\underline{情境归因}$: 将行为发生解释为情境（环境）因素使然者 —外因</li>\n<li>$\\underline{性格归因}$: 指个体将行为之发生解释为自己性格使然 —内因</li>\n</ul>\n<h3 id=\"归因偏差\"><a href=\"#归因偏差\" class=\"headerlink\" title=\"归因偏差\"></a>归因偏差</h3><p><strong>基本归因错误</strong>: 解释他人行为时, 高估特质和态度的作用, 而低估情境的影响;</p>\n<p><strong>行为者-观察者偏差</strong>: </p>\n<ul>\n<li>归因他人的行为时, 倾向于内部归因;归因自身行为时, 倾向于外部归因;</li>\n<li>为什么会产生上述区别?<ul>\n<li>对于行为的信息数量和类型, 因自身和他人的区别在了解程度上存在差异;</li>\n<li>人们倾向于利用 <strong>可得性</strong> 高的信息来处理问题<blockquote>\n<p>根据$\\underline{格式塔原理}$, 可得性高,即与背景形成 <strong>鲜明对比</strong>;<br>对于行为者,它代表着外部环境; 对于观察者, 他人的行为则构成了注意的中心.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>错误共识效应</strong>(False consensus effect): </p>\n<ul>\n<li>也称为 <strong>虚假一致性效应</strong>;</li>\n<li>指倾向于认为自己的观点、信念、特征或行为比实际情况更广泛地被认同, 从而倾向于根据自己的信念进行推论;</li>\n<li>这同时导致人们倾向于与自己 <strong>相似</strong> 的个体交往;</li>\n</ul>\n<hr>\n<p><strong>公平世界信念</strong>: 指的是相信”善有善报,恶有恶报”而导致的归因偏差.</p>\n<ul>\n<li>认为每个人都应该为自己的行为负责;</li>\n<li>分析行为的原因时, 倾向于追溯个人自身的原因;</li>\n</ul>\n<hr>\n<p><strong>动机性归因偏差</strong>: </p>\n<ul>\n<li>倾向于将自己的成功归因于内在因素、失败归因于外在因素;</li>\n<li>而观察和评价他人的行为时，倾向于将成功归因于外在因素，将失败归因于内在因素;</li>\n</ul>\n<h1 id=\"自我\"><a href=\"#自我\" class=\"headerlink\" title=\"自我\"></a>自我</h1><h2 id=\"自我概念\"><a href=\"#自我概念\" class=\"headerlink\" title=\"自我概念\"></a>自我概念</h2><ul>\n<li>$\\underline{自我知觉}$: 对自己持有的信念之集合;</li>\n<li>$\\underline{自我中心思维}$: 对自我的感觉处于意识的核心;</li>\n<li>$\\underline{虚假一致性效应}$: </li>\n</ul>\n","more":"<h1 id=\"社会知觉\"><a href=\"#社会知觉\" class=\"headerlink\" title=\"社会知觉\"></a>社会知觉</h1><h2 id=\"非语言线索\"><a href=\"#非语言线索\" class=\"headerlink\" title=\"非语言线索\"></a>非语言线索</h2><p><strong>面部表情反馈假设</strong>: 人为表现某种面部表情, 可以导致相应情绪体验的产生或增强;</p>\n<h2 id=\"印象形成\"><a href=\"#印象形成\" class=\"headerlink\" title=\"印象形成\"></a>印象形成</h2><p>顺序效应</p>\n<ul>\n<li>首因效应: 最初获得的信息影响更大, 即第一印象效应;</li>\n<li>近因效应: 后来获得的信息影响更大, 即新颖效应;</li>\n</ul>\n<p>晕轮效应</p>\n<ul>\n<li>对一个人的某种特征 <strong>形成</strong> 好或坏的印象 <strong>之后</strong>, 据此推论其他方面的特征;</li>\n<li>与首因效应的区别: <blockquote>\n<p>前者发生在初步印象形成之后, 后者发生在初步印象形成之前;</p>\n</blockquote>\n</li>\n</ul>\n<p>投射效应</p>\n<ul>\n<li>在认知和形成他人印象时，认为他人与自己具有<strong>相似</strong>的特性;</li>\n<li>将自己的情感、特性投射到他人身上并强加于他人;</li>\n</ul>\n<h3 id=\"期望效应\"><a href=\"#期望效应\" class=\"headerlink\" title=\"期望效应\"></a>期望效应</h3><p><strong><em>Self-fulfilling prophecy</em></strong></p>\n<blockquote>\n<p>自我实现预言 </p>\n</blockquote>\n<ul>\n<li>“预测”或期待某事的社会心理现象，而这种“预测”或期望之所以成真，只是因为该人相信或预期它会发生;</li>\n<li>人们的信念会影响他们的行为;</li>\n</ul>\n<p>可见迹象,感知和信念共同影响自我实现预言成为现实的可能性. </p>\n<h2 id=\"归因\"><a href=\"#归因\" class=\"headerlink\" title=\"归因\"></a>归因</h2><blockquote>\n<p>Attribution theory</p>\n</blockquote>\n<p><strong>归因</strong>, 指观察者从他人的行为推论出行为原因、因果关系。</p>\n<p><strong>归因理论</strong>, 指研究人们如何做出归因，以及为何在某情况做出某种归因，在另一情况做出另种归因的理论。</p>\n<ul>\n<li>$\\underline{情境归因}$: 将行为发生解释为情境（环境）因素使然者 —外因</li>\n<li>$\\underline{性格归因}$: 指个体将行为之发生解释为自己性格使然 —内因</li>\n</ul>\n<h3 id=\"归因偏差\"><a href=\"#归因偏差\" class=\"headerlink\" title=\"归因偏差\"></a>归因偏差</h3><p><strong>基本归因错误</strong>: 解释他人行为时, 高估特质和态度的作用, 而低估情境的影响;</p>\n<p><strong>行为者-观察者偏差</strong>: </p>\n<ul>\n<li>归因他人的行为时, 倾向于内部归因;归因自身行为时, 倾向于外部归因;</li>\n<li>为什么会产生上述区别?<ul>\n<li>对于行为的信息数量和类型, 因自身和他人的区别在了解程度上存在差异;</li>\n<li>人们倾向于利用 <strong>可得性</strong> 高的信息来处理问题<blockquote>\n<p>根据$\\underline{格式塔原理}$, 可得性高,即与背景形成 <strong>鲜明对比</strong>;<br>对于行为者,它代表着外部环境; 对于观察者, 他人的行为则构成了注意的中心.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>错误共识效应</strong>(False consensus effect): </p>\n<ul>\n<li>也称为 <strong>虚假一致性效应</strong>;</li>\n<li>指倾向于认为自己的观点、信念、特征或行为比实际情况更广泛地被认同, 从而倾向于根据自己的信念进行推论;</li>\n<li>这同时导致人们倾向于与自己 <strong>相似</strong> 的个体交往;</li>\n</ul>\n<hr>\n<p><strong>公平世界信念</strong>: 指的是相信”善有善报,恶有恶报”而导致的归因偏差.</p>\n<ul>\n<li>认为每个人都应该为自己的行为负责;</li>\n<li>分析行为的原因时, 倾向于追溯个人自身的原因;</li>\n</ul>\n<hr>\n<p><strong>动机性归因偏差</strong>: </p>\n<ul>\n<li>倾向于将自己的成功归因于内在因素、失败归因于外在因素;</li>\n<li>而观察和评价他人的行为时，倾向于将成功归因于外在因素，将失败归因于内在因素;</li>\n</ul>\n<h1 id=\"自我\"><a href=\"#自我\" class=\"headerlink\" title=\"自我\"></a>自我</h1><h2 id=\"自我概念\"><a href=\"#自我概念\" class=\"headerlink\" title=\"自我概念\"></a>自我概念</h2><ul>\n<li>$\\underline{自我知觉}$: 对自己持有的信念之集合;</li>\n<li>$\\underline{自我中心思维}$: 对自我的感觉处于意识的核心;</li>\n<li>$\\underline{虚假一致性效应}$: </li>\n</ul>\n"},{"title":"建站第一天","date":"2025-01-08T08:04:13.000Z","updated":"2025-01-08T08:04:15.000Z","excerpt":"鸽了好久的小博客终于诞生了","sticky":100,"index_img":"/img/闪耀pack.jpg","_content":"\n原本在倒腾Astro框架的, 想着用自己一些微薄的前端经验可以更自由地在react框架下自定义博客.\n\n然而发现Astro的文档~~还不够丰富, 配置起来还真是麻烦~~.折腾了几天, 还是放弃了. **还是hexo真香**.😊\n\n## 为什么搭建这个博客?😋\n- 记录一下自己的学习历程\n- 为生活的碎片留档, ~~越来越不想用puq了~~\n","source":"_posts/建站第一天.md","raw":"---\ntitle: 建站第一天\ndate: 2025-01-08 16:04:13\nupdated: 2025-01-08 16:04:15\ntags: \n- 杂记\nexcerpt: 鸽了好久的小博客终于诞生了\nsticky: 100\nindex_img: /img/闪耀pack.jpg\n---\n\n原本在倒腾Astro框架的, 想着用自己一些微薄的前端经验可以更自由地在react框架下自定义博客.\n\n然而发现Astro的文档~~还不够丰富, 配置起来还真是麻烦~~.折腾了几天, 还是放弃了. **还是hexo真香**.😊\n\n## 为什么搭建这个博客?😋\n- 记录一下自己的学习历程\n- 为生活的碎片留档, ~~越来越不想用puq了~~\n","slug":"建站第一天","published":1,"comments":1,"layout":"post","photos":[],"_id":"cm79tw4vv0008dwqgeitn63ic","content":"<p>原本在倒腾Astro框架的, 想着用自己一些微薄的前端经验可以更自由地在react框架下自定义博客.</p>\n<p>然而发现Astro的文档<del>还不够丰富, 配置起来还真是麻烦</del>.折腾了几天, 还是放弃了. <strong>还是hexo真香</strong>.😊</p>\n<h2 id=\"为什么搭建这个博客-😋\"><a href=\"#为什么搭建这个博客-😋\" class=\"headerlink\" title=\"为什么搭建这个博客?😋\"></a>为什么搭建这个博客?😋</h2><ul>\n<li>记录一下自己的学习历程</li>\n<li>为生活的碎片留档, <del>越来越不想用puq了</del></li>\n</ul>\n","more":"<p>原本在倒腾Astro框架的, 想着用自己一些微薄的前端经验可以更自由地在react框架下自定义博客.</p>\n<p>然而发现Astro的文档<del>还不够丰富, 配置起来还真是麻烦</del>.折腾了几天, 还是放弃了. <strong>还是hexo真香</strong>.😊</p>\n<h2 id=\"为什么搭建这个博客-😋\"><a href=\"#为什么搭建这个博客-😋\" class=\"headerlink\" title=\"为什么搭建这个博客?😋\"></a>为什么搭建这个博客?😋</h2><ul>\n<li>记录一下自己的学习历程</li>\n<li>为生活的碎片留档, <del>越来越不想用puq了</del></li>\n</ul>\n"},{"title":"关系数据库","date":"2025-01-22T03:27:49.000Z","excerpt":"freeCodeCamp项目","_content":"# 通过创建模板学习Bash\n- `more + <fileName>` 可以预览文件的内容;\n- `cd ..` , `cd ../..` \n- `clear`清除终端的内容;\n- `mkdir <folder_name>`\n  - `touch <file_name>` 新建一个文件;\n\n<br>\n\n`ls <flag>`:\n\n`ls -l` 以长格式显示文件和目录的信息:\n- `ls -lh`：以人类可读的格式显示文件大小（如 1K, 4.0M）;\n- `ls -la`：显示所有文件（包括隐藏文件 . 和 ..）;\n- `ls -ltr`：按时间排序，最近修改的文件排在最后.\n\n`ls --help`\n\n<br>\n\n`cp <file> <destination>` 拷贝文件到指定目录;\n`rm <fila_name>` 删除指定的文件;\n\n<br>\n\n- `mv <file_name> <new_file_name>`: rename \n- `mv <file> <destination>`: move\n\n<br>\n\n`find` 显示当前目录下的文件树\n![](/img/find-2025-01-22-11-58-20.png)\n","source":"_posts/关系数据库.md","raw":"---\ntitle: 关系数据库\ndate: 2025-01-22 11:27:49\ntags:\ncategories:\nexcerpt: freeCodeCamp项目\n---\n# 通过创建模板学习Bash\n- `more + <fileName>` 可以预览文件的内容;\n- `cd ..` , `cd ../..` \n- `clear`清除终端的内容;\n- `mkdir <folder_name>`\n  - `touch <file_name>` 新建一个文件;\n\n<br>\n\n`ls <flag>`:\n\n`ls -l` 以长格式显示文件和目录的信息:\n- `ls -lh`：以人类可读的格式显示文件大小（如 1K, 4.0M）;\n- `ls -la`：显示所有文件（包括隐藏文件 . 和 ..）;\n- `ls -ltr`：按时间排序，最近修改的文件排在最后.\n\n`ls --help`\n\n<br>\n\n`cp <file> <destination>` 拷贝文件到指定目录;\n`rm <fila_name>` 删除指定的文件;\n\n<br>\n\n- `mv <file_name> <new_file_name>`: rename \n- `mv <file> <destination>`: move\n\n<br>\n\n`find` 显示当前目录下的文件树\n![](/img/find-2025-01-22-11-58-20.png)\n","slug":"关系数据库","published":1,"updated":"2025-01-22T04:47:27.121Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vv0009dwqg2zmk9zkn","content":"<h1 id=\"通过创建模板学习Bash\"><a href=\"#通过创建模板学习Bash\" class=\"headerlink\" title=\"通过创建模板学习Bash\"></a>通过创建模板学习Bash</h1><ul>\n<li><code>more + &lt;fileName&gt;</code> 可以预览文件的内容;</li>\n<li><code>cd ..</code> , <code>cd ../..</code> </li>\n<li><code>clear</code>清除终端的内容;</li>\n<li><code>mkdir &lt;folder_name&gt;</code><ul>\n<li><code>touch &lt;file_name&gt;</code> 新建一个文件;</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p><code>ls &lt;flag&gt;</code>:</p>\n<p><code>ls -l</code> 以长格式显示文件和目录的信息:</p>\n<ul>\n<li><code>ls -lh</code>：以人类可读的格式显示文件大小（如 1K, 4.0M）;</li>\n<li><code>ls -la</code>：显示所有文件（包括隐藏文件 . 和 ..）;</li>\n<li><code>ls -ltr</code>：按时间排序，最近修改的文件排在最后.</li>\n</ul>\n<p><code>ls --help</code></p>\n<p><br></p>\n<p><code>cp &lt;file&gt; &lt;destination&gt;</code> 拷贝文件到指定目录;<br><code>rm &lt;fila_name&gt;</code> 删除指定的文件;</p>\n<p><br></p>\n<ul>\n<li><code>mv &lt;file_name&gt; &lt;new_file_name&gt;</code>: rename </li>\n<li><code>mv &lt;file&gt; &lt;destination&gt;</code>: move</li>\n</ul>\n<p><br></p>\n<p><code>find</code> 显示当前目录下的文件树<br><img src=\"/img/find-2025-01-22-11-58-20.png\" alt=\"\"></p>\n","more":"<h1 id=\"通过创建模板学习Bash\"><a href=\"#通过创建模板学习Bash\" class=\"headerlink\" title=\"通过创建模板学习Bash\"></a>通过创建模板学习Bash</h1><ul>\n<li><code>more + &lt;fileName&gt;</code> 可以预览文件的内容;</li>\n<li><code>cd ..</code> , <code>cd ../..</code> </li>\n<li><code>clear</code>清除终端的内容;</li>\n<li><code>mkdir &lt;folder_name&gt;</code><ul>\n<li><code>touch &lt;file_name&gt;</code> 新建一个文件;</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p><code>ls &lt;flag&gt;</code>:</p>\n<p><code>ls -l</code> 以长格式显示文件和目录的信息:</p>\n<ul>\n<li><code>ls -lh</code>：以人类可读的格式显示文件大小（如 1K, 4.0M）;</li>\n<li><code>ls -la</code>：显示所有文件（包括隐藏文件 . 和 ..）;</li>\n<li><code>ls -ltr</code>：按时间排序，最近修改的文件排在最后.</li>\n</ul>\n<p><code>ls --help</code></p>\n<p><br></p>\n<p><code>cp &lt;file&gt; &lt;destination&gt;</code> 拷贝文件到指定目录;<br><code>rm &lt;fila_name&gt;</code> 删除指定的文件;</p>\n<p><br></p>\n<ul>\n<li><code>mv &lt;file_name&gt; &lt;new_file_name&gt;</code>: rename </li>\n<li><code>mv &lt;file&gt; &lt;destination&gt;</code>: move</li>\n</ul>\n<p><br></p>\n<p><code>find</code> 显示当前目录下的文件树<br><img src=\"/img/find-2025-01-22-11-58-20.png\" alt=\"\"></p>\n"},{"title":"倦鸟","date":"2025-01-08T08:10:10.000Z","excerpt":"等一处栖居 🪶","index_img":"/img/倦鸟.png","banner_img":null,"hide":false,"archive":true,"_content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n<img src = \"/img/倦鸟.png\" width =\"70%\">\n> 下附最初的三节诗, 以及灵感来源.\n\n\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","source":"_posts/poets/bird.md","raw":"---\ntitle: 倦鸟\ndate: 2025-01-08 16:10:10\ntags: \n- 短诗\n- 她\ncategories: 随机掉落的文字碎片\nexcerpt: 等一处栖居 🪶\nindex_img: /img/倦鸟.png\nbanner_img: \nhide: false\narchive: true\n---\n<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n<img src = \"/img/倦鸟.png\" width =\"70%\">\n> 下附最初的三节诗, 以及灵感来源.\n\n\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","slug":"poets/bird","published":1,"updated":"2025-01-19T11:46:34.125Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vv000adwqggpb183fx","content":"<p><br></p>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n<p><img src = \"/img/倦鸟.png\" width =\"70%\"></p>\n<blockquote>\n<p>下附最初的三节诗, 以及灵感来源.</p>\n</blockquote>\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","more":"<p><br></p>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n<p><img src = \"/img/倦鸟.png\" width =\"70%\"></p>\n<blockquote>\n<p>下附最初的三节诗, 以及灵感来源.</p>\n</blockquote>\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>"},{"title":"晚霞","date":"2025-01-09T12:59:02.000Z","excerpt":"记紫金港的世纪晚霞","hide":false,"archive":true,"_content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n默默期待着  <br>\n</p>\n\n<img src = \"/img/晚霞.jpg\" width = \"70%\">","source":"_posts/poets/晚霞.md","raw":"---\ntitle: 晚霞\ndate: 2025-01-09 20:59:02\ntags: \n- 短诗\n- 自然\ncategories: 随机掉落的文字碎片\nexcerpt: 记紫金港的世纪晚霞\nhide: false\narchive: true\n---\n<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n默默期待着  <br>\n</p>\n\n<img src = \"/img/晚霞.jpg\" width = \"70%\">","slug":"poets/晚霞","published":1,"updated":"2025-01-24T06:35:46.868Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vw000edwqg4g5mcmci","content":"<p><br></p>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n默默期待着  <br>\n</p>\n\n<p><img src = \"/img/晚霞.jpg\" width = \"70%\"></p>\n","more":"<p><br></p>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n默默期待着  <br>\n</p>\n\n<p><img src = \"/img/晚霞.jpg\" width = \"70%\"></p>\n"},{"title":"AI-beginner","date":"2025-02-15T05:47:23.000Z","excerpt":"一起来学习AI吧！","math":true,"_content":"\n# Introduction to AI\n## Definition of Intelligence\n在讨论AI之前, 我们需要对**智能**作出定义. 作为一个复杂的概念, 不同领域对其具有不同的理解:\n1. **传统定义**\n- 学习或理解新事物的能力\n- 处理抽象概念的能力\n- 适应新情况的能力\n- 理解和运用知识解决问题的能力\n\n2. **计算机科学视角**\n- **感知能力**: 接收和处理输入信息;\n- **推理能力**: 基于已知信息进行逻辑推导;\n- **学习能力**: 从经验中改进性能;\n- **适应能力**: 能够应对新的情况;\n- **决策能力**: 能够在不确定的情况下作出合理的选择.\n\n### Turing Test\nAlan Turning提出的图灵测试为判断机器是否具有智能提供了一个可操作的标准:\n\n\t如果一个机器可以与人类进行对话, 且人类无法判断对方是机器还是人类, 则认为这个机器具有智能.\n\t\n\t\n\n## Approaches to AI\n为了让计算机的*思维意识*像人类一样表现, 我们需要以某种方式用自己的思维方式对计算机进行**建模**.\n\n建模方式主要有两种方法:\n- 自上而下的方法--符号推理 Symbolic Reasoning\n- 自下而上的方法--神经网络 Neural Networks\n\n### Top-down Approach\n符号推理试图模拟人类的推理过程和决策方式. 这一推理方式需要基于规则和逻辑的系统, 建模的流程分为:\n1. 从人类专家中获取知识;\n2. 将知识转换为计算机可读的形式;\n3. 建立明确的规则和推理系统.\n\n#### 应用案例\n典型的应用包括专家系统（Expert Systems）和早期的棋类游戏程序。以医疗诊断系统为例，医生在诊断过程中会遵循一系列规则：\n- 如果病人有发烧症状，可能存在炎症\n- 根据具体症状组合，推导出可能的诊断结果\n\n#### 优势与局限\n优势：\n- 推理过程透明，可解释性强\n- 适合处理有明确规则的问题领域\n\n局限：\n- 难以处理模糊或不确定的情况\n- 知识获取和维护成本高昂\n- 难以适应新情况\n\n### Bottom-up Approach\n最初,自上而下的符号推理是普遍的方法, 但是其知识的提取和维护成本较高, 因此可以考虑自下而上的方法.\n\n这种方法也被称之为**神经网络方法**. 它通过建模大脑内部最简单的元素--神经元, 尝试在计算机内部构建一个所谓的人工神经网络.\n\n#### 工作原理\n神经网络通过以下方式工作：\n1. 构建由大量简单神经元组成的网络\n2. 每个神经元作为其输入的加权平均值\n3. 通过提供训练数据来教会网络解决问题\n4. 网络通过反复学习优化权重参数\n\n#### 现代应用\n近年来，神经网络在多个领域取得了突破性进展：\n- 计算机视觉（Computer Vision）\n- 自然语言处理（NLP）\n- 语音识别（Speech Recognition）\n- 自动驾驶（Autonomous Driving）\n\n### 混合方法\n在实际应用中，往往会采用混合方法来获得更好的效果。例如现代AI助手：\n- 使用神经网络进行语音识别和自然语言理解\n- 使用规则系统处理具体任务执行\n- 结合知识图谱提供更准确的答案\n\n### 未来展望\n随着计算能力的提升和数据规模的扩大，神经网络方法可能会在更多领域占据主导地位。但在一些特定场景下，符号推理的优势仍然不可替代，未来可能会出现更多两种方法的融合应用。\n\n---\n\n# Symbolic AI\n正如在[Top-down Approach](#Top-down-Approach)部分所描述的, 在AI的早期, 通过自上而下的方法来创建Intelligent systems是很受欢迎的. 改方法基于两个重要的想法:\n- Knowledge Representation 知识表示 \n- Reasoning 推理 \n\n## Knowledge Representation\n在`Symbolic AI`中的重要概念之一就是**Knowledge**. \n\n知识需要与其他概念进行区分:\n- **Data**: 数据是物理媒介中所展示的, 比如文本与单词. 数据独立于人类, 可以在人之间传递;\n- **Information**: 信息是我们如何解释脑海中的数据;\n- **Knowledge**: 通过将信息整合到我们感知世界的认知模型中, 我们获得了知识;\n- **Wisdom**: 智慧代表我们理解世界的一个水平.\n\n\n因此, **‌Knowledge Representation**的问题就是——寻找有效的方式将数据`Data`来表示计算机内部的知识, 以使其自动可用.\n\n### Hierarchical\nHierarchical representations 即 **分层表示**, 强调在脑海中创建一个对象的层次结构, 是一种模仿人类思维方式的知识组织方法.\n\n用金丝雀的例子来说明层级表示:\n- **基本的层级关系**:\n\t- 金丝雀 $\\rightarrow$ 鸟 ;\n\t- 鸟 $\\rightarrow$ 具有翅膀\n- **属性继承**:\n\t- 由于金丝雀是鸟, 所以它继承了鸟类的特征--具有翅膀;\n\t- 同时, 金丝雀还具有自身特殊的属性--如颜色与飞行速度.\n\n```markdown\n鸟类\n  ├── 特征：有翅膀\n  ├── 特征：有羽毛\n  │\n  └── 金丝雀\n      ├── 继承：有翅膀\n      ├── 继承：有羽毛\n      ├── 特征：黄色\n      └── 特征：飞行速度快\n```\n\n这种分层表示的方法十分常见, 面向对象编程中的**类继承**就是具体的应用.\n\n### Procedural\nProcedural representation 即 **过程表示**. 它着重于描述“如何做”, 关注知识的动态性和可执行性. 通过将知识编码为一系列具体的操作步骤或规则, 适用于处理具有决策流程的场景.\n\n过程表示最常见的形式是`Production rules`产生式规则. 这种规则采用`if-then`的形式, 非常接近人类的思维方式.\n> 比如在医疗诊断系统中，医生的诊断经验可以被编码为一系列规则：当观察到某些症状时，系统就会建议进行特定的检查或治疗。这种表示方式的优势在于它既直观又易于理解，同时也便于计算机执行。\n\n算法是另一种重要的过程表示形式. 它将解决问题的步骤明确地编排成序列, 且每个步骤都是确定和**可执行**的\n\n在现代人工智能系统中，过程表示通常与其他知识表示方式结合使用。例如，一个智能教学系统可能会使用框架来表示课程内容的结构，而用过程表示来描述解题策略和教学方法。\n\n## Expert Systems\n专家系统是`symbolic AI`早期的成功产物之一.\n\n专家系统旨在某些有限的问题域中充当专家的计算机系统","source":"_posts/AI/AI-beginner.md","raw":"---\ntitle: AI-beginner\ndate: 2025-02-15 13:47:23\ntags:\ncategories:\nexcerpt: 一起来学习AI吧！\nmath: true\n---\n\n# Introduction to AI\n## Definition of Intelligence\n在讨论AI之前, 我们需要对**智能**作出定义. 作为一个复杂的概念, 不同领域对其具有不同的理解:\n1. **传统定义**\n- 学习或理解新事物的能力\n- 处理抽象概念的能力\n- 适应新情况的能力\n- 理解和运用知识解决问题的能力\n\n2. **计算机科学视角**\n- **感知能力**: 接收和处理输入信息;\n- **推理能力**: 基于已知信息进行逻辑推导;\n- **学习能力**: 从经验中改进性能;\n- **适应能力**: 能够应对新的情况;\n- **决策能力**: 能够在不确定的情况下作出合理的选择.\n\n### Turing Test\nAlan Turning提出的图灵测试为判断机器是否具有智能提供了一个可操作的标准:\n\n\t如果一个机器可以与人类进行对话, 且人类无法判断对方是机器还是人类, 则认为这个机器具有智能.\n\t\n\t\n\n## Approaches to AI\n为了让计算机的*思维意识*像人类一样表现, 我们需要以某种方式用自己的思维方式对计算机进行**建模**.\n\n建模方式主要有两种方法:\n- 自上而下的方法--符号推理 Symbolic Reasoning\n- 自下而上的方法--神经网络 Neural Networks\n\n### Top-down Approach\n符号推理试图模拟人类的推理过程和决策方式. 这一推理方式需要基于规则和逻辑的系统, 建模的流程分为:\n1. 从人类专家中获取知识;\n2. 将知识转换为计算机可读的形式;\n3. 建立明确的规则和推理系统.\n\n#### 应用案例\n典型的应用包括专家系统（Expert Systems）和早期的棋类游戏程序。以医疗诊断系统为例，医生在诊断过程中会遵循一系列规则：\n- 如果病人有发烧症状，可能存在炎症\n- 根据具体症状组合，推导出可能的诊断结果\n\n#### 优势与局限\n优势：\n- 推理过程透明，可解释性强\n- 适合处理有明确规则的问题领域\n\n局限：\n- 难以处理模糊或不确定的情况\n- 知识获取和维护成本高昂\n- 难以适应新情况\n\n### Bottom-up Approach\n最初,自上而下的符号推理是普遍的方法, 但是其知识的提取和维护成本较高, 因此可以考虑自下而上的方法.\n\n这种方法也被称之为**神经网络方法**. 它通过建模大脑内部最简单的元素--神经元, 尝试在计算机内部构建一个所谓的人工神经网络.\n\n#### 工作原理\n神经网络通过以下方式工作：\n1. 构建由大量简单神经元组成的网络\n2. 每个神经元作为其输入的加权平均值\n3. 通过提供训练数据来教会网络解决问题\n4. 网络通过反复学习优化权重参数\n\n#### 现代应用\n近年来，神经网络在多个领域取得了突破性进展：\n- 计算机视觉（Computer Vision）\n- 自然语言处理（NLP）\n- 语音识别（Speech Recognition）\n- 自动驾驶（Autonomous Driving）\n\n### 混合方法\n在实际应用中，往往会采用混合方法来获得更好的效果。例如现代AI助手：\n- 使用神经网络进行语音识别和自然语言理解\n- 使用规则系统处理具体任务执行\n- 结合知识图谱提供更准确的答案\n\n### 未来展望\n随着计算能力的提升和数据规模的扩大，神经网络方法可能会在更多领域占据主导地位。但在一些特定场景下，符号推理的优势仍然不可替代，未来可能会出现更多两种方法的融合应用。\n\n---\n\n# Symbolic AI\n正如在[Top-down Approach](#Top-down-Approach)部分所描述的, 在AI的早期, 通过自上而下的方法来创建Intelligent systems是很受欢迎的. 改方法基于两个重要的想法:\n- Knowledge Representation 知识表示 \n- Reasoning 推理 \n\n## Knowledge Representation\n在`Symbolic AI`中的重要概念之一就是**Knowledge**. \n\n知识需要与其他概念进行区分:\n- **Data**: 数据是物理媒介中所展示的, 比如文本与单词. 数据独立于人类, 可以在人之间传递;\n- **Information**: 信息是我们如何解释脑海中的数据;\n- **Knowledge**: 通过将信息整合到我们感知世界的认知模型中, 我们获得了知识;\n- **Wisdom**: 智慧代表我们理解世界的一个水平.\n\n\n因此, **‌Knowledge Representation**的问题就是——寻找有效的方式将数据`Data`来表示计算机内部的知识, 以使其自动可用.\n\n### Hierarchical\nHierarchical representations 即 **分层表示**, 强调在脑海中创建一个对象的层次结构, 是一种模仿人类思维方式的知识组织方法.\n\n用金丝雀的例子来说明层级表示:\n- **基本的层级关系**:\n\t- 金丝雀 $\\rightarrow$ 鸟 ;\n\t- 鸟 $\\rightarrow$ 具有翅膀\n- **属性继承**:\n\t- 由于金丝雀是鸟, 所以它继承了鸟类的特征--具有翅膀;\n\t- 同时, 金丝雀还具有自身特殊的属性--如颜色与飞行速度.\n\n```markdown\n鸟类\n  ├── 特征：有翅膀\n  ├── 特征：有羽毛\n  │\n  └── 金丝雀\n      ├── 继承：有翅膀\n      ├── 继承：有羽毛\n      ├── 特征：黄色\n      └── 特征：飞行速度快\n```\n\n这种分层表示的方法十分常见, 面向对象编程中的**类继承**就是具体的应用.\n\n### Procedural\nProcedural representation 即 **过程表示**. 它着重于描述“如何做”, 关注知识的动态性和可执行性. 通过将知识编码为一系列具体的操作步骤或规则, 适用于处理具有决策流程的场景.\n\n过程表示最常见的形式是`Production rules`产生式规则. 这种规则采用`if-then`的形式, 非常接近人类的思维方式.\n> 比如在医疗诊断系统中，医生的诊断经验可以被编码为一系列规则：当观察到某些症状时，系统就会建议进行特定的检查或治疗。这种表示方式的优势在于它既直观又易于理解，同时也便于计算机执行。\n\n算法是另一种重要的过程表示形式. 它将解决问题的步骤明确地编排成序列, 且每个步骤都是确定和**可执行**的\n\n在现代人工智能系统中，过程表示通常与其他知识表示方式结合使用。例如，一个智能教学系统可能会使用框架来表示课程内容的结构，而用过程表示来描述解题策略和教学方法。\n\n## Expert Systems\n专家系统是`symbolic AI`早期的成功产物之一.\n\n专家系统旨在某些有限的问题域中充当专家的计算机系统","slug":"AI/AI-beginner","published":1,"updated":"2025-02-15T07:20:39.548Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vw000fdwqgg7g42qxy","content":"<h1 id=\"Introduction-to-AI\"><a href=\"#Introduction-to-AI\" class=\"headerlink\" title=\"Introduction to AI\"></a>Introduction to AI</h1><h2 id=\"Definition-of-Intelligence\"><a href=\"#Definition-of-Intelligence\" class=\"headerlink\" title=\"Definition of Intelligence\"></a>Definition of Intelligence</h2><p>在讨论AI之前, 我们需要对<strong>智能</strong>作出定义. 作为一个复杂的概念, 不同领域对其具有不同的理解:</p>\n<ol>\n<li><strong>传统定义</strong></li>\n</ol>\n<ul>\n<li>学习或理解新事物的能力</li>\n<li>处理抽象概念的能力</li>\n<li>适应新情况的能力</li>\n<li>理解和运用知识解决问题的能力</li>\n</ul>\n<ol>\n<li><strong>计算机科学视角</strong></li>\n</ol>\n<ul>\n<li><strong>感知能力</strong>: 接收和处理输入信息;</li>\n<li><strong>推理能力</strong>: 基于已知信息进行逻辑推导;</li>\n<li><strong>学习能力</strong>: 从经验中改进性能;</li>\n<li><strong>适应能力</strong>: 能够应对新的情况;</li>\n<li><strong>决策能力</strong>: 能够在不确定的情况下作出合理的选择.</li>\n</ul>\n<h3 id=\"Turing-Test\"><a href=\"#Turing-Test\" class=\"headerlink\" title=\"Turing Test\"></a>Turing Test</h3><p>Alan Turning提出的图灵测试为判断机器是否具有智能提供了一个可操作的标准:</p>\n<pre><code class=\"hljs\">如果一个机器可以与人类进行对话, 且人类无法判断对方是机器还是人类, 则认为这个机器具有智能.\n</code></pre><h2 id=\"Approaches-to-AI\"><a href=\"#Approaches-to-AI\" class=\"headerlink\" title=\"Approaches to AI\"></a>Approaches to AI</h2><p>为了让计算机的<em>思维意识</em>像人类一样表现, 我们需要以某种方式用自己的思维方式对计算机进行<strong>建模</strong>.</p>\n<p>建模方式主要有两种方法:</p>\n<ul>\n<li>自上而下的方法—符号推理 Symbolic Reasoning</li>\n<li>自下而上的方法—神经网络 Neural Networks</li>\n</ul>\n<h3 id=\"Top-down-Approach\"><a href=\"#Top-down-Approach\" class=\"headerlink\" title=\"Top-down Approach\"></a>Top-down Approach</h3><p>符号推理试图模拟人类的推理过程和决策方式. 这一推理方式需要基于规则和逻辑的系统, 建模的流程分为:</p>\n<ol>\n<li>从人类专家中获取知识;</li>\n<li>将知识转换为计算机可读的形式;</li>\n<li>建立明确的规则和推理系统.</li>\n</ol>\n<h4 id=\"应用案例\"><a href=\"#应用案例\" class=\"headerlink\" title=\"应用案例\"></a>应用案例</h4><p>典型的应用包括专家系统（Expert Systems）和早期的棋类游戏程序。以医疗诊断系统为例，医生在诊断过程中会遵循一系列规则：</p>\n<ul>\n<li>如果病人有发烧症状，可能存在炎症</li>\n<li>根据具体症状组合，推导出可能的诊断结果</li>\n</ul>\n<h4 id=\"优势与局限\"><a href=\"#优势与局限\" class=\"headerlink\" title=\"优势与局限\"></a>优势与局限</h4><p>优势：</p>\n<ul>\n<li>推理过程透明，可解释性强</li>\n<li>适合处理有明确规则的问题领域</li>\n</ul>\n<p>局限：</p>\n<ul>\n<li>难以处理模糊或不确定的情况</li>\n<li>知识获取和维护成本高昂</li>\n<li>难以适应新情况</li>\n</ul>\n<h3 id=\"Bottom-up-Approach\"><a href=\"#Bottom-up-Approach\" class=\"headerlink\" title=\"Bottom-up Approach\"></a>Bottom-up Approach</h3><p>最初,自上而下的符号推理是普遍的方法, 但是其知识的提取和维护成本较高, 因此可以考虑自下而上的方法.</p>\n<p>这种方法也被称之为<strong>神经网络方法</strong>. 它通过建模大脑内部最简单的元素—神经元, 尝试在计算机内部构建一个所谓的人工神经网络.</p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>神经网络通过以下方式工作：</p>\n<ol>\n<li>构建由大量简单神经元组成的网络</li>\n<li>每个神经元作为其输入的加权平均值</li>\n<li>通过提供训练数据来教会网络解决问题</li>\n<li>网络通过反复学习优化权重参数</li>\n</ol>\n<h4 id=\"现代应用\"><a href=\"#现代应用\" class=\"headerlink\" title=\"现代应用\"></a>现代应用</h4><p>近年来，神经网络在多个领域取得了突破性进展：</p>\n<ul>\n<li>计算机视觉（Computer Vision）</li>\n<li>自然语言处理（NLP）</li>\n<li>语音识别（Speech Recognition）</li>\n<li>自动驾驶（Autonomous Driving）</li>\n</ul>\n<h3 id=\"混合方法\"><a href=\"#混合方法\" class=\"headerlink\" title=\"混合方法\"></a>混合方法</h3><p>在实际应用中，往往会采用混合方法来获得更好的效果。例如现代AI助手：</p>\n<ul>\n<li>使用神经网络进行语音识别和自然语言理解</li>\n<li>使用规则系统处理具体任务执行</li>\n<li>结合知识图谱提供更准确的答案</li>\n</ul>\n<h3 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h3><p>随着计算能力的提升和数据规模的扩大，神经网络方法可能会在更多领域占据主导地位。但在一些特定场景下，符号推理的优势仍然不可替代，未来可能会出现更多两种方法的融合应用。</p>\n<hr>\n<h1 id=\"Symbolic-AI\"><a href=\"#Symbolic-AI\" class=\"headerlink\" title=\"Symbolic AI\"></a>Symbolic AI</h1><p>正如在<a href=\"#Top-down-Approach\">Top-down Approach</a>部分所描述的, 在AI的早期, 通过自上而下的方法来创建Intelligent systems是很受欢迎的. 改方法基于两个重要的想法:</p>\n<ul>\n<li>Knowledge Representation 知识表示 </li>\n<li>Reasoning 推理 </li>\n</ul>\n<h2 id=\"Knowledge-Representation\"><a href=\"#Knowledge-Representation\" class=\"headerlink\" title=\"Knowledge Representation\"></a>Knowledge Representation</h2><p>在<code>Symbolic AI</code>中的重要概念之一就是<strong>Knowledge</strong>. </p>\n<p>知识需要与其他概念进行区分:</p>\n<ul>\n<li><strong>Data</strong>: 数据是物理媒介中所展示的, 比如文本与单词. 数据独立于人类, 可以在人之间传递;</li>\n<li><strong>Information</strong>: 信息是我们如何解释脑海中的数据;</li>\n<li><strong>Knowledge</strong>: 通过将信息整合到我们感知世界的认知模型中, 我们获得了知识;</li>\n<li><strong>Wisdom</strong>: 智慧代表我们理解世界的一个水平.</li>\n</ul>\n<p>因此, <strong>‌Knowledge Representation</strong>的问题就是——寻找有效的方式将数据<code>Data</code>来表示计算机内部的知识, 以使其自动可用.</p>\n<h3 id=\"Hierarchical\"><a href=\"#Hierarchical\" class=\"headerlink\" title=\"Hierarchical\"></a>Hierarchical</h3><p>Hierarchical representations 即 <strong>分层表示</strong>, 强调在脑海中创建一个对象的层次结构, 是一种模仿人类思维方式的知识组织方法.</p>\n<p>用金丝雀的例子来说明层级表示:</p>\n<ul>\n<li><strong>基本的层级关系</strong>:<ul>\n<li>金丝雀 $\\rightarrow$ 鸟 ;</li>\n<li>鸟 $\\rightarrow$ 具有翅膀</li>\n</ul>\n</li>\n<li><strong>属性继承</strong>:<ul>\n<li>由于金丝雀是鸟, 所以它继承了鸟类的特征—具有翅膀;</li>\n<li>同时, 金丝雀还具有自身特殊的属性—如颜色与飞行速度.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">鸟类<br>  ├── 特征：有翅膀<br>  ├── 特征：有羽毛<br>  │<br>  └── 金丝雀<br><span class=\"hljs-code\">      ├── 继承：有翅膀</span><br><span class=\"hljs-code\">      ├── 继承：有羽毛</span><br><span class=\"hljs-code\">      ├── 特征：黄色</span><br><span class=\"hljs-code\">      └── 特征：飞行速度快</span><br></code></pre></td></tr></table></figure>\n<p>这种分层表示的方法十分常见, 面向对象编程中的<strong>类继承</strong>就是具体的应用.</p>\n<h3 id=\"Procedural\"><a href=\"#Procedural\" class=\"headerlink\" title=\"Procedural\"></a>Procedural</h3><p>Procedural representation 即 <strong>过程表示</strong>. 它着重于描述“如何做”, 关注知识的动态性和可执行性. 通过将知识编码为一系列具体的操作步骤或规则, 适用于处理具有决策流程的场景.</p>\n<p>过程表示最常见的形式是<code>Production rules</code>产生式规则. 这种规则采用<code>if-then</code>的形式, 非常接近人类的思维方式.</p>\n<blockquote>\n<p>比如在医疗诊断系统中，医生的诊断经验可以被编码为一系列规则：当观察到某些症状时，系统就会建议进行特定的检查或治疗。这种表示方式的优势在于它既直观又易于理解，同时也便于计算机执行。</p>\n</blockquote>\n<p>算法是另一种重要的过程表示形式. 它将解决问题的步骤明确地编排成序列, 且每个步骤都是确定和<strong>可执行</strong>的</p>\n<p>在现代人工智能系统中，过程表示通常与其他知识表示方式结合使用。例如，一个智能教学系统可能会使用框架来表示课程内容的结构，而用过程表示来描述解题策略和教学方法。</p>\n<h2 id=\"Expert-Systems\"><a href=\"#Expert-Systems\" class=\"headerlink\" title=\"Expert Systems\"></a>Expert Systems</h2><p>专家系统是<code>symbolic AI</code>早期的成功产物之一.</p>\n<p>专家系统旨在某些有限的问题域中充当专家的计算机系统</p>\n","more":"<h1 id=\"Introduction-to-AI\"><a href=\"#Introduction-to-AI\" class=\"headerlink\" title=\"Introduction to AI\"></a>Introduction to AI</h1><h2 id=\"Definition-of-Intelligence\"><a href=\"#Definition-of-Intelligence\" class=\"headerlink\" title=\"Definition of Intelligence\"></a>Definition of Intelligence</h2><p>在讨论AI之前, 我们需要对<strong>智能</strong>作出定义. 作为一个复杂的概念, 不同领域对其具有不同的理解:</p>\n<ol>\n<li><strong>传统定义</strong></li>\n</ol>\n<ul>\n<li>学习或理解新事物的能力</li>\n<li>处理抽象概念的能力</li>\n<li>适应新情况的能力</li>\n<li>理解和运用知识解决问题的能力</li>\n</ul>\n<ol>\n<li><strong>计算机科学视角</strong></li>\n</ol>\n<ul>\n<li><strong>感知能力</strong>: 接收和处理输入信息;</li>\n<li><strong>推理能力</strong>: 基于已知信息进行逻辑推导;</li>\n<li><strong>学习能力</strong>: 从经验中改进性能;</li>\n<li><strong>适应能力</strong>: 能够应对新的情况;</li>\n<li><strong>决策能力</strong>: 能够在不确定的情况下作出合理的选择.</li>\n</ul>\n<h3 id=\"Turing-Test\"><a href=\"#Turing-Test\" class=\"headerlink\" title=\"Turing Test\"></a>Turing Test</h3><p>Alan Turning提出的图灵测试为判断机器是否具有智能提供了一个可操作的标准:</p>\n<pre><code>如果一个机器可以与人类进行对话, 且人类无法判断对方是机器还是人类, 则认为这个机器具有智能.\n</code></pre><h2 id=\"Approaches-to-AI\"><a href=\"#Approaches-to-AI\" class=\"headerlink\" title=\"Approaches to AI\"></a>Approaches to AI</h2><p>为了让计算机的<em>思维意识</em>像人类一样表现, 我们需要以某种方式用自己的思维方式对计算机进行<strong>建模</strong>.</p>\n<p>建模方式主要有两种方法:</p>\n<ul>\n<li>自上而下的方法—符号推理 Symbolic Reasoning</li>\n<li>自下而上的方法—神经网络 Neural Networks</li>\n</ul>\n<h3 id=\"Top-down-Approach\"><a href=\"#Top-down-Approach\" class=\"headerlink\" title=\"Top-down Approach\"></a>Top-down Approach</h3><p>符号推理试图模拟人类的推理过程和决策方式. 这一推理方式需要基于规则和逻辑的系统, 建模的流程分为:</p>\n<ol>\n<li>从人类专家中获取知识;</li>\n<li>将知识转换为计算机可读的形式;</li>\n<li>建立明确的规则和推理系统.</li>\n</ol>\n<h4 id=\"应用案例\"><a href=\"#应用案例\" class=\"headerlink\" title=\"应用案例\"></a>应用案例</h4><p>典型的应用包括专家系统（Expert Systems）和早期的棋类游戏程序。以医疗诊断系统为例，医生在诊断过程中会遵循一系列规则：</p>\n<ul>\n<li>如果病人有发烧症状，可能存在炎症</li>\n<li>根据具体症状组合，推导出可能的诊断结果</li>\n</ul>\n<h4 id=\"优势与局限\"><a href=\"#优势与局限\" class=\"headerlink\" title=\"优势与局限\"></a>优势与局限</h4><p>优势：</p>\n<ul>\n<li>推理过程透明，可解释性强</li>\n<li>适合处理有明确规则的问题领域</li>\n</ul>\n<p>局限：</p>\n<ul>\n<li>难以处理模糊或不确定的情况</li>\n<li>知识获取和维护成本高昂</li>\n<li>难以适应新情况</li>\n</ul>\n<h3 id=\"Bottom-up-Approach\"><a href=\"#Bottom-up-Approach\" class=\"headerlink\" title=\"Bottom-up Approach\"></a>Bottom-up Approach</h3><p>最初,自上而下的符号推理是普遍的方法, 但是其知识的提取和维护成本较高, 因此可以考虑自下而上的方法.</p>\n<p>这种方法也被称之为<strong>神经网络方法</strong>. 它通过建模大脑内部最简单的元素—神经元, 尝试在计算机内部构建一个所谓的人工神经网络.</p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>神经网络通过以下方式工作：</p>\n<ol>\n<li>构建由大量简单神经元组成的网络</li>\n<li>每个神经元作为其输入的加权平均值</li>\n<li>通过提供训练数据来教会网络解决问题</li>\n<li>网络通过反复学习优化权重参数</li>\n</ol>\n<h4 id=\"现代应用\"><a href=\"#现代应用\" class=\"headerlink\" title=\"现代应用\"></a>现代应用</h4><p>近年来，神经网络在多个领域取得了突破性进展：</p>\n<ul>\n<li>计算机视觉（Computer Vision）</li>\n<li>自然语言处理（NLP）</li>\n<li>语音识别（Speech Recognition）</li>\n<li>自动驾驶（Autonomous Driving）</li>\n</ul>\n<h3 id=\"混合方法\"><a href=\"#混合方法\" class=\"headerlink\" title=\"混合方法\"></a>混合方法</h3><p>在实际应用中，往往会采用混合方法来获得更好的效果。例如现代AI助手：</p>\n<ul>\n<li>使用神经网络进行语音识别和自然语言理解</li>\n<li>使用规则系统处理具体任务执行</li>\n<li>结合知识图谱提供更准确的答案</li>\n</ul>\n<h3 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h3><p>随着计算能力的提升和数据规模的扩大，神经网络方法可能会在更多领域占据主导地位。但在一些特定场景下，符号推理的优势仍然不可替代，未来可能会出现更多两种方法的融合应用。</p>\n<hr>\n<h1 id=\"Symbolic-AI\"><a href=\"#Symbolic-AI\" class=\"headerlink\" title=\"Symbolic AI\"></a>Symbolic AI</h1><p>正如在<a href=\"#Top-down-Approach\">Top-down Approach</a>部分所描述的, 在AI的早期, 通过自上而下的方法来创建Intelligent systems是很受欢迎的. 改方法基于两个重要的想法:</p>\n<ul>\n<li>Knowledge Representation 知识表示 </li>\n<li>Reasoning 推理 </li>\n</ul>\n<h2 id=\"Knowledge-Representation\"><a href=\"#Knowledge-Representation\" class=\"headerlink\" title=\"Knowledge Representation\"></a>Knowledge Representation</h2><p>在<code>Symbolic AI</code>中的重要概念之一就是<strong>Knowledge</strong>. </p>\n<p>知识需要与其他概念进行区分:</p>\n<ul>\n<li><strong>Data</strong>: 数据是物理媒介中所展示的, 比如文本与单词. 数据独立于人类, 可以在人之间传递;</li>\n<li><strong>Information</strong>: 信息是我们如何解释脑海中的数据;</li>\n<li><strong>Knowledge</strong>: 通过将信息整合到我们感知世界的认知模型中, 我们获得了知识;</li>\n<li><strong>Wisdom</strong>: 智慧代表我们理解世界的一个水平.</li>\n</ul>\n<p>因此, <strong>‌Knowledge Representation</strong>的问题就是——寻找有效的方式将数据<code>Data</code>来表示计算机内部的知识, 以使其自动可用.</p>\n<h3 id=\"Hierarchical\"><a href=\"#Hierarchical\" class=\"headerlink\" title=\"Hierarchical\"></a>Hierarchical</h3><p>Hierarchical representations 即 <strong>分层表示</strong>, 强调在脑海中创建一个对象的层次结构, 是一种模仿人类思维方式的知识组织方法.</p>\n<p>用金丝雀的例子来说明层级表示:</p>\n<ul>\n<li><strong>基本的层级关系</strong>:<ul>\n<li>金丝雀 $\\rightarrow$ 鸟 ;</li>\n<li>鸟 $\\rightarrow$ 具有翅膀</li>\n</ul>\n</li>\n<li><strong>属性继承</strong>:<ul>\n<li>由于金丝雀是鸟, 所以它继承了鸟类的特征—具有翅膀;</li>\n<li>同时, 金丝雀还具有自身特殊的属性—如颜色与飞行速度.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">鸟类<br>  ├── 特征：有翅膀<br>  ├── 特征：有羽毛<br>  │<br>  └── 金丝雀<br><span class=\"hljs-code\">      ├── 继承：有翅膀</span><br><span class=\"hljs-code\">      ├── 继承：有羽毛</span><br><span class=\"hljs-code\">      ├── 特征：黄色</span><br><span class=\"hljs-code\">      └── 特征：飞行速度快</span><br></code></pre></td></tr></table></figure>\n<p>这种分层表示的方法十分常见, 面向对象编程中的<strong>类继承</strong>就是具体的应用.</p>\n<h3 id=\"Procedural\"><a href=\"#Procedural\" class=\"headerlink\" title=\"Procedural\"></a>Procedural</h3><p>Procedural representation 即 <strong>过程表示</strong>. 它着重于描述“如何做”, 关注知识的动态性和可执行性. 通过将知识编码为一系列具体的操作步骤或规则, 适用于处理具有决策流程的场景.</p>\n<p>过程表示最常见的形式是<code>Production rules</code>产生式规则. 这种规则采用<code>if-then</code>的形式, 非常接近人类的思维方式.</p>\n<blockquote>\n<p>比如在医疗诊断系统中，医生的诊断经验可以被编码为一系列规则：当观察到某些症状时，系统就会建议进行特定的检查或治疗。这种表示方式的优势在于它既直观又易于理解，同时也便于计算机执行。</p>\n</blockquote>\n<p>算法是另一种重要的过程表示形式. 它将解决问题的步骤明确地编排成序列, 且每个步骤都是确定和<strong>可执行</strong>的</p>\n<p>在现代人工智能系统中，过程表示通常与其他知识表示方式结合使用。例如，一个智能教学系统可能会使用框架来表示课程内容的结构，而用过程表示来描述解题策略和教学方法。</p>\n<h2 id=\"Expert-Systems\"><a href=\"#Expert-Systems\" class=\"headerlink\" title=\"Expert Systems\"></a>Expert Systems</h2><p>专家系统是<code>symbolic AI</code>早期的成功产物之一.</p>\n<p>专家系统旨在某些有限的问题域中充当专家的计算机系统</p>\n"},{"title":"CORS","date":"2025-01-16T02:11:38.000Z","excerpt":"在前后端分离的项目中, 常常需要注意跨域资源共享的问题.","index_img":"/img/跨域共享.jpg","_content":"\n# 跨域资源共享（CORS）技术指南\n\n## 目录\n1. [概述](#概述)\n2. [技术背景](#技术背景)\n3. [配置方案](#配置方案)\n4. [最佳实践](#最佳实践)\n5. [问题排查](#问题排查)\n6. [参考文献](#参考文献)\n\n## 概述\n\n跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n\n## 技术背景\n\n### 同源策略基础\n\n同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n\n```plaintext\n基准URL：http://example.com/page.html\n\n跨域场景：\n- http://api.example.com/data     // 子域名差异\n- https://example.com/data        // 协议差异\n- http://example.com:8080/data    // 端口差异\n```\n\n## 配置方案\n\n### 环境变量驱动的CORS配置\n\n以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\n\n```python\nimport os\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# 从环境变量获取前端URL，如果没有设置则使用默认值\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n\n# CORS配置实现\nCORS(app, resources={\n    r\"/api/*\": {\n        \"origins\": FRONTEND_URL,\n        \"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"],\n        \"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"],\n        \"supports_credentials\": True,\n        \"expose_headers\": [\"Content-Disposition\"]\n    }\n})\n```\n\n### 配置详解\n\n让我们逐行分析这个配置：\n\n1. **环境变量设置**\n```python\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n```\n- 使用`os.environ.get()`获取环境变量\n- 提供默认值`'http://localhost:3000'`作为本地开发环境的配置\n- 可以通过环境变量轻松切换不同环境的配置\n\n2. **CORS配置参数**\n```python\n\"origins\": FRONTEND_URL\n```\n- 动态设置允许的源，基于环境变量\n- 避免了硬编码的问题\n- 支持不同部署环境的灵活配置\n\n3. **HTTP方法配置**\n```python\n\"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"]\n```\n- 明确定义允许的HTTP方法\n- 包含了RESTful API所需的全部方法\n- `OPTIONS`用于预检请求（preflight request）\n\n4. **请求头配置**\n```python\n\"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"]\n```\n- `Content-Type`：允许设置请求的内容类型\n- `Authorization`：支持身份验证令牌\n- `X-Requested-With`：用于标识AJAX请求\n\n5. **凭证支持**\n```python\n\"supports_credentials\": True\n```\n- 允许跨域请求携带凭证（如Cookie）\n- 对需要身份验证的API至关重要\n\n6. **响应头暴露**\n```python\n\"expose_headers\": [\"Content-Disposition\"]\n```\n- 允许客户端访问`Content-Disposition`响应头\n- 通常用于文件下载功能\n\n### 环境变量配置示例\n\n```bash\n# 开发环境\nexport FRONTEND_URL=http://localhost:3000\n\n# 测试环境\nexport FRONTEND_URL=http://test.example.com\n\n# 生产环境\nexport FRONTEND_URL=https://www.example.com\n```\n\n## 最佳实践\n\n### 环境变量管理建议\n\n1. **开发环境**\n- 使用`.env`文件管理本地开发环境变量\n- 将`.env`文件加入`.gitignore`\n\n2. **生产环境**\n- 使用容器化部署时通过环境变量注入\n- 使用配置管理系统统一管理环境变量\n\n### 安全性考虑\n\n1. **避免过于宽松的配置**\n```python\n# 不推荐\n\"origins\": \"*\"  \n\n# 推荐\n\"origins\": FRONTEND_URL\n```\n\n2. **合理设置凭证策略**\n- 仅在必要时启用`supports_credentials`\n- 确保前端配置匹配（`credentials: 'include'`）\n\n## 问题排查\n\n### 常见错误及解决方案\n\n1. **CORS策略违规**\n```plaintext\nAccess to XMLHttpRequest at 'http://api.example.com' from origin 'http://example.com' \nhas been blocked by CORS policy\n```\n解决方案：\n- 检查环境变量是否正确设置\n- 验证前端请求URL与配置是否匹配\n- 确认所有必要的请求头都已配置\n\n## 参考文献\n\n1. [W3C CORS Specification](https://fetch.spec.whatwg.org/?locale=zh_CN)\n2. [MDN Web Docs - Cross-Origin Resource Sharing](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n3. [Flask-CORS Official Documentation](https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN)\n","source":"_posts/前后端/CORS.md","raw":"---\ntitle: CORS\ndate: 2025-01-16 10:11:38\ntags: \n- 前后端交互  \n- 网站开发\ncategories: 学习笔记\nexcerpt: 在前后端分离的项目中, 常常需要注意跨域资源共享的问题.\nindex_img: /img/跨域共享.jpg\n---\n\n# 跨域资源共享（CORS）技术指南\n\n## 目录\n1. [概述](#概述)\n2. [技术背景](#技术背景)\n3. [配置方案](#配置方案)\n4. [最佳实践](#最佳实践)\n5. [问题排查](#问题排查)\n6. [参考文献](#参考文献)\n\n## 概述\n\n跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n\n## 技术背景\n\n### 同源策略基础\n\n同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n\n```plaintext\n基准URL：http://example.com/page.html\n\n跨域场景：\n- http://api.example.com/data     // 子域名差异\n- https://example.com/data        // 协议差异\n- http://example.com:8080/data    // 端口差异\n```\n\n## 配置方案\n\n### 环境变量驱动的CORS配置\n\n以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\n\n```python\nimport os\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# 从环境变量获取前端URL，如果没有设置则使用默认值\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n\n# CORS配置实现\nCORS(app, resources={\n    r\"/api/*\": {\n        \"origins\": FRONTEND_URL,\n        \"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"],\n        \"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"],\n        \"supports_credentials\": True,\n        \"expose_headers\": [\"Content-Disposition\"]\n    }\n})\n```\n\n### 配置详解\n\n让我们逐行分析这个配置：\n\n1. **环境变量设置**\n```python\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n```\n- 使用`os.environ.get()`获取环境变量\n- 提供默认值`'http://localhost:3000'`作为本地开发环境的配置\n- 可以通过环境变量轻松切换不同环境的配置\n\n2. **CORS配置参数**\n```python\n\"origins\": FRONTEND_URL\n```\n- 动态设置允许的源，基于环境变量\n- 避免了硬编码的问题\n- 支持不同部署环境的灵活配置\n\n3. **HTTP方法配置**\n```python\n\"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"]\n```\n- 明确定义允许的HTTP方法\n- 包含了RESTful API所需的全部方法\n- `OPTIONS`用于预检请求（preflight request）\n\n4. **请求头配置**\n```python\n\"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"]\n```\n- `Content-Type`：允许设置请求的内容类型\n- `Authorization`：支持身份验证令牌\n- `X-Requested-With`：用于标识AJAX请求\n\n5. **凭证支持**\n```python\n\"supports_credentials\": True\n```\n- 允许跨域请求携带凭证（如Cookie）\n- 对需要身份验证的API至关重要\n\n6. **响应头暴露**\n```python\n\"expose_headers\": [\"Content-Disposition\"]\n```\n- 允许客户端访问`Content-Disposition`响应头\n- 通常用于文件下载功能\n\n### 环境变量配置示例\n\n```bash\n# 开发环境\nexport FRONTEND_URL=http://localhost:3000\n\n# 测试环境\nexport FRONTEND_URL=http://test.example.com\n\n# 生产环境\nexport FRONTEND_URL=https://www.example.com\n```\n\n## 最佳实践\n\n### 环境变量管理建议\n\n1. **开发环境**\n- 使用`.env`文件管理本地开发环境变量\n- 将`.env`文件加入`.gitignore`\n\n2. **生产环境**\n- 使用容器化部署时通过环境变量注入\n- 使用配置管理系统统一管理环境变量\n\n### 安全性考虑\n\n1. **避免过于宽松的配置**\n```python\n# 不推荐\n\"origins\": \"*\"  \n\n# 推荐\n\"origins\": FRONTEND_URL\n```\n\n2. **合理设置凭证策略**\n- 仅在必要时启用`supports_credentials`\n- 确保前端配置匹配（`credentials: 'include'`）\n\n## 问题排查\n\n### 常见错误及解决方案\n\n1. **CORS策略违规**\n```plaintext\nAccess to XMLHttpRequest at 'http://api.example.com' from origin 'http://example.com' \nhas been blocked by CORS policy\n```\n解决方案：\n- 检查环境变量是否正确设置\n- 验证前端请求URL与配置是否匹配\n- 确认所有必要的请求头都已配置\n\n## 参考文献\n\n1. [W3C CORS Specification](https://fetch.spec.whatwg.org/?locale=zh_CN)\n2. [MDN Web Docs - Cross-Origin Resource Sharing](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n3. [Flask-CORS Official Documentation](https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN)\n","slug":"前后端/CORS","published":1,"updated":"2025-01-19T11:46:34.122Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vw000jdwqgab715y8e","content":"<h1 id=\"跨域资源共享（CORS）技术指南\"><a href=\"#跨域资源共享（CORS）技术指南\" class=\"headerlink\" title=\"跨域资源共享（CORS）技术指南\"></a>跨域资源共享（CORS）技术指南</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#概述\">概述</a></li>\n<li><a href=\"#技术背景\">技术背景</a></li>\n<li><a href=\"#配置方案\">配置方案</a></li>\n<li><a href=\"#最佳实践\">最佳实践</a></li>\n<li><a href=\"#问题排查\">问题排查</a></li>\n<li><a href=\"#参考文献\">参考文献</a></li>\n</ol>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。</p>\n<h2 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h2><h3 id=\"同源策略基础\"><a href=\"#同源策略基础\" class=\"headerlink\" title=\"同源策略基础\"></a>同源策略基础</h3><p>同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">基准URL：http://example.com/page.html<br><br>跨域场景：<br>- http://api.example.com/data     // 子域名差异<br>- https://example.com/data        // 协议差异<br>- http://example.com:8080/data    // 端口差异<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><h3 id=\"环境变量驱动的CORS配置\"><a href=\"#环境变量驱动的CORS配置\" class=\"headerlink\" title=\"环境变量驱动的CORS配置\"></a>环境变量驱动的CORS配置</h3><p>以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask<br><span class=\"hljs-keyword\">from</span> flask_cors <span class=\"hljs-keyword\">import</span> CORS<br><br>app = Flask(__name__)<br><br><span class=\"hljs-comment\"># 从环境变量获取前端URL，如果没有设置则使用默认值</span><br>FRONTEND_URL = os.environ.get(<span class=\"hljs-string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>)<br><br><span class=\"hljs-comment\"># CORS配置实现</span><br>CORS(app, resources=&#123;<br>    <span class=\"hljs-string\">r&quot;/api/*&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL,<br>        <span class=\"hljs-string\">&quot;methods&quot;</span>: [<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;OPTIONS&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>],<br>        <span class=\"hljs-string\">&quot;allow_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;X-Requested-With&quot;</span>],<br>        <span class=\"hljs-string\">&quot;supports_credentials&quot;</span>: <span class=\"hljs-literal\">True</span>,<br>        <span class=\"hljs-string\">&quot;expose_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Disposition&quot;</span>]<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h3><p>让我们逐行分析这个配置：</p>\n<ol>\n<li><strong>环境变量设置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">FRONTEND_URL = os.environ.get(<span class=\"hljs-string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使用<code>os.environ.get()</code>获取环境变量</li>\n<li>提供默认值<code>&#39;http://localhost:3000&#39;</code>作为本地开发环境的配置</li>\n<li>可以通过环境变量轻松切换不同环境的配置</li>\n</ul>\n<ol>\n<li><strong>CORS配置参数</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>动态设置允许的源，基于环境变量</li>\n<li>避免了硬编码的问题</li>\n<li>支持不同部署环境的灵活配置</li>\n</ul>\n<ol>\n<li><strong>HTTP方法配置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;methods&quot;</span>: [<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;OPTIONS&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>明确定义允许的HTTP方法</li>\n<li>包含了RESTful API所需的全部方法</li>\n<li><code>OPTIONS</code>用于预检请求（preflight request）</li>\n</ul>\n<ol>\n<li><strong>请求头配置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;allow_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;X-Requested-With&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><code>Content-Type</code>：允许设置请求的内容类型</li>\n<li><code>Authorization</code>：支持身份验证令牌</li>\n<li><code>X-Requested-With</code>：用于标识AJAX请求</li>\n</ul>\n<ol>\n<li><strong>凭证支持</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;supports_credentials&quot;</span>: <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>允许跨域请求携带凭证（如Cookie）</li>\n<li>对需要身份验证的API至关重要</li>\n</ul>\n<ol>\n<li><strong>响应头暴露</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;expose_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Disposition&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>允许客户端访问<code>Content-Disposition</code>响应头</li>\n<li>通常用于文件下载功能</li>\n</ul>\n<h3 id=\"环境变量配置示例\"><a href=\"#环境变量配置示例\" class=\"headerlink\" title=\"环境变量配置示例\"></a>环境变量配置示例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 开发环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=http://localhost:3000<br><br><span class=\"hljs-comment\"># 测试环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=http://test.example.com<br><br><span class=\"hljs-comment\"># 生产环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=https://www.example.com<br></code></pre></td></tr></table></figure>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"环境变量管理建议\"><a href=\"#环境变量管理建议\" class=\"headerlink\" title=\"环境变量管理建议\"></a>环境变量管理建议</h3><ol>\n<li><strong>开发环境</strong></li>\n</ol>\n<ul>\n<li>使用<code>.env</code>文件管理本地开发环境变量</li>\n<li>将<code>.env</code>文件加入<code>.gitignore</code></li>\n</ul>\n<ol>\n<li><strong>生产环境</strong></li>\n</ol>\n<ul>\n<li>使用容器化部署时通过环境变量注入</li>\n<li>使用配置管理系统统一管理环境变量</li>\n</ul>\n<h3 id=\"安全性考虑\"><a href=\"#安全性考虑\" class=\"headerlink\" title=\"安全性考虑\"></a>安全性考虑</h3><ol>\n<li><p><strong>避免过于宽松的配置</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 不推荐</span><br><span class=\"hljs-string\">&quot;origins&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span>  <br><br><span class=\"hljs-comment\"># 推荐</span><br><span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合理设置凭证策略</strong></p>\n</li>\n</ol>\n<ul>\n<li>仅在必要时启用<code>supports_credentials</code></li>\n<li>确保前端配置匹配（<code>credentials: &#39;include&#39;</code>）</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"常见错误及解决方案\"><a href=\"#常见错误及解决方案\" class=\"headerlink\" title=\"常见错误及解决方案\"></a>常见错误及解决方案</h3><ol>\n<li><strong>CORS策略违规</strong><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">Access to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; <br>has been blocked by CORS policy<br></code></pre></td></tr></table></figure>\n解决方案：</li>\n</ol>\n<ul>\n<li>检查环境变量是否正确设置</li>\n<li>验证前端请求URL与配置是否匹配</li>\n<li>确认所有必要的请求头都已配置</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://fetch.spec.whatwg.org/?locale=zh_CN\">W3C CORS Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">MDN Web Docs - Cross-Origin Resource Sharing</a></li>\n<li><a href=\"https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN\">Flask-CORS Official Documentation</a></li>\n</ol>\n","more":"<h1 id=\"跨域资源共享（CORS）技术指南\"><a href=\"#跨域资源共享（CORS）技术指南\" class=\"headerlink\" title=\"跨域资源共享（CORS）技术指南\"></a>跨域资源共享（CORS）技术指南</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#概述\">概述</a></li>\n<li><a href=\"#技术背景\">技术背景</a></li>\n<li><a href=\"#配置方案\">配置方案</a></li>\n<li><a href=\"#最佳实践\">最佳实践</a></li>\n<li><a href=\"#问题排查\">问题排查</a></li>\n<li><a href=\"#参考文献\">参考文献</a></li>\n</ol>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。</p>\n<h2 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h2><h3 id=\"同源策略基础\"><a href=\"#同源策略基础\" class=\"headerlink\" title=\"同源策略基础\"></a>同源策略基础</h3><p>同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">基准URL：http://example.com/page.html<br><br>跨域场景：<br>- http://api.example.com/data     // 子域名差异<br>- https://example.com/data        // 协议差异<br>- http://example.com:8080/data    // 端口差异<br></code></pre></td></tr></table></figure>\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><h3 id=\"环境变量驱动的CORS配置\"><a href=\"#环境变量驱动的CORS配置\" class=\"headerlink\" title=\"环境变量驱动的CORS配置\"></a>环境变量驱动的CORS配置</h3><p>以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask<br><span class=\"hljs-keyword\">from</span> flask_cors <span class=\"hljs-keyword\">import</span> CORS<br><br>app = Flask(__name__)<br><br><span class=\"hljs-comment\"># 从环境变量获取前端URL，如果没有设置则使用默认值</span><br>FRONTEND_URL = os.environ.get(<span class=\"hljs-string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>)<br><br><span class=\"hljs-comment\"># CORS配置实现</span><br>CORS(app, resources=&#123;<br>    <span class=\"hljs-string\">r&quot;/api/*&quot;</span>: &#123;<br>        <span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL,<br>        <span class=\"hljs-string\">&quot;methods&quot;</span>: [<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;OPTIONS&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>],<br>        <span class=\"hljs-string\">&quot;allow_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;X-Requested-With&quot;</span>],<br>        <span class=\"hljs-string\">&quot;supports_credentials&quot;</span>: <span class=\"hljs-literal\">True</span>,<br>        <span class=\"hljs-string\">&quot;expose_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Disposition&quot;</span>]<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<h3 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h3><p>让我们逐行分析这个配置：</p>\n<ol>\n<li><strong>环境变量设置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">FRONTEND_URL = os.environ.get(<span class=\"hljs-string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"hljs-string\">&#x27;http://localhost:3000&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使用<code>os.environ.get()</code>获取环境变量</li>\n<li>提供默认值<code>&#39;http://localhost:3000&#39;</code>作为本地开发环境的配置</li>\n<li>可以通过环境变量轻松切换不同环境的配置</li>\n</ul>\n<ol>\n<li><strong>CORS配置参数</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>动态设置允许的源，基于环境变量</li>\n<li>避免了硬编码的问题</li>\n<li>支持不同部署环境的灵活配置</li>\n</ul>\n<ol>\n<li><strong>HTTP方法配置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;methods&quot;</span>: [<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;OPTIONS&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>明确定义允许的HTTP方法</li>\n<li>包含了RESTful API所需的全部方法</li>\n<li><code>OPTIONS</code>用于预检请求（preflight request）</li>\n</ul>\n<ol>\n<li><strong>请求头配置</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;allow_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Type&quot;</span>, <span class=\"hljs-string\">&quot;Authorization&quot;</span>, <span class=\"hljs-string\">&quot;X-Requested-With&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><code>Content-Type</code>：允许设置请求的内容类型</li>\n<li><code>Authorization</code>：支持身份验证令牌</li>\n<li><code>X-Requested-With</code>：用于标识AJAX请求</li>\n</ul>\n<ol>\n<li><strong>凭证支持</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;supports_credentials&quot;</span>: <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>允许跨域请求携带凭证（如Cookie）</li>\n<li>对需要身份验证的API至关重要</li>\n</ul>\n<ol>\n<li><strong>响应头暴露</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;expose_headers&quot;</span>: [<span class=\"hljs-string\">&quot;Content-Disposition&quot;</span>]<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>允许客户端访问<code>Content-Disposition</code>响应头</li>\n<li>通常用于文件下载功能</li>\n</ul>\n<h3 id=\"环境变量配置示例\"><a href=\"#环境变量配置示例\" class=\"headerlink\" title=\"环境变量配置示例\"></a>环境变量配置示例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 开发环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=http://localhost:3000<br><br><span class=\"hljs-comment\"># 测试环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=http://test.example.com<br><br><span class=\"hljs-comment\"># 生产环境</span><br><span class=\"hljs-built_in\">export</span> FRONTEND_URL=https://www.example.com<br></code></pre></td></tr></table></figure>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"环境变量管理建议\"><a href=\"#环境变量管理建议\" class=\"headerlink\" title=\"环境变量管理建议\"></a>环境变量管理建议</h3><ol>\n<li><strong>开发环境</strong></li>\n</ol>\n<ul>\n<li>使用<code>.env</code>文件管理本地开发环境变量</li>\n<li>将<code>.env</code>文件加入<code>.gitignore</code></li>\n</ul>\n<ol>\n<li><strong>生产环境</strong></li>\n</ol>\n<ul>\n<li>使用容器化部署时通过环境变量注入</li>\n<li>使用配置管理系统统一管理环境变量</li>\n</ul>\n<h3 id=\"安全性考虑\"><a href=\"#安全性考虑\" class=\"headerlink\" title=\"安全性考虑\"></a>安全性考虑</h3><ol>\n<li><p><strong>避免过于宽松的配置</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 不推荐</span><br><span class=\"hljs-string\">&quot;origins&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span>  <br><br><span class=\"hljs-comment\"># 推荐</span><br><span class=\"hljs-string\">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合理设置凭证策略</strong></p>\n</li>\n</ol>\n<ul>\n<li>仅在必要时启用<code>supports_credentials</code></li>\n<li>确保前端配置匹配（<code>credentials: &#39;include&#39;</code>）</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"常见错误及解决方案\"><a href=\"#常见错误及解决方案\" class=\"headerlink\" title=\"常见错误及解决方案\"></a>常见错误及解决方案</h3><ol>\n<li><strong>CORS策略违规</strong><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">Access to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; <br>has been blocked by CORS policy<br></code></pre></td></tr></table></figure>\n解决方案：</li>\n</ol>\n<ul>\n<li>检查环境变量是否正确设置</li>\n<li>验证前端请求URL与配置是否匹配</li>\n<li>确认所有必要的请求头都已配置</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://fetch.spec.whatwg.org/?locale=zh_CN\">W3C CORS Specification</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\">MDN Web Docs - Cross-Origin Resource Sharing</a></li>\n<li><a href=\"https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN\">Flask-CORS Official Documentation</a></li>\n</ol>\n"},{"title":"响应式设计","date":"2025-01-20T13:38:45.000Z","excerpt":"通过在freecodeCamp上的入门项目“响应式设计”来复习html等基础知识.","index_img":null,"math":true,"_content":"\n所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n- 第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n- 另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n<br>\n\n注意嵌套的形式.\ne.g\n```html\n <p>See more <a href=\"https://freecatphotoapp.com\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n```html\n<p>See more <a href=\"https://freecatphotoapp.com\" target = \"_blank\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n锚元素除了能将文本转化为链接, 还可以将 **图片** 转换为链接:\n```html\n<a hreg = \"https://freecatphotoapp.com\">\n    <img src=\"https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg\" alt=\"A cute orange cat lying on its back.\">\n</a>\n```\n\n<br>\n\n\n**section** 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n<br>\n\n\n列表:\n- 无序列表: `ul`;\n- 有序列表:`ol`;\n- 列表项: `li`;\n\n<br>\n\n\n**figure** 元素代表自包含的内容，允许将图像与标题相关联;\n**figcaption** 元素用于添加标题以描述 figure 元素中包含的图像。\n```html\n<figure>\n  <img src=\"image.jpg\" alt=\"A description of the image\">\n  <figcaption>A cute cat</figcaption>\n</figure>\n```\n\n<br>\n\n\n- 使用 **em** 使得文字为斜体;\n- `strong` 加深文字;\n\n<br>\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n- `action`属性指定表单数据发送的位置;\n``` html\n<form action=\"/submit-url\"></form>\n```\n\n---\ninput 允许通过多种方式从Web表单中收集数据:\n- 与`img`一样为空元素——不需要结束标签;\n- 使用 `type` 属性创建多种输入;\n  - `text` : 文本;\n  - `radio`: 可以使用单选按钮;\n  - `checkbox`: 表单使用 **复选框**;\n- 使用`name`属性使得区分提交的数据;\n  - 令多个单选按钮具有 **相同** 的`name`, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n  - 形成`name = value`形式的属性对进行提交;\n```html\n<label><input id=\"indoor\" type=\"radio\" name = \"indoor-outdoor\"> Indoor</label>\n<label><input id=\"outdoor\" type=\"radio\" name = 'indoor-outdoor'> Outdoor</label>\n```\n- `placeholder` 中为 **占位符** 文本, 用于提示输入框中输入的信息;\n- `required`属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n```html\n    <input type=\"text\" name = \"catphotourl\">\n```\n\n<br>\n\n\n`button` 用于创建可点击的按钮:\n- 单击**没有任何属性**的表单按钮的默认行为会将表单提交到**表单**的 `action `属性中指定的位置;\n- 由于`input`和`button`为 **内联** 元素, 即使相隔书写也会显示在同行:\n- `type`的`submit`明确了为 可提交按钮;\n```html\n<button type = \"submit\">Submit</button>\n```\n\n<br>\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n```html\n<label><input type=\"radio\"> cat</label>\n<!-- 点击单词 \"cat\" 也将选择 radio 按钮。 -->\n```\n\n<br>\n\n`id`用于标识特定的HTML元素\n\n<br>\n\n`fieldset` 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n  - 块级元素，这意味着它们出现在新的一行上。\n  - `legend` 元素充当 fieldset 元素中内容的标题。\n```html\n<fieldset>\n        <legend> Is your cat an indoor or outdoor cat?</legend>\n          <label><input id=\"indoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"indoor\"> Indoor</label>\n          <label><input id=\"outdoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"outdoor\"> Outdoor</label>\n</fieldset>\n```\n![](/img/legend-2025-01-21-21-19-51.png)\n\n<br>\n\n还可以使用`for`属性将文本直接嵌套在`label`当中, 同时设置`input`的`id`与上述的`for`属性相同, 从而实现文本与元素相关联的效果:\n```html\n<input id=\"loving\" type=\"checkbox\"> \n<label for = \"loving\"> Loving </label>\n```\n\n<br>\n\n默认选中的按钮: `checked`\n```html\n<input checked type=\"radio\" name=\"meal\" value=\"breakfast\"> Breakfast\n```\n> checked属性无需额外赋值.\n\n<br>\n\n`footer`素用于定义文档或章节的页脚:\n- 脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n<br>\n\nhead 相关\n- 存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\n- `title `元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n- `<link rel = \"stylesheet\" href = \"styles.css\">` 将CSS文件链接到当前的HTML\n\nelse:\n- `<!DOCTYPE html`: 声明满足最新版本html相关设置的要求;\n- `meta`是空元素; `<meta charset = \"utf-8\">`;\n- \n\n\n---\n\n选择器:\n- **id**选择器\n```css\n#cat {\n  width: 250px;\n}\n```\n- **class**选择器\n```css\n.class-name, .other-class {\n  styles\n}\n```\n- class类中元素的选择\n```css\n.item p{\n  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */\n  display: inline-block; \n}\n```\n- **伪元素**\n```css\n/* 已访问链接后设置为灰色 */\na:visited{\n  color: grey;\n}\n\n/* 悬浮时的变色 */\na:hover {\n  color: brown;\n}\n\n/* 点击时的状态设置 */\na:active{\n  color: white;\n}\n```\n<br>\n\n```css\n  margin-left : auto;\n  margin-right: auto;\n```\n> 使得**普通**元素在父级元素的空间内 **水平居中**\n\n\n<br>\n\n`article`是一个语义化标签:\n- 用于表示文档、页面或应用中的**独立**的、完整的内容单元;\n- 清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n- 内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n- `div`: 粹的容器，没有语义，常用于布局;\n- `section`: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\n- `article`: 示一个可以独立存在的内容单元.\n\n<br>\n\n```css\n/* 设置备用字体 */\nh1, h2 {\n  font-family: Impact, serif;\n}\n```\n\n\n","source":"_posts/前后端/响应式设计.md","raw":"---\ntitle: 响应式设计\ndate: 2025-01-20 21:38:45\ntags: \n- 杂记\nexcerpt: 通过在freecodeCamp上的入门项目“响应式设计”来复习html等基础知识.\nindex_img: \ncategories: 学习笔记\nmath: true\n---\n\n所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n- 第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n- 另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n<br>\n\n注意嵌套的形式.\ne.g\n```html\n <p>See more <a href=\"https://freecatphotoapp.com\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n```html\n<p>See more <a href=\"https://freecatphotoapp.com\" target = \"_blank\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n锚元素除了能将文本转化为链接, 还可以将 **图片** 转换为链接:\n```html\n<a hreg = \"https://freecatphotoapp.com\">\n    <img src=\"https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg\" alt=\"A cute orange cat lying on its back.\">\n</a>\n```\n\n<br>\n\n\n**section** 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n<br>\n\n\n列表:\n- 无序列表: `ul`;\n- 有序列表:`ol`;\n- 列表项: `li`;\n\n<br>\n\n\n**figure** 元素代表自包含的内容，允许将图像与标题相关联;\n**figcaption** 元素用于添加标题以描述 figure 元素中包含的图像。\n```html\n<figure>\n  <img src=\"image.jpg\" alt=\"A description of the image\">\n  <figcaption>A cute cat</figcaption>\n</figure>\n```\n\n<br>\n\n\n- 使用 **em** 使得文字为斜体;\n- `strong` 加深文字;\n\n<br>\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n- `action`属性指定表单数据发送的位置;\n``` html\n<form action=\"/submit-url\"></form>\n```\n\n---\ninput 允许通过多种方式从Web表单中收集数据:\n- 与`img`一样为空元素——不需要结束标签;\n- 使用 `type` 属性创建多种输入;\n  - `text` : 文本;\n  - `radio`: 可以使用单选按钮;\n  - `checkbox`: 表单使用 **复选框**;\n- 使用`name`属性使得区分提交的数据;\n  - 令多个单选按钮具有 **相同** 的`name`, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n  - 形成`name = value`形式的属性对进行提交;\n```html\n<label><input id=\"indoor\" type=\"radio\" name = \"indoor-outdoor\"> Indoor</label>\n<label><input id=\"outdoor\" type=\"radio\" name = 'indoor-outdoor'> Outdoor</label>\n```\n- `placeholder` 中为 **占位符** 文本, 用于提示输入框中输入的信息;\n- `required`属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n```html\n    <input type=\"text\" name = \"catphotourl\">\n```\n\n<br>\n\n\n`button` 用于创建可点击的按钮:\n- 单击**没有任何属性**的表单按钮的默认行为会将表单提交到**表单**的 `action `属性中指定的位置;\n- 由于`input`和`button`为 **内联** 元素, 即使相隔书写也会显示在同行:\n- `type`的`submit`明确了为 可提交按钮;\n```html\n<button type = \"submit\">Submit</button>\n```\n\n<br>\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n```html\n<label><input type=\"radio\"> cat</label>\n<!-- 点击单词 \"cat\" 也将选择 radio 按钮。 -->\n```\n\n<br>\n\n`id`用于标识特定的HTML元素\n\n<br>\n\n`fieldset` 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n  - 块级元素，这意味着它们出现在新的一行上。\n  - `legend` 元素充当 fieldset 元素中内容的标题。\n```html\n<fieldset>\n        <legend> Is your cat an indoor or outdoor cat?</legend>\n          <label><input id=\"indoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"indoor\"> Indoor</label>\n          <label><input id=\"outdoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"outdoor\"> Outdoor</label>\n</fieldset>\n```\n![](/img/legend-2025-01-21-21-19-51.png)\n\n<br>\n\n还可以使用`for`属性将文本直接嵌套在`label`当中, 同时设置`input`的`id`与上述的`for`属性相同, 从而实现文本与元素相关联的效果:\n```html\n<input id=\"loving\" type=\"checkbox\"> \n<label for = \"loving\"> Loving </label>\n```\n\n<br>\n\n默认选中的按钮: `checked`\n```html\n<input checked type=\"radio\" name=\"meal\" value=\"breakfast\"> Breakfast\n```\n> checked属性无需额外赋值.\n\n<br>\n\n`footer`素用于定义文档或章节的页脚:\n- 脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n<br>\n\nhead 相关\n- 存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\n- `title `元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n- `<link rel = \"stylesheet\" href = \"styles.css\">` 将CSS文件链接到当前的HTML\n\nelse:\n- `<!DOCTYPE html`: 声明满足最新版本html相关设置的要求;\n- `meta`是空元素; `<meta charset = \"utf-8\">`;\n- \n\n\n---\n\n选择器:\n- **id**选择器\n```css\n#cat {\n  width: 250px;\n}\n```\n- **class**选择器\n```css\n.class-name, .other-class {\n  styles\n}\n```\n- class类中元素的选择\n```css\n.item p{\n  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */\n  display: inline-block; \n}\n```\n- **伪元素**\n```css\n/* 已访问链接后设置为灰色 */\na:visited{\n  color: grey;\n}\n\n/* 悬浮时的变色 */\na:hover {\n  color: brown;\n}\n\n/* 点击时的状态设置 */\na:active{\n  color: white;\n}\n```\n<br>\n\n```css\n  margin-left : auto;\n  margin-right: auto;\n```\n> 使得**普通**元素在父级元素的空间内 **水平居中**\n\n\n<br>\n\n`article`是一个语义化标签:\n- 用于表示文档、页面或应用中的**独立**的、完整的内容单元;\n- 清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n- 内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n- `div`: 粹的容器，没有语义，常用于布局;\n- `section`: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\n- `article`: 示一个可以独立存在的内容单元.\n\n<br>\n\n```css\n/* 设置备用字体 */\nh1, h2 {\n  font-family: Impact, serif;\n}\n```\n\n\n","slug":"前后端/响应式设计","published":1,"updated":"2025-02-07T07:47:51.269Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vw000ldwqge2t80pjh","content":"<p>所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:</p>\n<ul>\n<li>第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；</li>\n<li>另一个作用是当图片无法加载时，页面需要显示的替代文本。</li>\n</ul>\n<p><br></p>\n<p>注意嵌套的形式.<br>e.g<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>See more <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span>cat photos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span> in our gallery.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>See more <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span> <span class=\"hljs-attr\">target</span> = <span class=\"hljs-string\">&quot;_blank&quot;</span>&gt;</span>cat photos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span> in our gallery.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>锚元素除了能将文本转化为链接, 还可以将 <strong>图片</strong> 转换为链接:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">hreg</span> = <span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;A cute orange cat lying on its back.&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>section</strong> 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。</p>\n<p><br></p>\n<p>列表:</p>\n<ul>\n<li>无序列表: <code>ul</code>;</li>\n<li>有序列表:<code>ol</code>;</li>\n<li>列表项: <code>li</code>;</li>\n</ul>\n<p><br></p>\n<p><strong>figure</strong> 元素代表自包含的内容，允许将图像与标题相关联;<br><strong>figcaption</strong> 元素用于添加标题以描述 figure 元素中包含的图像。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figure</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;A description of the image&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figcaption</span>&gt;</span>A cute cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figcaption</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figure</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<ul>\n<li>使用 <strong>em</strong> 使得文字为斜体;</li>\n<li><code>strong</code> 加深文字;</li>\n</ul>\n<p><br></p>\n<p>form 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。</p>\n<ul>\n<li><code>action</code>属性指定表单数据发送的位置;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/submit-url&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>input 允许通过多种方式从Web表单中收集数据:</p>\n<ul>\n<li>与<code>img</code>一样为空元素——不需要结束标签;</li>\n<li>使用 <code>type</code> 属性创建多种输入;<ul>\n<li><code>text</code> : 文本;</li>\n<li><code>radio</code>: 可以使用单选按钮;</li>\n<li><code>checkbox</code>: 表单使用 <strong>复选框</strong>;</li>\n</ul>\n</li>\n<li>使用<code>name</code>属性使得区分提交的数据;<ul>\n<li>令多个单选按钮具有 <strong>相同</strong> 的<code>name</code>, 使得在选中其中一个按钮时自动取消另外的单选按钮;</li>\n<li>形成<code>name = value</code>形式的属性对进行提交;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span>&gt;</span> Indoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&#x27;indoor-outdoor&#x27;</span>&gt;</span> Outdoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><code>placeholder</code> 中为 <strong>占位符</strong> 文本, 用于提示输入框中输入的信息;</li>\n<li><code>required</code>属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&quot;catphotourl&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><br></p>\n<p><code>button</code> 用于创建可点击的按钮:</p>\n<ul>\n<li>单击<strong>没有任何属性</strong>的表单按钮的默认行为会将表单提交到<strong>表单</strong>的 <code>action</code>属性中指定的位置;</li>\n<li>由于<code>input</code>和<code>button</code>为 <strong>内联</strong> 元素, 即使相隔书写也会显示在同行:</li>\n<li><code>type</code>的<code>submit</code>明确了为 可提交按钮;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span> = <span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<p>label 元素用于帮助将 input 元素的文本与 input 元素本身关联起来<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span>&gt;</span> cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-comment\">&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><code>id</code>用于标识特定的HTML元素</p>\n<p><br></p>\n<p><code>fieldset</code> 元素用于在 Web 表单中将相关的输入和标签组合在一起:</p>\n<ul>\n<li>块级元素，这意味着它们出现在新的一行上。</li>\n<li><code>legend</code> 元素充当 fieldset 元素中内容的标题。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span> Is your cat an indoor or outdoor cat?<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span>&gt;</span> Indoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span>&gt;</span> Outdoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<img src=\"/img/legend-2025-01-21-21-19-51.png\" alt=\"\"></li>\n</ul>\n<p><br></p>\n<p>还可以使用<code>for</code>属性将文本直接嵌套在<code>label</code>当中, 同时设置<code>input</code>的<code>id</code>与上述的<code>for</code>属性相同, 从而实现文本与元素相关联的效果:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;loving&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>&gt;</span> <br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span> = <span class=\"hljs-string\">&quot;loving&quot;</span>&gt;</span> Loving <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>默认选中的按钮: <code>checked</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">checked</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;meal&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;breakfast&quot;</span>&gt;</span> Breakfast<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>checked属性无需额外赋值.</p>\n</blockquote>\n<p><br></p>\n<p><code>footer</code>素用于定义文档或章节的页脚:</p>\n<ul>\n<li>脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.</li>\n</ul>\n<p><br></p>\n<p>head 相关</p>\n<ul>\n<li>存放 $\\underline{元数据}$ 不会实际显示在html中的数据;</li>\n<li><code>title</code>元素决定了浏览器在页面的标题栏或选项卡中显示的内容;</li>\n<li><code>&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt;</code> 将CSS文件链接到当前的HTML</li>\n</ul>\n<p>else:</p>\n<ul>\n<li><code>&lt;!DOCTYPE html</code>: 声明满足最新版本html相关设置的要求;</li>\n<li><code>meta</code>是空元素; <code>&lt;meta charset = &quot;utf-8&quot;&gt;</code>;</li>\n<li></li>\n</ul>\n<hr>\n<p>选择器:</p>\n<ul>\n<li><strong>id</strong>选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cat</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">250px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><strong>class</strong>选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.class-name</span>, <span class=\"hljs-selector-class\">.other-class</span> &#123;<br>  styles<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>class类中元素的选择<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.item</span> <span class=\"hljs-selector-tag\">p</span>&#123;<br>  <span class=\"hljs-comment\">/* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */</span><br>  <span class=\"hljs-attribute\">display</span>: inline-block; <br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><strong>伪元素</strong><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 已访问链接后设置为灰色 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:visited</span>&#123;<br>  <span class=\"hljs-attribute\">color</span>: grey;<br>&#125;<br><br><span class=\"hljs-comment\">/* 悬浮时的变色 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: brown;<br>&#125;<br><br><span class=\"hljs-comment\">/* 点击时的状态设置 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:active</span>&#123;<br>  <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<br></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">margin-left</span> : auto;<br><span class=\"hljs-attribute\">margin-right</span>: auto;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>使得<strong>普通</strong>元素在父级元素的空间内 <strong>水平居中</strong></p>\n</blockquote>\n<p><br></p>\n<p><code>article</code>是一个语义化标签:</p>\n<ul>\n<li>用于表示文档、页面或应用中的<strong>独立</strong>的、完整的内容单元;</li>\n<li>清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;</li>\n<li>内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.</li>\n</ul>\n<p>与其他类似标签的区别:</p>\n<ul>\n<li><code>div</code>: 粹的容器，没有语义，常用于布局;</li>\n<li><code>section</code>: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;</li>\n<li><code>article</code>: 示一个可以独立存在的内容单元.</li>\n</ul>\n<p><br></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 设置备用字体 */</span><br><span class=\"hljs-selector-tag\">h1</span>, <span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: Impact, serif;<br>&#125;<br></code></pre></td></tr></table></figure>\n","more":"<p>所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:</p>\n<ul>\n<li>第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；</li>\n<li>另一个作用是当图片无法加载时，页面需要显示的替代文本。</li>\n</ul>\n<p><br></p>\n<p>注意嵌套的形式.<br>e.g<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>See more <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span>cat photos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span> in our gallery.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>See more <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span> <span class=\"hljs-attr\">target</span> = <span class=\"hljs-string\">&quot;_blank&quot;</span>&gt;</span>cat photos<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span> in our gallery.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>锚元素除了能将文本转化为链接, 还可以将 <strong>图片</strong> 转换为链接:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">hreg</span> = <span class=\"hljs-string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;A cute orange cat lying on its back.&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>section</strong> 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。</p>\n<p><br></p>\n<p>列表:</p>\n<ul>\n<li>无序列表: <code>ul</code>;</li>\n<li>有序列表:<code>ol</code>;</li>\n<li>列表项: <code>li</code>;</li>\n</ul>\n<p><br></p>\n<p><strong>figure</strong> 元素代表自包含的内容，允许将图像与标题相关联;<br><strong>figcaption</strong> 元素用于添加标题以描述 figure 元素中包含的图像。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figure</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;A description of the image&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figcaption</span>&gt;</span>A cute cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figcaption</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figure</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<ul>\n<li>使用 <strong>em</strong> 使得文字为斜体;</li>\n<li><code>strong</code> 加深文字;</li>\n</ul>\n<p><br></p>\n<p>form 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。</p>\n<ul>\n<li><code>action</code>属性指定表单数据发送的位置;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/submit-url&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>input 允许通过多种方式从Web表单中收集数据:</p>\n<ul>\n<li>与<code>img</code>一样为空元素——不需要结束标签;</li>\n<li>使用 <code>type</code> 属性创建多种输入;<ul>\n<li><code>text</code> : 文本;</li>\n<li><code>radio</code>: 可以使用单选按钮;</li>\n<li><code>checkbox</code>: 表单使用 <strong>复选框</strong>;</li>\n</ul>\n</li>\n<li>使用<code>name</code>属性使得区分提交的数据;<ul>\n<li>令多个单选按钮具有 <strong>相同</strong> 的<code>name</code>, 使得在选中其中一个按钮时自动取消另外的单选按钮;</li>\n<li>形成<code>name = value</code>形式的属性对进行提交;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span>&gt;</span> Indoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&#x27;indoor-outdoor&#x27;</span>&gt;</span> Outdoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><code>placeholder</code> 中为 <strong>占位符</strong> 文本, 用于提示输入框中输入的信息;</li>\n<li><code>required</code>属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">name</span> = <span class=\"hljs-string\">&quot;catphotourl&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><br></p>\n<p><code>button</code> 用于创建可点击的按钮:</p>\n<ul>\n<li>单击<strong>没有任何属性</strong>的表单按钮的默认行为会将表单提交到<strong>表单</strong>的 <code>action</code>属性中指定的位置;</li>\n<li>由于<code>input</code>和<code>button</code>为 <strong>内联</strong> 元素, 即使相隔书写也会显示在同行:</li>\n<li><code>type</code>的<code>submit</code>明确了为 可提交按钮;<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span> = <span class=\"hljs-string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<p>label 元素用于帮助将 input 元素的文本与 input 元素本身关联起来<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span>&gt;</span> cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-comment\">&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><code>id</code>用于标识特定的HTML元素</p>\n<p><br></p>\n<p><code>fieldset</code> 元素用于在 Web 表单中将相关的输入和标签组合在一起:</p>\n<ul>\n<li>块级元素，这意味着它们出现在新的一行上。</li>\n<li><code>legend</code> 元素充当 fieldset 元素中内容的标题。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">fieldset</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">legend</span>&gt;</span> Is your cat an indoor or outdoor cat?<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">legend</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;indoor&quot;</span>&gt;</span> Indoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;indoor-outdoor&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;outdoor&quot;</span>&gt;</span> Outdoor<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">fieldset</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<img src=\"/img/legend-2025-01-21-21-19-51.png\" alt=\"\"></li>\n</ul>\n<p><br></p>\n<p>还可以使用<code>for</code>属性将文本直接嵌套在<code>label</code>当中, 同时设置<code>input</code>的<code>id</code>与上述的<code>for</code>属性相同, 从而实现文本与元素相关联的效果:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;loving&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>&gt;</span> <br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span> = <span class=\"hljs-string\">&quot;loving&quot;</span>&gt;</span> Loving <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>默认选中的按钮: <code>checked</code><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">checked</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;meal&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;breakfast&quot;</span>&gt;</span> Breakfast<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>checked属性无需额外赋值.</p>\n</blockquote>\n<p><br></p>\n<p><code>footer</code>素用于定义文档或章节的页脚:</p>\n<ul>\n<li>脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.</li>\n</ul>\n<p><br></p>\n<p>head 相关</p>\n<ul>\n<li>存放 $\\underline{元数据}$ 不会实际显示在html中的数据;</li>\n<li><code>title</code>元素决定了浏览器在页面的标题栏或选项卡中显示的内容;</li>\n<li><code>&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt;</code> 将CSS文件链接到当前的HTML</li>\n</ul>\n<p>else:</p>\n<ul>\n<li><code>&lt;!DOCTYPE html</code>: 声明满足最新版本html相关设置的要求;</li>\n<li><code>meta</code>是空元素; <code>&lt;meta charset = &quot;utf-8&quot;&gt;</code>;</li>\n<li></li>\n</ul>\n<hr>\n<p>选择器:</p>\n<ul>\n<li><strong>id</strong>选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-id\">#cat</span> &#123;<br>  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">250px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><strong>class</strong>选择器<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.class-name</span>, <span class=\"hljs-selector-class\">.other-class</span> &#123;<br>  styles<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>class类中元素的选择<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.item</span> <span class=\"hljs-selector-tag\">p</span>&#123;<br>  <span class=\"hljs-comment\">/* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */</span><br>  <span class=\"hljs-attribute\">display</span>: inline-block; <br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><strong>伪元素</strong><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 已访问链接后设置为灰色 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:visited</span>&#123;<br>  <span class=\"hljs-attribute\">color</span>: grey;<br>&#125;<br><br><span class=\"hljs-comment\">/* 悬浮时的变色 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: brown;<br>&#125;<br><br><span class=\"hljs-comment\">/* 点击时的状态设置 */</span><br><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:active</span>&#123;<br>  <span class=\"hljs-attribute\">color</span>: white;<br>&#125;<br></code></pre></td></tr></table></figure>\n<br></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">margin-left</span> : auto;<br><span class=\"hljs-attribute\">margin-right</span>: auto;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>使得<strong>普通</strong>元素在父级元素的空间内 <strong>水平居中</strong></p>\n</blockquote>\n<p><br></p>\n<p><code>article</code>是一个语义化标签:</p>\n<ul>\n<li>用于表示文档、页面或应用中的<strong>独立</strong>的、完整的内容单元;</li>\n<li>清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;</li>\n<li>内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.</li>\n</ul>\n<p>与其他类似标签的区别:</p>\n<ul>\n<li><code>div</code>: 粹的容器，没有语义，常用于布局;</li>\n<li><code>section</code>: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;</li>\n<li><code>article</code>: 示一个可以独立存在的内容单元.</li>\n</ul>\n<p><br></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 设置备用字体 */</span><br><span class=\"hljs-selector-tag\">h1</span>, <span class=\"hljs-selector-tag\">h2</span> &#123;<br>  <span class=\"hljs-attribute\">font-family</span>: Impact, serif;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"SSH隧道","date":"2025-01-17T05:53:33.000Z","excerpt":"让服务器能够共享本地代理, 在服务器自身没有设置代理的情况下是一个简便可行的好方法.","index_img":"/img/照镜子.jpg","_content":" \n# 通过 SSH 隧道实现远程服务器使用本地代理\n\n在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。\n\n## 背景\n\n通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。\n\n## 原理解释\n\nSSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。\n\n```\n[远程服务器] <--- SSH隧道 ---> [本地电脑] <--- 代理 ---> [互联网]\n```\n\n## 具体步骤\n\n### 1. 前提条件\n- 本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）\n- 能够通过 SSH 连接到远程服务器\n- 确保本地代理软件正常工作\n\n### 2. 建立 SSH 隧道\n在本地电脑的终端中执行：\n\n```bash\nssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP\n```\n\n参数说明：\n- `-R 7890:127.0.0.1:7890`：将远程服务器的 7890 端口转发到本地的 7890 端口\n- `-o ServerAliveInterval=60`：每 60 秒发送一次心跳包\n- `-o ServerAliveCountMax=3`：最多允许丢失 3 次心跳包\n\n<br>\n\n然后根据提示输入服务器用户的密码:\n![](/img/2025-01-18-11-45-41.png)\n### 3. 配置服务器代理\n在服务器终端中执行：\n\n```bash\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n```\n\n### 4. 验证代理是否生效\n在服务器上执行：\n\n```bash\ncurl -v https://github.com\n```\n\n如果能够正常访问，说明代理配置成功。\n\n## 持久化配置\n\n如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：\n\n```bash\n# 编辑 ~/.bashrc 或 ~/.zshrc\necho 'export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890' >> ~/.bashrc\n\n# 重新加载配置\nsource ~/.bashrc\n```\n\n## 注意事项\n\n1. **安全性考虑**：SSH 隧道是加密的，相对安全\n2. **连接维护**：保持 SSH 连接不断开，否则代理会失效\n3. **带宽限制**：代理流量会经过你的本地电脑，注意带宽占用\n4. **临时使用**：这种方法适合临时使用，长期使用建议直接在服务器上配置代理\n\n## 常见问题排查\n\n1. **隧道无法建立**\n   - 检查本地代理是否正常运行\n   - 确认端口号是否正确\n   - 检查服务器防火墙设置\n\n2. **代理失效**\n   - SSH 连接是否断开\n   - 本地代理软件是否正常运行\n   - 环境变量是否正确设置\n\n### Clash设置\n在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:\n以mac的ClashX Pro为例, 在`更多设置`中\n![](/img/2025-01-17-14-00-36.png)\n\n## 结论\n\n通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。\n","source":"_posts/其他/SSH隧道.md","raw":"---\ntitle: SSH隧道\ndate: 2025-01-17 13:53:33\ntags:\n- ssh\n- 服务器\ncategories: 通用技能\nexcerpt: 让服务器能够共享本地代理, 在服务器自身没有设置代理的情况下是一个简便可行的好方法.\nindex_img: /img/照镜子.jpg\n--- \n# 通过 SSH 隧道实现远程服务器使用本地代理\n\n在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。\n\n## 背景\n\n通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。\n\n## 原理解释\n\nSSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。\n\n```\n[远程服务器] <--- SSH隧道 ---> [本地电脑] <--- 代理 ---> [互联网]\n```\n\n## 具体步骤\n\n### 1. 前提条件\n- 本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）\n- 能够通过 SSH 连接到远程服务器\n- 确保本地代理软件正常工作\n\n### 2. 建立 SSH 隧道\n在本地电脑的终端中执行：\n\n```bash\nssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP\n```\n\n参数说明：\n- `-R 7890:127.0.0.1:7890`：将远程服务器的 7890 端口转发到本地的 7890 端口\n- `-o ServerAliveInterval=60`：每 60 秒发送一次心跳包\n- `-o ServerAliveCountMax=3`：最多允许丢失 3 次心跳包\n\n<br>\n\n然后根据提示输入服务器用户的密码:\n![](/img/2025-01-18-11-45-41.png)\n### 3. 配置服务器代理\n在服务器终端中执行：\n\n```bash\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n```\n\n### 4. 验证代理是否生效\n在服务器上执行：\n\n```bash\ncurl -v https://github.com\n```\n\n如果能够正常访问，说明代理配置成功。\n\n## 持久化配置\n\n如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：\n\n```bash\n# 编辑 ~/.bashrc 或 ~/.zshrc\necho 'export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890' >> ~/.bashrc\n\n# 重新加载配置\nsource ~/.bashrc\n```\n\n## 注意事项\n\n1. **安全性考虑**：SSH 隧道是加密的，相对安全\n2. **连接维护**：保持 SSH 连接不断开，否则代理会失效\n3. **带宽限制**：代理流量会经过你的本地电脑，注意带宽占用\n4. **临时使用**：这种方法适合临时使用，长期使用建议直接在服务器上配置代理\n\n## 常见问题排查\n\n1. **隧道无法建立**\n   - 检查本地代理是否正常运行\n   - 确认端口号是否正确\n   - 检查服务器防火墙设置\n\n2. **代理失效**\n   - SSH 连接是否断开\n   - 本地代理软件是否正常运行\n   - 环境变量是否正确设置\n\n### Clash设置\n在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:\n以mac的ClashX Pro为例, 在`更多设置`中\n![](/img/2025-01-17-14-00-36.png)\n\n## 结论\n\n通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。\n","slug":"其他/SSH隧道","published":1,"updated":"2025-01-19T11:46:34.124Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vx000pdwqg9m389gpi","content":"<h1 id=\"通过-SSH-隧道实现远程服务器使用本地代理\"><a href=\"#通过-SSH-隧道实现远程服务器使用本地代理\" class=\"headerlink\" title=\"通过 SSH 隧道实现远程服务器使用本地代理\"></a>通过 SSH 隧道实现远程服务器使用本地代理</h1><p>在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。</p>\n<h2 id=\"原理解释\"><a href=\"#原理解释\" class=\"headerlink\" title=\"原理解释\"></a>原理解释</h2><p>SSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-title\">[</span><span class=\"hljs-comment\">远程服务器</span><span class=\"hljs-title\">]</span> &lt;<span class=\"hljs-literal\">---</span> <span class=\"hljs-comment\">SSH隧道</span> <span class=\"hljs-literal\">---</span>&gt; <span class=\"hljs-title\">[</span><span class=\"hljs-comment\">本地电脑</span><span class=\"hljs-title\">]</span> &lt;<span class=\"hljs-literal\">---</span> <span class=\"hljs-comment\">代理</span> <span class=\"hljs-literal\">---</span>&gt; <span class=\"hljs-title\">[</span><span class=\"hljs-comment\">互联网</span><span class=\"hljs-title\">]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1. 前提条件\"></a>1. 前提条件</h3><ul>\n<li>本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）</li>\n<li>能够通过 SSH 连接到远程服务器</li>\n<li>确保本地代理软件正常工作</li>\n</ul>\n<h3 id=\"2-建立-SSH-隧道\"><a href=\"#2-建立-SSH-隧道\" class=\"headerlink\" title=\"2. 建立 SSH 隧道\"></a>2. 建立 SSH 隧道</h3><p>在本地电脑的终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP<br></code></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><code>-R 7890:127.0.0.1:7890</code>：将远程服务器的 7890 端口转发到本地的 7890 端口</li>\n<li><code>-o ServerAliveInterval=60</code>：每 60 秒发送一次心跳包</li>\n<li><code>-o ServerAliveCountMax=3</code>：最多允许丢失 3 次心跳包</li>\n</ul>\n<p><br></p>\n<p>然后根据提示输入服务器用户的密码:<br><img src=\"/img/2025-01-18-11-45-41.png\" alt=\"\"></p>\n<h3 id=\"3-配置服务器代理\"><a href=\"#3-配置服务器代理\" class=\"headerlink\" title=\"3. 配置服务器代理\"></a>3. 配置服务器代理</h3><p>在服务器终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-验证代理是否生效\"><a href=\"#4-验证代理是否生效\" class=\"headerlink\" title=\"4. 验证代理是否生效\"></a>4. 验证代理是否生效</h3><p>在服务器上执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -v https://github.com<br></code></pre></td></tr></table></figure>\n<p>如果能够正常访问，说明代理配置成功。</p>\n<h2 id=\"持久化配置\"><a href=\"#持久化配置\" class=\"headerlink\" title=\"持久化配置\"></a>持久化配置</h2><p>如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 编辑 ~/.bashrc 或 ~/.zshrc</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890&#x27;</span> &gt;&gt; ~/.bashrc<br><br><span class=\"hljs-comment\"># 重新加载配置</span><br><span class=\"hljs-built_in\">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><strong>安全性考虑</strong>：SSH 隧道是加密的，相对安全</li>\n<li><strong>连接维护</strong>：保持 SSH 连接不断开，否则代理会失效</li>\n<li><strong>带宽限制</strong>：代理流量会经过你的本地电脑，注意带宽占用</li>\n<li><strong>临时使用</strong>：这种方法适合临时使用，长期使用建议直接在服务器上配置代理</li>\n</ol>\n<h2 id=\"常见问题排查\"><a href=\"#常见问题排查\" class=\"headerlink\" title=\"常见问题排查\"></a>常见问题排查</h2><ol>\n<li><p><strong>隧道无法建立</strong></p>\n<ul>\n<li>检查本地代理是否正常运行</li>\n<li>确认端口号是否正确</li>\n<li>检查服务器防火墙设置</li>\n</ul>\n</li>\n<li><p><strong>代理失效</strong></p>\n<ul>\n<li>SSH 连接是否断开</li>\n<li>本地代理软件是否正常运行</li>\n<li>环境变量是否正确设置</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Clash设置\"><a href=\"#Clash设置\" class=\"headerlink\" title=\"Clash设置\"></a>Clash设置</h3><p>在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:<br>以mac的ClashX Pro为例, 在<code>更多设置</code>中<br><img src=\"/img/2025-01-17-14-00-36.png\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。</p>\n","more":"<h1 id=\"通过-SSH-隧道实现远程服务器使用本地代理\"><a href=\"#通过-SSH-隧道实现远程服务器使用本地代理\" class=\"headerlink\" title=\"通过 SSH 隧道实现远程服务器使用本地代理\"></a>通过 SSH 隧道实现远程服务器使用本地代理</h1><p>在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。</p>\n<h2 id=\"原理解释\"><a href=\"#原理解释\" class=\"headerlink\" title=\"原理解释\"></a>原理解释</h2><p>SSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。</p>\n<figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs brainfuck\"><span class=\"hljs-title\">[</span><span class=\"hljs-comment\">远程服务器</span><span class=\"hljs-title\">]</span> &lt;<span class=\"hljs-literal\">---</span> <span class=\"hljs-comment\">SSH隧道</span> <span class=\"hljs-literal\">---</span>&gt; <span class=\"hljs-title\">[</span><span class=\"hljs-comment\">本地电脑</span><span class=\"hljs-title\">]</span> &lt;<span class=\"hljs-literal\">---</span> <span class=\"hljs-comment\">代理</span> <span class=\"hljs-literal\">---</span>&gt; <span class=\"hljs-title\">[</span><span class=\"hljs-comment\">互联网</span><span class=\"hljs-title\">]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h2><h3 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1. 前提条件\"></a>1. 前提条件</h3><ul>\n<li>本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）</li>\n<li>能够通过 SSH 连接到远程服务器</li>\n<li>确保本地代理软件正常工作</li>\n</ul>\n<h3 id=\"2-建立-SSH-隧道\"><a href=\"#2-建立-SSH-隧道\" class=\"headerlink\" title=\"2. 建立 SSH 隧道\"></a>2. 建立 SSH 隧道</h3><p>在本地电脑的终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP<br></code></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><code>-R 7890:127.0.0.1:7890</code>：将远程服务器的 7890 端口转发到本地的 7890 端口</li>\n<li><code>-o ServerAliveInterval=60</code>：每 60 秒发送一次心跳包</li>\n<li><code>-o ServerAliveCountMax=3</code>：最多允许丢失 3 次心跳包</li>\n</ul>\n<p><br></p>\n<p>然后根据提示输入服务器用户的密码:<br><img src=\"/img/2025-01-18-11-45-41.png\" alt=\"\"></p>\n<h3 id=\"3-配置服务器代理\"><a href=\"#3-配置服务器代理\" class=\"headerlink\" title=\"3. 配置服务器代理\"></a>3. 配置服务器代理</h3><p>在服务器终端中执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-验证代理是否生效\"><a href=\"#4-验证代理是否生效\" class=\"headerlink\" title=\"4. 验证代理是否生效\"></a>4. 验证代理是否生效</h3><p>在服务器上执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">curl -v https://github.com<br></code></pre></td></tr></table></figure>\n<p>如果能够正常访问，说明代理配置成功。</p>\n<h2 id=\"持久化配置\"><a href=\"#持久化配置\" class=\"headerlink\" title=\"持久化配置\"></a>持久化配置</h2><p>如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 编辑 ~/.bashrc 或 ~/.zshrc</span><br><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890&#x27;</span> &gt;&gt; ~/.bashrc<br><br><span class=\"hljs-comment\"># 重新加载配置</span><br><span class=\"hljs-built_in\">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><strong>安全性考虑</strong>：SSH 隧道是加密的，相对安全</li>\n<li><strong>连接维护</strong>：保持 SSH 连接不断开，否则代理会失效</li>\n<li><strong>带宽限制</strong>：代理流量会经过你的本地电脑，注意带宽占用</li>\n<li><strong>临时使用</strong>：这种方法适合临时使用，长期使用建议直接在服务器上配置代理</li>\n</ol>\n<h2 id=\"常见问题排查\"><a href=\"#常见问题排查\" class=\"headerlink\" title=\"常见问题排查\"></a>常见问题排查</h2><ol>\n<li><p><strong>隧道无法建立</strong></p>\n<ul>\n<li>检查本地代理是否正常运行</li>\n<li>确认端口号是否正确</li>\n<li>检查服务器防火墙设置</li>\n</ul>\n</li>\n<li><p><strong>代理失效</strong></p>\n<ul>\n<li>SSH 连接是否断开</li>\n<li>本地代理软件是否正常运行</li>\n<li>环境变量是否正确设置</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Clash设置\"><a href=\"#Clash设置\" class=\"headerlink\" title=\"Clash设置\"></a>Clash设置</h3><p>在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:<br>以mac的ClashX Pro为例, 在<code>更多设置</code>中<br><img src=\"/img/2025-01-17-14-00-36.png\" alt=\"\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。</p>\n"},{"title":"跨组件渲染","date":"2025-02-16T07:40:06.000Z","excerpt":"组件渲染","_content":"# React Context 实现跨组件实时渲染的实践分析\n\n## 为什么需要跨组件实时渲染？\n\n在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n- 用户在一个组件中编辑内容，其他组件需要立即看到更新\n- 多个组件需要共享同一份数据\n- 需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n\n## 最小实现示例\n\n以下是实现跨组件实时渲染的最简代码结构：\n\n```typescript\n// 1. 定义 Context 类型\ninterface SharedContextType {\n  data: any;\n  updateData: (newData: any) => void;\n}\n\n// 2. 创建 Context\nconst SharedContext = createContext<SharedContextType | undefined>(undefined);\n\n// 3. 创建 Provider 组件\nexport function SharedProvider({ children }: { children: React.ReactNode }) {\n  const [data, setData] = useState<any>(null);\n\n  const updateData = useCallback((newData: any) => {\n    setData(newData);\n  }, []);\n\n  return (\n    <SharedContext.Provider value={{ data, updateData }}>\n      {children}\n    </SharedContext.Provider>\n  );\n}\n\n// 4. 创建自定义 Hook\nexport function useShared() {\n  const context = useContext(SharedContext);\n  if (!context) {\n    throw new Error('useShared must be used within SharedProvider');\n  }\n  return context;\n}\n```\n\n## 实际应用分析\n\n让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n\n```typescript\n// 1. 定义具体的数据结构\ninterface HistoryItem {\n  id: string;\n  content: string;\n  mermaidCode: string;\n  timestamp: number;\n}\n\n// 2. 实现带有持久化的 Context Provider\nexport function HistoryProvider({ children }: { children: React.ReactNode }) {\n  const [selectedHistory, setSelectedHistory] = useState<HistoryItem | null>(null);\n  const [historyList, setHistoryList] = useState<HistoryItem[]>([]);\n\n  // 数据持久化\n  useEffect(() => {\n    if (selectedHistory) {\n      localStorage.setItem('selectedHistory', JSON.stringify(selectedHistory));\n    }\n  }, [selectedHistory]);\n\n  // 实时更新方法\n  const addHistory = async (content: string, mermaidCode: string) => {\n    const historyItem: HistoryItem = {\n      id: Date.now().toString(),\n      content,\n      mermaidCode,\n      timestamp: Date.now()\n    };\n    setHistoryList(prev => [historyItem, ...prev]);\n  };\n\n  return (\n    <HistoryContext.Provider\n      value={{\n        selectedHistory,\n        setSelectedHistory,\n        addHistory,\n        historyList\n      }}\n    >\n      {children}\n    </HistoryContext.Provider>\n  );\n}\n```\n\n在这个实际例子中，我们可以看到几个关键点：\n\n1. **状态定义**：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n2. **状态持久化**：通过 `useEffect` 监听状态变化并保存到 localStorage\n3. **实时更新**：通过 `setHistoryList` 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\n\n```typescript\nfunction HistoryViewer() {\n  const { selectedHistory } = useHistory();\n  \n  return (\n    <div>\n      {selectedHistory && (\n        <div>{selectedHistory.content}</div>\n      )}\n    </div>\n  );\n}\n```\n\n这种模式的优势在于：\n\n- 避免了 props 的层层传递\n- 实现了组件间的解耦\n- 确保了状态更新的实时性\n- 提供了类型安全的数据访问\n\n## 参考资料\n\n- [React Context Documentation](https://react.dev/reference/react/createContext)\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/)\n- [React Hooks API Reference](https://react.dev/reference/react/hooks)\n","source":"_posts/前后端/跨组件渲染.md","raw":"---\ntitle: 跨组件渲染\ndate: 2025-02-16 15:40:06\ntags:\ncategories:\nexcerpt: 组件渲染\n---\n# React Context 实现跨组件实时渲染的实践分析\n\n## 为什么需要跨组件实时渲染？\n\n在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n- 用户在一个组件中编辑内容，其他组件需要立即看到更新\n- 多个组件需要共享同一份数据\n- 需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n\n## 最小实现示例\n\n以下是实现跨组件实时渲染的最简代码结构：\n\n```typescript\n// 1. 定义 Context 类型\ninterface SharedContextType {\n  data: any;\n  updateData: (newData: any) => void;\n}\n\n// 2. 创建 Context\nconst SharedContext = createContext<SharedContextType | undefined>(undefined);\n\n// 3. 创建 Provider 组件\nexport function SharedProvider({ children }: { children: React.ReactNode }) {\n  const [data, setData] = useState<any>(null);\n\n  const updateData = useCallback((newData: any) => {\n    setData(newData);\n  }, []);\n\n  return (\n    <SharedContext.Provider value={{ data, updateData }}>\n      {children}\n    </SharedContext.Provider>\n  );\n}\n\n// 4. 创建自定义 Hook\nexport function useShared() {\n  const context = useContext(SharedContext);\n  if (!context) {\n    throw new Error('useShared must be used within SharedProvider');\n  }\n  return context;\n}\n```\n\n## 实际应用分析\n\n让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n\n```typescript\n// 1. 定义具体的数据结构\ninterface HistoryItem {\n  id: string;\n  content: string;\n  mermaidCode: string;\n  timestamp: number;\n}\n\n// 2. 实现带有持久化的 Context Provider\nexport function HistoryProvider({ children }: { children: React.ReactNode }) {\n  const [selectedHistory, setSelectedHistory] = useState<HistoryItem | null>(null);\n  const [historyList, setHistoryList] = useState<HistoryItem[]>([]);\n\n  // 数据持久化\n  useEffect(() => {\n    if (selectedHistory) {\n      localStorage.setItem('selectedHistory', JSON.stringify(selectedHistory));\n    }\n  }, [selectedHistory]);\n\n  // 实时更新方法\n  const addHistory = async (content: string, mermaidCode: string) => {\n    const historyItem: HistoryItem = {\n      id: Date.now().toString(),\n      content,\n      mermaidCode,\n      timestamp: Date.now()\n    };\n    setHistoryList(prev => [historyItem, ...prev]);\n  };\n\n  return (\n    <HistoryContext.Provider\n      value={{\n        selectedHistory,\n        setSelectedHistory,\n        addHistory,\n        historyList\n      }}\n    >\n      {children}\n    </HistoryContext.Provider>\n  );\n}\n```\n\n在这个实际例子中，我们可以看到几个关键点：\n\n1. **状态定义**：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n2. **状态持久化**：通过 `useEffect` 监听状态变化并保存到 localStorage\n3. **实时更新**：通过 `setHistoryList` 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\n\n```typescript\nfunction HistoryViewer() {\n  const { selectedHistory } = useHistory();\n  \n  return (\n    <div>\n      {selectedHistory && (\n        <div>{selectedHistory.content}</div>\n      )}\n    </div>\n  );\n}\n```\n\n这种模式的优势在于：\n\n- 避免了 props 的层层传递\n- 实现了组件间的解耦\n- 确保了状态更新的实时性\n- 提供了类型安全的数据访问\n\n## 参考资料\n\n- [React Context Documentation](https://react.dev/reference/react/createContext)\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/)\n- [React Hooks API Reference](https://react.dev/reference/react/hooks)\n","slug":"前后端/跨组件渲染","published":1,"updated":"2025-02-16T07:40:45.188Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vx000rdwqg3zofcc28","content":"<h1 id=\"React-Context-实现跨组件实时渲染的实践分析\"><a href=\"#React-Context-实现跨组件实时渲染的实践分析\" class=\"headerlink\" title=\"React Context 实现跨组件实时渲染的实践分析\"></a>React Context 实现跨组件实时渲染的实践分析</h1><h2 id=\"为什么需要跨组件实时渲染？\"><a href=\"#为什么需要跨组件实时渲染？\" class=\"headerlink\" title=\"为什么需要跨组件实时渲染？\"></a>为什么需要跨组件实时渲染？</h2><p>在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：</p>\n<ul>\n<li>用户在一个组件中编辑内容，其他组件需要立即看到更新</li>\n<li>多个组件需要共享同一份数据</li>\n<li>需要避免通过层层组件传递 props（即所谓的 prop drilling）</li>\n</ul>\n<p>这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。</p>\n<h2 id=\"最小实现示例\"><a href=\"#最小实现示例\" class=\"headerlink\" title=\"最小实现示例\"></a>最小实现示例</h2><p>以下是实现跨组件实时渲染的最简代码结构：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 1. 定义 Context 类型</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SharedContextType</span> &#123;<br>  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-built_in\">any</span>;<br>  <span class=\"hljs-attr\">updateData</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">newData</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 2. 创建 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">SharedContext</span> = createContext&lt;<span class=\"hljs-title class_\">SharedContextType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-comment\">// 3. 创建 Provider 组件</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SharedProvider</span>(<span class=\"hljs-params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [data, setData] = useState&lt;<span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-literal\">null</span>);<br><br>  <span class=\"hljs-keyword\">const</span> updateData = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">newData</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">setData</span>(newData);<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SharedContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">data</span>, <span class=\"hljs-attr\">updateData</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">SharedContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 4. 创建自定义 Hook</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useShared</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">SharedContext</span>);<br>  <span class=\"hljs-keyword\">if</span> (!context) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;useShared must be used within SharedProvider&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"实际应用分析\"><a href=\"#实际应用分析\" class=\"headerlink\" title=\"实际应用分析\"></a>实际应用分析</h2><p>让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 1. 定义具体的数据结构</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HistoryItem</span> &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">mermaidCode</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 2. 实现带有持久化的 Context Provider</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">HistoryProvider</span>(<span class=\"hljs-params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [selectedHistory, setSelectedHistory] = useState&lt;<span class=\"hljs-title class_\">HistoryItem</span> | <span class=\"hljs-literal\">null</span>&gt;(<span class=\"hljs-literal\">null</span>);<br>  <span class=\"hljs-keyword\">const</span> [historyList, setHistoryList] = useState&lt;<span class=\"hljs-title class_\">HistoryItem</span>[]&gt;([]);<br><br>  <span class=\"hljs-comment\">// 数据持久化</span><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (selectedHistory) &#123;<br>      <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-string\">&#x27;selectedHistory&#x27;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(selectedHistory));<br>    &#125;<br>  &#125;, [selectedHistory]);<br><br>  <span class=\"hljs-comment\">// 实时更新方法</span><br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">addHistory</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"><span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">mermaidCode</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">historyItem</span>: <span class=\"hljs-title class_\">HistoryItem</span> = &#123;<br>      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>().<span class=\"hljs-title function_\">toString</span>(),<br>      content,<br>      mermaidCode,<br>      <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>    &#125;;<br>    <span class=\"hljs-title function_\">setHistoryList</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prev</span> =&gt;</span> [historyItem, ...prev]);<br>  &#125;;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HistoryContext.Provider</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">selectedHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">setSelectedHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">addHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">historyList</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &#125;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">    &gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">HistoryContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在这个实际例子中，我们可以看到几个关键点：</p>\n<ol>\n<li><strong>状态定义</strong>：使用 TypeScript 接口明确定义了数据结构，确保类型安全</li>\n<li><strong>状态持久化</strong>：通过 <code>useEffect</code> 监听状态变化并保存到 localStorage</li>\n<li><strong>实时更新</strong>：通过 <code>setHistoryList</code> 确保状态更新后所有使用该 Context 的组件都能即时获得更新</li>\n</ol>\n<p>当组件需要使用这些共享状态时，只需：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">HistoryViewer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; selectedHistory &#125; = <span class=\"hljs-title function_\">useHistory</span>();<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;selectedHistory &amp;&amp; (</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;selectedHistory.content&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      )&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种模式的优势在于：</p>\n<ul>\n<li>避免了 props 的层层传递</li>\n<li>实现了组件间的解耦</li>\n<li>确保了状态更新的实时性</li>\n<li>提供了类型安全的数据访问</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://react.dev/reference/react/createContext\">React Context Documentation</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/\">TypeScript Handbook</a></li>\n<li><a href=\"https://react.dev/reference/react/hooks\">React Hooks API Reference</a></li>\n</ul>\n","more":"<h1 id=\"React-Context-实现跨组件实时渲染的实践分析\"><a href=\"#React-Context-实现跨组件实时渲染的实践分析\" class=\"headerlink\" title=\"React Context 实现跨组件实时渲染的实践分析\"></a>React Context 实现跨组件实时渲染的实践分析</h1><h2 id=\"为什么需要跨组件实时渲染？\"><a href=\"#为什么需要跨组件实时渲染？\" class=\"headerlink\" title=\"为什么需要跨组件实时渲染？\"></a>为什么需要跨组件实时渲染？</h2><p>在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：</p>\n<ul>\n<li>用户在一个组件中编辑内容，其他组件需要立即看到更新</li>\n<li>多个组件需要共享同一份数据</li>\n<li>需要避免通过层层组件传递 props（即所谓的 prop drilling）</li>\n</ul>\n<p>这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。</p>\n<h2 id=\"最小实现示例\"><a href=\"#最小实现示例\" class=\"headerlink\" title=\"最小实现示例\"></a>最小实现示例</h2><p>以下是实现跨组件实时渲染的最简代码结构：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 1. 定义 Context 类型</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SharedContextType</span> &#123;<br>  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-built_in\">any</span>;<br>  <span class=\"hljs-attr\">updateData</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">newData</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 2. 创建 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">SharedContext</span> = createContext&lt;<span class=\"hljs-title class_\">SharedContextType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-comment\">// 3. 创建 Provider 组件</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">SharedProvider</span>(<span class=\"hljs-params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [data, setData] = useState&lt;<span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-literal\">null</span>);<br><br>  <span class=\"hljs-keyword\">const</span> updateData = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-attr\">newData</span>: <span class=\"hljs-built_in\">any</span></span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">setData</span>(newData);<br>  &#125;, []);<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SharedContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">data</span>, <span class=\"hljs-attr\">updateData</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">SharedContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class=\"hljs-comment\">// 4. 创建自定义 Hook</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useShared</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">SharedContext</span>);<br>  <span class=\"hljs-keyword\">if</span> (!context) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;useShared must be used within SharedProvider&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"实际应用分析\"><a href=\"#实际应用分析\" class=\"headerlink\" title=\"实际应用分析\"></a>实际应用分析</h2><p>让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// 1. 定义具体的数据结构</span><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">HistoryItem</span> &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">mermaidCode</span>: <span class=\"hljs-built_in\">string</span>;<br>  <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-built_in\">number</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 2. 实现带有持久化的 Context Provider</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">HistoryProvider</span>(<span class=\"hljs-params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> [selectedHistory, setSelectedHistory] = useState&lt;<span class=\"hljs-title class_\">HistoryItem</span> | <span class=\"hljs-literal\">null</span>&gt;(<span class=\"hljs-literal\">null</span>);<br>  <span class=\"hljs-keyword\">const</span> [historyList, setHistoryList] = useState&lt;<span class=\"hljs-title class_\">HistoryItem</span>[]&gt;([]);<br><br>  <span class=\"hljs-comment\">// 数据持久化</span><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (selectedHistory) &#123;<br>      <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-string\">&#x27;selectedHistory&#x27;</span>, <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(selectedHistory));<br>    &#125;<br>  &#125;, [selectedHistory]);<br><br>  <span class=\"hljs-comment\">// 实时更新方法</span><br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">addHistory</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"><span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\">mermaidCode</span>: <span class=\"hljs-built_in\">string</span></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">historyItem</span>: <span class=\"hljs-title class_\">HistoryItem</span> = &#123;<br>      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>().<span class=\"hljs-title function_\">toString</span>(),<br>      content,<br>      mermaidCode,<br>      <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>    &#125;;<br>    <span class=\"hljs-title function_\">setHistoryList</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prev</span> =&gt;</span> [historyItem, ...prev]);<br>  &#125;;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">HistoryContext.Provider</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">selectedHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">setSelectedHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">addHistory</span>,</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">historyList</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &#125;&#125;</span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">    &gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">HistoryContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在这个实际例子中，我们可以看到几个关键点：</p>\n<ol>\n<li><strong>状态定义</strong>：使用 TypeScript 接口明确定义了数据结构，确保类型安全</li>\n<li><strong>状态持久化</strong>：通过 <code>useEffect</code> 监听状态变化并保存到 localStorage</li>\n<li><strong>实时更新</strong>：通过 <code>setHistoryList</code> 确保状态更新后所有使用该 Context 的组件都能即时获得更新</li>\n</ol>\n<p>当组件需要使用这些共享状态时，只需：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">HistoryViewer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; selectedHistory &#125; = <span class=\"hljs-title function_\">useHistory</span>();<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      &#123;selectedHistory &amp;&amp; (</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;selectedHistory.content&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">      )&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这种模式的优势在于：</p>\n<ul>\n<li>避免了 props 的层层传递</li>\n<li>实现了组件间的解耦</li>\n<li>确保了状态更新的实时性</li>\n<li>提供了类型安全的数据访问</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://react.dev/reference/react/createContext\">React Context Documentation</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/\">TypeScript Handbook</a></li>\n<li><a href=\"https://react.dev/reference/react/hooks\">React Hooks API Reference</a></li>\n</ul>\n"},{"title":"makefile","date":"2025-02-12T10:15:25.000Z","excerpt":"一起来学习makefile吧！","_content":"# 编译\n# 基本概念\n## 默认目标\n- `Makefile`当中的第一个目标会成为**默认目标**;\n- 不指定参数的`make`命令会执行默认目标;\n- 通常使用`all`的伪目标作为默认目标.\n\n## 伪目标\n当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 **伪目标**.\n\n**语法**\n```makefile\n.PHONY: 目标名\n目标名:\n    命令\n```\n\n**使用示例**\n```makefile\n# 情景：需要清理编译产生的 .o 文件和可执行文件\n.PHONY: clean\nclean:\n    rm -f *.o program\n\n# 情景：需要运行测试\n.PHONY: test\ntest:\n    ./run_tests.sh\n\n# 使用方法：\n# make clean  # 清理文件\n# make test   # 运行测试\n```\n> 其中`-f`表示强制删除, 其他的参数如`-r`表示递归删除目录, `-rf`表示强制递归删除目录.\n\n### 多重构建\n我们还可以利用伪目标使得默认目标具有多个对象:\n```makefile \n.PHONY: all debug release clean\n\n# 默认目标包含常用的构建类型\nall: debug release\n\n# 调试版本\ndebug: main.c\n    @echo \"构建调试版本...\"\n    gcc -g main.c -o debug-program\n\n# 发布版本\nrelease: main.c\n    @echo \"构建发布版本...\"\n    gcc -O2 main.c -o release-program\n\nclean:\n    rm -f debug-program release-program\n\n# 使用：\n# make          # 构建调试版和发布版\n# make debug    # 只构建调试版\n# make release  # 只构建发布版\n# make clean    # 清理\n```\n\n## 多目标\ne.g: \n```makefile\nbigoutput littleoutput : text.g\n    generate text.g -$(subst output,,$@) > $@\n```\n\n### 解析\n\n```makefile\nbigoutput littleoutput : text.g\n    generate text.g -$(subst output,,$@) > $@\n```\n\n1. `bigoutput littleoutput` - 两个目标文件\n2. `text.g` - 依赖文件\n3. `$(subst output,,$@)` -变量展开：\n   - `$@` 是自动变量，表示当前目标名\n   - `subst` 是替换函数，格式为 `$(subst from,to,text)`\n   - 此处将目标名中的 \"output\" 替换为空\n\n当规则执行时：\n- 对于 `bigoutput` 目标：\n  - `$@` 展开为 `bigoutput`\n  - `$(subst output,,$@)` 结果为 `big`\n  - 最终命令变为：`generate text.g -big > bigoutput`\n\n- 对于 `littleoutput` 目标：\n  - `$@` 展开为 `littleoutput`\n  - `$(subst output,,$@)` 结果为 `little`\n  - 最终命令变为：`generate text.g -little > littleoutput`\n\n<br>\n\n因此, 上述的多目标规则**等价**于:\n```makefile\nbigoutput : text.g\n    generate text.g -big > bigoutput\nlittleoutput : text.g\n    generate text.g -little > littleoutput\n```\n\n### 规则语法\n\n多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：\n\n1. **基本语法**：\n   ```makefile\n   target1 target2 : prerequisites\n       commands\n   ```\n\n2. **特点**：\n   - 多个目标共享相同的依赖关系\n   - 命令会对每个目标分别执行一次\n   - 可以使用 `$@` 引用当前正在构建的目标\n\n3. **使用场景**：\n   - 生成相似但略有不同的文件\n   - 多个目标需要类似的构建过程\n   - 减少重复代码\n\n4. **示例**：\n   ```makefile\n   # 生成不同大小的图片\n   big.jpg small.jpg : original.jpg\n       convert original.jpg -resize $* > $@\n\n   # 生成不同格式的文档\n   manual.pdf manual.html : manual.txt\n       pandoc manual.txt -o $@\n   ```\n\n5. **优势**：\n   - 代码更简洁\n   - 易于维护\n   - 避免重复规则\n   - 更好的规则组织\n\n6. **注意事项**：\n   - 命令对每个目标都会执行一次\n   - 需要合理使用自动变量（如 `$@`）来区分不同目标\n   - 确保命令对所有目标都适用\n\n## 静态模式\n好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。\n\n### 1. 引入背景\n\n在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：\n\n```makefile\nfoo.o : foo.c\n    $(CC) -c $(CFLAGS) foo.c -o foo.o\n\nbar.o : bar.c\n    $(CC) -c $(CFLAGS) bar.c -o bar.o\n\ntest.o : test.c\n    $(CC) -c $(CFLAGS) test.c -o test.o\n```\n\n这种写法存在明显问题：\n- 规则重复，维护困难\n- 当新增源文件时需要手动添加规则\n- 代码冗长，不够优雅\n\n虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。\n\n### 2. 基本语法\n\n静态模式规则的基本语法如下：\n```makefile\ntargets ...: target-pattern: prereq-pattern\n    commands\n```\n\n其中：\n- `targets`: 要生成的目标文件列表\n- `target-pattern`: 目标的模式，通常包含 `%` 通配符\n- `prereq-pattern`: 依赖的模式，通常也包含 `%` 通配符\n- `commands`: 构建命令\n\n`%` 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。\n\n### 3. 综合示例\n\n让我们通过几个逐渐复杂的例子来说明静态模式的使用：\n\n#### 基础示例：编译 C 文件\n```makefile\nobjects = foo.o bar.o test.o\n\n$(objects): %.o: %.c\n    $(CC) -c $(CFLAGS) $< -o $@\n```\n\n#### 复杂示例：多种源文件处理\n```makefile\n# 定义源文件和目标文件\ncpp_sources := $(wildcard *.cpp)\nc_sources := $(wildcard *.c)\ncpp_objects := $(cpp_sources:.cpp=.o)\nc_objects := $(c_sources:.c=.o)\nall_objects := $(cpp_objects) $(c_objects)\n\n# C++ 源文件的编译规则\n$(cpp_objects): %.o: %.cpp\n    $(CXX) -c $(CXXFLAGS) $< -o $@\n\n# C 源文件的编译规则\n$(c_objects): %.o: %.c\n    $(CC) -c $(CFLAGS) $< -o $@\n\n# 生成可执行文件\nprogram: $(all_objects)\n    $(CXX) $^ -o $@\n```\n- `$(cpp_sources:.cpp=.o)`是一种**模式替换**, 会将`cpp_sources`中的所有`.cpp`文件替换为`.o`文件;\n  - 即`$(varname:pattern1=pattern2)` 会将`varname`中的所有`pattern1`替换为`pattern2`;\n\n#### 更复杂的示例：多目录处理\n```makefile\n# 目录结构\nSRCDIR = src\nOBJDIR = obj\n\n# 源文件和目标文件\nSOURCES = $(wildcard $(SRCDIR)/*.c)\nOBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)\n\n# 确保目标目录存在\n$(OBJDIR):\n    mkdir -p $@\n\n# 静态模式规则\n$(OBJECTS): $(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)\n    $(CC) -c $(CFLAGS) $< -o $@\n\n# 最终目标\nprogram: $(OBJECTS)\n    $(CC) $^ -o $@\n```\n> todo\n\n这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在**文件组织**方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 `src` 和 `obj`）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。\n\n在**目录管理**方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 `|` 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。\n\n在**文件名处理**方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 `src/main.c` 转换为 `obj/main.o`，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。\n\n---\n\n## 基本规则\n```makefile\ntarget ... : prerequisites ...\n    recipe\n    ...\n    ...\n```\n`target`: 目标文件 | 可执行文件 | 标签;\n`prerequisites`: 依赖文件 | `target`;\n`recipe`: 对应`target`所需的命令(以`Tap`缩进开头).\n\n<br>\n\n执行`recipe`命令的条件:\n- `prerequisites`中存在文件的日期早于`target`的日期;\n- `target`的文件不存在.\n\n## 使用变量\n```makefile\n# 定义变量: 类似于C的宏定义\nobjects = main.o display.o\n\n# 使用变量\nedit: $(objects)\n    cc -o edit $(objects)\n```\n1. 必须使用`Tab`缩进;\n2. 采取`$(variable)`的形式引用变量, 将会展开为变量的值;\n3. `cc -o edit` 声明采用C语言编译器同时指定输出文件名为`edit`.\n\n## Make的自动推导\n### 自动推导规则\n1. **文件关联**：\n   - 当make看到`.o`文件时，会自动将对应的`.c`文件加入依赖关系\n   - 例如：发现`whatever.o`时，会自动关联`whatever.c`作为依赖文件\n\n2. **命令推导**：\n   - 自动推导编译命令，如`cc -c whatever.c`\n   - 无需在每个`.o`文件后都手动写编译命令\n\n### 示例结构\n\n- **依赖关系**：\n```makefile\n# 自动推导之前\nmain.o : main.c defs.h\n    cc -c main.c\n\n# 自动推导下的简化书写\nmain.o : defs.h\n```\n\n- **清理目标**：\n```makefile\n.PHONY : clean\nclean :\n    rm edit $(objects)\n```\n\n- `.PHONY`表示`clean`是伪目标文件;\n- 这种自动推导方式大大简化了Makefile的编写;\n- `clean`总是放在文件的末尾.\n\n\n\n`make`命令在默认情况下会在当前目录下**依次**寻找文件名为`GNUmakefile`,`makefile`,`Makefile`的文件.\n- 推荐使用`Makefile`作为文件名;\n- 也可以使用`-f`或者`-file`参数来指定特定的`Makefile`文件.\n```shell\nmake -f Make.Linux\n```\n\n\n\n\n## include命令\n```makefile\n# 使用include命令可以将其他Makefile包含进来\ninclude <file-name>\n```\n- `include`命令前可以存在空字符, 但是不能为`Tab`缩进;\n- `include`与文件之间可以存在多个空格.\n\n\n### 直接指定文件\n```makefile\n# 最基本的include用法是直接指定文件名\ninclude config.mk\ninclude ./build/rules.mk\n\n# 同时包含多个文件\ninclude config.mk rules.mk tests.mk\n```\n\n### 使用通配符 *\n```makefile\n# * 匹配任意字符串\ninclude *.mk              # 包含当前目录下所有.mk文件\ninclude src/*.mk         # 包含src目录下的所有.mk文件\ninclude **/build/*.mk    # 包含任意子目录中build目录下的所有.mk文件\n```\n\n我们同样可以在变量中使用通配符 `*`:\n```makefile\n# 使用时展开\nobjects = *.o\n\n# 定义时展开(除非重新赋值, 否则保持定义时的展开状态)\nobjects := $(wildcard *.o)\n```\n\ne.g:\n```makefile\n$(patsubst %.c,%.o,$(wildcard *.c))\n```\n- `patsubst`是一个函数, 用于模式替换;\n- 语法为`patsubst <pattern>,<replacement>,<text>`;\n- 此处表示利用通配符, 将所有的`.c`文件名称替换为`.o`文件.\n\n\n### 使用单字符通配符\n```makefile\n# ? 匹配单个字符\ninclude test?.mk         # 匹配test1.mk, testA.mk等\ninclude rule_?.mk        # 匹配rule_1.mk, rule_2.mk等\ninclude config???.mk     # 匹配config后带三个字符的.mk文件\n```\n\n### 使用目录路径\n```makefile\n# 可以指定不同的目录路径\ninclude ./configs/*.mk    # 当前目录下的configs子目录\ninclude ../shared/*.mk    # 上级目录的shared子目录\ninclude /usr/local/include/make/*.mk  # 绝对路径\n```\n\n### 使用字符集[]\n```makefile\n# [] 用于匹配字符集中的任意一个字符\ninclude make[123].mk     # 匹配make1.mk, make2.mk, make3.mk\ninclude test[a-z].mk     # 匹配testa.mk到testz.mk\ninclude config[0-9].mk   # 匹配config0.mk到config9.mk\n```\n\n### 错误处理\n```makefile\n# 默认情况下，如果include的文件不存在，make会报错\n\n# 使用-include或sinclude可以忽略文件不存在的错误\n-include optional.mk     # 如果文件不存在，继续执行不报错\nsinclude optional.mk     # 与-include完全相同\n\n# 多个可选文件\n-include config/*.mk     # 如果config目录下有任何.mk文件不存在，继续执行\n```\n\n### 组合使用示例\n```makefile\n# 可以组合使用多种模式\ninclude config.mk \\\n        rules/*.mk \\\n        test[0-9].mk \\\n        ./build/**/*.mk\n\n# 使用变量\nINCLUDE_DIR = ./includes\ninclude $(INCLUDE_DIR)/*.mk\n\n# 条件包含\nifdef CUSTOM_RULES\n    include $(CUSTOM_RULES)\nendif\n```\n\n## make的工作方式\n1. 读取所有的`Makefile`;\n2. 读取`include`涉及的`Makefile`文件;\n3. 初始化文件当中的**变量**;\n4. 推导**隐式规则**并分析所有规则;\n5. 为目标文件创建依赖关系链;\n6. 根据依赖关系, 决定需要重新生成的文件;\n7. 执行生成命令.\n\n\n## 文件搜寻\n### VPATH\n默认情况下, `make`会在当前目录和所有子目录下寻找依赖文件和目标文件. \n为了能够在较大工程中扩大`make`的搜索范围, 我们可以通过特殊变量`VPATH`来指定搜索路径.\n\n\n```makefile\nVPATH = src:../headers\n```\n1. 不同的目录之间由`:`分隔, 上述定义指定了额外的`src`以及`../headers`目录;\n2. 当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中**从左到右**继续寻找.\n\n### vpath\n上述的`VPATH`指定了全局文件的搜索路径, 而`vpath`允许为**不同类型**的文件指定不同的搜索路径.\n\n**语法**\n```makefile\n# 1. 为指定模式的文件设置搜索路径\nvpath pattern directory1:directory2\n\n# 2. 清除指定模式的搜索路径\nvpath pattern\n\n# 3. 清除所有已设置的 vpath\nvpath\n```\n\n**特点**\n- 可以为不同类型的文件指定不同的搜索路径;\n- 支持使用 `%` 通配符匹配文件名;\n- 可以有多条 vpath 指令, 且针对相同模式的命令将会起到**附加**而非覆盖的作用.\n\n\n**e.g.**\n```makefile\n# 定义编译器\nCC = gcc\n\nvpath %.h include\nvpath %.c src\nvpath %.o build\nvpath %.a lib\n\nprogram: main.o utils.o\n    $(CC) -o program main.o utils.o -L. -lmylib\n\nmain.o: main.c project.h\n    $(CC) -c main.c\n\nutils.o: utils.c utils.h\n    $(CC) -c utils.c\n```\n\n---\n\n`vpath`的指令必须都写在`Makefile`当中, 在`Make`解析`Makefile`文件时被处理, 例如:\n```makefile\n# 如果需要清理 .o 文件的搜索路径并重新设置\nclean-paths:\n\t# 清除 .o 文件的搜索路径\n\tvpath %.o\n\t# 设置新的搜索路径\n\tvpath %.o new/build\n\n# 如果需要完全重置所有搜索路径\nreset-paths:\n\t# 清除所有 vpath 设置\n\tvpath\n\t# 重新设置所需的搜索路径\n\tvpath %.h include\n\tvpath %.c src\n\tvpath %.o build\n```\n在终端中对应的指令:\n```shell\n$ make              # 使用默认搜索路径编译\n$ make clean-paths  # 执行搜索路径清理和重设\n$ make reset-paths  # 重置所有搜索路径\n```\n\n---\n\n**优先级**: 当前目录 > `vpath` > `VPATH`. \n\n\n","source":"_posts/其他/makefile.md","raw":"---\ntitle: makefile\ndate: 2025-02-12 18:15:25\ntags:\ncategories:\nexcerpt: 一起来学习makefile吧！\n---\n# 编译\n# 基本概念\n## 默认目标\n- `Makefile`当中的第一个目标会成为**默认目标**;\n- 不指定参数的`make`命令会执行默认目标;\n- 通常使用`all`的伪目标作为默认目标.\n\n## 伪目标\n当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 **伪目标**.\n\n**语法**\n```makefile\n.PHONY: 目标名\n目标名:\n    命令\n```\n\n**使用示例**\n```makefile\n# 情景：需要清理编译产生的 .o 文件和可执行文件\n.PHONY: clean\nclean:\n    rm -f *.o program\n\n# 情景：需要运行测试\n.PHONY: test\ntest:\n    ./run_tests.sh\n\n# 使用方法：\n# make clean  # 清理文件\n# make test   # 运行测试\n```\n> 其中`-f`表示强制删除, 其他的参数如`-r`表示递归删除目录, `-rf`表示强制递归删除目录.\n\n### 多重构建\n我们还可以利用伪目标使得默认目标具有多个对象:\n```makefile \n.PHONY: all debug release clean\n\n# 默认目标包含常用的构建类型\nall: debug release\n\n# 调试版本\ndebug: main.c\n    @echo \"构建调试版本...\"\n    gcc -g main.c -o debug-program\n\n# 发布版本\nrelease: main.c\n    @echo \"构建发布版本...\"\n    gcc -O2 main.c -o release-program\n\nclean:\n    rm -f debug-program release-program\n\n# 使用：\n# make          # 构建调试版和发布版\n# make debug    # 只构建调试版\n# make release  # 只构建发布版\n# make clean    # 清理\n```\n\n## 多目标\ne.g: \n```makefile\nbigoutput littleoutput : text.g\n    generate text.g -$(subst output,,$@) > $@\n```\n\n### 解析\n\n```makefile\nbigoutput littleoutput : text.g\n    generate text.g -$(subst output,,$@) > $@\n```\n\n1. `bigoutput littleoutput` - 两个目标文件\n2. `text.g` - 依赖文件\n3. `$(subst output,,$@)` -变量展开：\n   - `$@` 是自动变量，表示当前目标名\n   - `subst` 是替换函数，格式为 `$(subst from,to,text)`\n   - 此处将目标名中的 \"output\" 替换为空\n\n当规则执行时：\n- 对于 `bigoutput` 目标：\n  - `$@` 展开为 `bigoutput`\n  - `$(subst output,,$@)` 结果为 `big`\n  - 最终命令变为：`generate text.g -big > bigoutput`\n\n- 对于 `littleoutput` 目标：\n  - `$@` 展开为 `littleoutput`\n  - `$(subst output,,$@)` 结果为 `little`\n  - 最终命令变为：`generate text.g -little > littleoutput`\n\n<br>\n\n因此, 上述的多目标规则**等价**于:\n```makefile\nbigoutput : text.g\n    generate text.g -big > bigoutput\nlittleoutput : text.g\n    generate text.g -little > littleoutput\n```\n\n### 规则语法\n\n多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：\n\n1. **基本语法**：\n   ```makefile\n   target1 target2 : prerequisites\n       commands\n   ```\n\n2. **特点**：\n   - 多个目标共享相同的依赖关系\n   - 命令会对每个目标分别执行一次\n   - 可以使用 `$@` 引用当前正在构建的目标\n\n3. **使用场景**：\n   - 生成相似但略有不同的文件\n   - 多个目标需要类似的构建过程\n   - 减少重复代码\n\n4. **示例**：\n   ```makefile\n   # 生成不同大小的图片\n   big.jpg small.jpg : original.jpg\n       convert original.jpg -resize $* > $@\n\n   # 生成不同格式的文档\n   manual.pdf manual.html : manual.txt\n       pandoc manual.txt -o $@\n   ```\n\n5. **优势**：\n   - 代码更简洁\n   - 易于维护\n   - 避免重复规则\n   - 更好的规则组织\n\n6. **注意事项**：\n   - 命令对每个目标都会执行一次\n   - 需要合理使用自动变量（如 `$@`）来区分不同目标\n   - 确保命令对所有目标都适用\n\n## 静态模式\n好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。\n\n### 1. 引入背景\n\n在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：\n\n```makefile\nfoo.o : foo.c\n    $(CC) -c $(CFLAGS) foo.c -o foo.o\n\nbar.o : bar.c\n    $(CC) -c $(CFLAGS) bar.c -o bar.o\n\ntest.o : test.c\n    $(CC) -c $(CFLAGS) test.c -o test.o\n```\n\n这种写法存在明显问题：\n- 规则重复，维护困难\n- 当新增源文件时需要手动添加规则\n- 代码冗长，不够优雅\n\n虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。\n\n### 2. 基本语法\n\n静态模式规则的基本语法如下：\n```makefile\ntargets ...: target-pattern: prereq-pattern\n    commands\n```\n\n其中：\n- `targets`: 要生成的目标文件列表\n- `target-pattern`: 目标的模式，通常包含 `%` 通配符\n- `prereq-pattern`: 依赖的模式，通常也包含 `%` 通配符\n- `commands`: 构建命令\n\n`%` 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。\n\n### 3. 综合示例\n\n让我们通过几个逐渐复杂的例子来说明静态模式的使用：\n\n#### 基础示例：编译 C 文件\n```makefile\nobjects = foo.o bar.o test.o\n\n$(objects): %.o: %.c\n    $(CC) -c $(CFLAGS) $< -o $@\n```\n\n#### 复杂示例：多种源文件处理\n```makefile\n# 定义源文件和目标文件\ncpp_sources := $(wildcard *.cpp)\nc_sources := $(wildcard *.c)\ncpp_objects := $(cpp_sources:.cpp=.o)\nc_objects := $(c_sources:.c=.o)\nall_objects := $(cpp_objects) $(c_objects)\n\n# C++ 源文件的编译规则\n$(cpp_objects): %.o: %.cpp\n    $(CXX) -c $(CXXFLAGS) $< -o $@\n\n# C 源文件的编译规则\n$(c_objects): %.o: %.c\n    $(CC) -c $(CFLAGS) $< -o $@\n\n# 生成可执行文件\nprogram: $(all_objects)\n    $(CXX) $^ -o $@\n```\n- `$(cpp_sources:.cpp=.o)`是一种**模式替换**, 会将`cpp_sources`中的所有`.cpp`文件替换为`.o`文件;\n  - 即`$(varname:pattern1=pattern2)` 会将`varname`中的所有`pattern1`替换为`pattern2`;\n\n#### 更复杂的示例：多目录处理\n```makefile\n# 目录结构\nSRCDIR = src\nOBJDIR = obj\n\n# 源文件和目标文件\nSOURCES = $(wildcard $(SRCDIR)/*.c)\nOBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)\n\n# 确保目标目录存在\n$(OBJDIR):\n    mkdir -p $@\n\n# 静态模式规则\n$(OBJECTS): $(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)\n    $(CC) -c $(CFLAGS) $< -o $@\n\n# 最终目标\nprogram: $(OBJECTS)\n    $(CC) $^ -o $@\n```\n> todo\n\n这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在**文件组织**方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 `src` 和 `obj`）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。\n\n在**目录管理**方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 `|` 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。\n\n在**文件名处理**方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 `src/main.c` 转换为 `obj/main.o`，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。\n\n---\n\n## 基本规则\n```makefile\ntarget ... : prerequisites ...\n    recipe\n    ...\n    ...\n```\n`target`: 目标文件 | 可执行文件 | 标签;\n`prerequisites`: 依赖文件 | `target`;\n`recipe`: 对应`target`所需的命令(以`Tap`缩进开头).\n\n<br>\n\n执行`recipe`命令的条件:\n- `prerequisites`中存在文件的日期早于`target`的日期;\n- `target`的文件不存在.\n\n## 使用变量\n```makefile\n# 定义变量: 类似于C的宏定义\nobjects = main.o display.o\n\n# 使用变量\nedit: $(objects)\n    cc -o edit $(objects)\n```\n1. 必须使用`Tab`缩进;\n2. 采取`$(variable)`的形式引用变量, 将会展开为变量的值;\n3. `cc -o edit` 声明采用C语言编译器同时指定输出文件名为`edit`.\n\n## Make的自动推导\n### 自动推导规则\n1. **文件关联**：\n   - 当make看到`.o`文件时，会自动将对应的`.c`文件加入依赖关系\n   - 例如：发现`whatever.o`时，会自动关联`whatever.c`作为依赖文件\n\n2. **命令推导**：\n   - 自动推导编译命令，如`cc -c whatever.c`\n   - 无需在每个`.o`文件后都手动写编译命令\n\n### 示例结构\n\n- **依赖关系**：\n```makefile\n# 自动推导之前\nmain.o : main.c defs.h\n    cc -c main.c\n\n# 自动推导下的简化书写\nmain.o : defs.h\n```\n\n- **清理目标**：\n```makefile\n.PHONY : clean\nclean :\n    rm edit $(objects)\n```\n\n- `.PHONY`表示`clean`是伪目标文件;\n- 这种自动推导方式大大简化了Makefile的编写;\n- `clean`总是放在文件的末尾.\n\n\n\n`make`命令在默认情况下会在当前目录下**依次**寻找文件名为`GNUmakefile`,`makefile`,`Makefile`的文件.\n- 推荐使用`Makefile`作为文件名;\n- 也可以使用`-f`或者`-file`参数来指定特定的`Makefile`文件.\n```shell\nmake -f Make.Linux\n```\n\n\n\n\n## include命令\n```makefile\n# 使用include命令可以将其他Makefile包含进来\ninclude <file-name>\n```\n- `include`命令前可以存在空字符, 但是不能为`Tab`缩进;\n- `include`与文件之间可以存在多个空格.\n\n\n### 直接指定文件\n```makefile\n# 最基本的include用法是直接指定文件名\ninclude config.mk\ninclude ./build/rules.mk\n\n# 同时包含多个文件\ninclude config.mk rules.mk tests.mk\n```\n\n### 使用通配符 *\n```makefile\n# * 匹配任意字符串\ninclude *.mk              # 包含当前目录下所有.mk文件\ninclude src/*.mk         # 包含src目录下的所有.mk文件\ninclude **/build/*.mk    # 包含任意子目录中build目录下的所有.mk文件\n```\n\n我们同样可以在变量中使用通配符 `*`:\n```makefile\n# 使用时展开\nobjects = *.o\n\n# 定义时展开(除非重新赋值, 否则保持定义时的展开状态)\nobjects := $(wildcard *.o)\n```\n\ne.g:\n```makefile\n$(patsubst %.c,%.o,$(wildcard *.c))\n```\n- `patsubst`是一个函数, 用于模式替换;\n- 语法为`patsubst <pattern>,<replacement>,<text>`;\n- 此处表示利用通配符, 将所有的`.c`文件名称替换为`.o`文件.\n\n\n### 使用单字符通配符\n```makefile\n# ? 匹配单个字符\ninclude test?.mk         # 匹配test1.mk, testA.mk等\ninclude rule_?.mk        # 匹配rule_1.mk, rule_2.mk等\ninclude config???.mk     # 匹配config后带三个字符的.mk文件\n```\n\n### 使用目录路径\n```makefile\n# 可以指定不同的目录路径\ninclude ./configs/*.mk    # 当前目录下的configs子目录\ninclude ../shared/*.mk    # 上级目录的shared子目录\ninclude /usr/local/include/make/*.mk  # 绝对路径\n```\n\n### 使用字符集[]\n```makefile\n# [] 用于匹配字符集中的任意一个字符\ninclude make[123].mk     # 匹配make1.mk, make2.mk, make3.mk\ninclude test[a-z].mk     # 匹配testa.mk到testz.mk\ninclude config[0-9].mk   # 匹配config0.mk到config9.mk\n```\n\n### 错误处理\n```makefile\n# 默认情况下，如果include的文件不存在，make会报错\n\n# 使用-include或sinclude可以忽略文件不存在的错误\n-include optional.mk     # 如果文件不存在，继续执行不报错\nsinclude optional.mk     # 与-include完全相同\n\n# 多个可选文件\n-include config/*.mk     # 如果config目录下有任何.mk文件不存在，继续执行\n```\n\n### 组合使用示例\n```makefile\n# 可以组合使用多种模式\ninclude config.mk \\\n        rules/*.mk \\\n        test[0-9].mk \\\n        ./build/**/*.mk\n\n# 使用变量\nINCLUDE_DIR = ./includes\ninclude $(INCLUDE_DIR)/*.mk\n\n# 条件包含\nifdef CUSTOM_RULES\n    include $(CUSTOM_RULES)\nendif\n```\n\n## make的工作方式\n1. 读取所有的`Makefile`;\n2. 读取`include`涉及的`Makefile`文件;\n3. 初始化文件当中的**变量**;\n4. 推导**隐式规则**并分析所有规则;\n5. 为目标文件创建依赖关系链;\n6. 根据依赖关系, 决定需要重新生成的文件;\n7. 执行生成命令.\n\n\n## 文件搜寻\n### VPATH\n默认情况下, `make`会在当前目录和所有子目录下寻找依赖文件和目标文件. \n为了能够在较大工程中扩大`make`的搜索范围, 我们可以通过特殊变量`VPATH`来指定搜索路径.\n\n\n```makefile\nVPATH = src:../headers\n```\n1. 不同的目录之间由`:`分隔, 上述定义指定了额外的`src`以及`../headers`目录;\n2. 当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中**从左到右**继续寻找.\n\n### vpath\n上述的`VPATH`指定了全局文件的搜索路径, 而`vpath`允许为**不同类型**的文件指定不同的搜索路径.\n\n**语法**\n```makefile\n# 1. 为指定模式的文件设置搜索路径\nvpath pattern directory1:directory2\n\n# 2. 清除指定模式的搜索路径\nvpath pattern\n\n# 3. 清除所有已设置的 vpath\nvpath\n```\n\n**特点**\n- 可以为不同类型的文件指定不同的搜索路径;\n- 支持使用 `%` 通配符匹配文件名;\n- 可以有多条 vpath 指令, 且针对相同模式的命令将会起到**附加**而非覆盖的作用.\n\n\n**e.g.**\n```makefile\n# 定义编译器\nCC = gcc\n\nvpath %.h include\nvpath %.c src\nvpath %.o build\nvpath %.a lib\n\nprogram: main.o utils.o\n    $(CC) -o program main.o utils.o -L. -lmylib\n\nmain.o: main.c project.h\n    $(CC) -c main.c\n\nutils.o: utils.c utils.h\n    $(CC) -c utils.c\n```\n\n---\n\n`vpath`的指令必须都写在`Makefile`当中, 在`Make`解析`Makefile`文件时被处理, 例如:\n```makefile\n# 如果需要清理 .o 文件的搜索路径并重新设置\nclean-paths:\n\t# 清除 .o 文件的搜索路径\n\tvpath %.o\n\t# 设置新的搜索路径\n\tvpath %.o new/build\n\n# 如果需要完全重置所有搜索路径\nreset-paths:\n\t# 清除所有 vpath 设置\n\tvpath\n\t# 重新设置所需的搜索路径\n\tvpath %.h include\n\tvpath %.c src\n\tvpath %.o build\n```\n在终端中对应的指令:\n```shell\n$ make              # 使用默认搜索路径编译\n$ make clean-paths  # 执行搜索路径清理和重设\n$ make reset-paths  # 重置所有搜索路径\n```\n\n---\n\n**优先级**: 当前目录 > `vpath` > `VPATH`. \n\n\n","slug":"其他/makefile","published":1,"updated":"2025-02-18T02:42:43.132Z","_id":"cm79tw4vx000wdwqgd5vi88m1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h1><h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"默认目标\"><a href=\"#默认目标\" class=\"headerlink\" title=\"默认目标\"></a>默认目标</h2><ul>\n<li><code>Makefile</code>当中的第一个目标会成为<strong>默认目标</strong>;</li>\n<li>不指定参数的<code>make</code>命令会执行默认目标;</li>\n<li>通常使用<code>all</code>的伪目标作为默认目标.</li>\n</ul>\n<h2 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h2><p>当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 <strong>伪目标</strong>.</p>\n<p><strong>语法</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: 目标名</span><br><span class=\"hljs-section\">目标名:</span><br>    命令<br></code></pre></td></tr></table></figure></p>\n<p><strong>使用示例</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 情景：需要清理编译产生的 .o 文件和可执行文件</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: clean</span><br><span class=\"hljs-section\">clean:</span><br>    rm -f *.o program<br><br><span class=\"hljs-comment\"># 情景：需要运行测试</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: test</span><br><span class=\"hljs-section\">test:</span><br>    ./run_tests.sh<br><br><span class=\"hljs-comment\"># 使用方法：</span><br><span class=\"hljs-comment\"># make clean  # 清理文件</span><br><span class=\"hljs-comment\"># make test   # 运行测试</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>其中<code>-f</code>表示强制删除, 其他的参数如<code>-r</code>表示递归删除目录, <code>-rf</code>表示强制递归删除目录.</p>\n</blockquote>\n<h3 id=\"多重构建\"><a href=\"#多重构建\" class=\"headerlink\" title=\"多重构建\"></a>多重构建</h3><p>我们还可以利用伪目标使得默认目标具有多个对象:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all debug release clean</span><br><br><span class=\"hljs-comment\"># 默认目标包含常用的构建类型</span><br><span class=\"hljs-section\">all: debug release</span><br><br><span class=\"hljs-comment\"># 调试版本</span><br><span class=\"hljs-section\">debug: main.c</span><br>    @echo <span class=\"hljs-string\">&quot;构建调试版本...&quot;</span><br>    gcc -g main.c -o debug-program<br><br><span class=\"hljs-comment\"># 发布版本</span><br><span class=\"hljs-section\">release: main.c</span><br>    @echo <span class=\"hljs-string\">&quot;构建发布版本...&quot;</span><br>    gcc -O2 main.c -o release-program<br><br><span class=\"hljs-section\">clean:</span><br>    rm -f debug-program release-program<br><br><span class=\"hljs-comment\"># 使用：</span><br><span class=\"hljs-comment\"># make          # 构建调试版和发布版</span><br><span class=\"hljs-comment\"># make debug    # 只构建调试版</span><br><span class=\"hljs-comment\"># make release  # 只构建发布版</span><br><span class=\"hljs-comment\"># make clean    # 清理</span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"多目标\"><a href=\"#多目标\" class=\"headerlink\" title=\"多目标\"></a>多目标</h2><p>e.g:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput littleoutput : text.g<br>    generate text.g -<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">subst</span> output,,<span class=\"hljs-variable\">$@</span>)</span> &gt; <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput littleoutput : text.g<br>    generate text.g -<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">subst</span> output,,<span class=\"hljs-variable\">$@</span>)</span> &gt; <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li><code>bigoutput littleoutput</code> - 两个目标文件</li>\n<li><code>text.g</code> - 依赖文件</li>\n<li><code>$(subst output,,$@)</code> -变量展开：<ul>\n<li><code>$@</code> 是自动变量，表示当前目标名</li>\n<li><code>subst</code> 是替换函数，格式为 <code>$(subst from,to,text)</code></li>\n<li>此处将目标名中的 “output” 替换为空</li>\n</ul>\n</li>\n</ol>\n<p>当规则执行时：</p>\n<ul>\n<li><p>对于 <code>bigoutput</code> 目标：</p>\n<ul>\n<li><code>$@</code> 展开为 <code>bigoutput</code></li>\n<li><code>$(subst output,,$@)</code> 结果为 <code>big</code></li>\n<li>最终命令变为：<code>generate text.g -big &gt; bigoutput</code></li>\n</ul>\n</li>\n<li><p>对于 <code>littleoutput</code> 目标：</p>\n<ul>\n<li><code>$@</code> 展开为 <code>littleoutput</code></li>\n<li><code>$(subst output,,$@)</code> 结果为 <code>little</code></li>\n<li>最终命令变为：<code>generate text.g -little &gt; littleoutput</code></li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p>因此, 上述的多目标规则<strong>等价</strong>于:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput : text.g<br>    generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>    generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"规则语法\"><a href=\"#规则语法\" class=\"headerlink\" title=\"规则语法\"></a>规则语法</h3><p>多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：</p>\n<ol>\n<li><p><strong>基本语法</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">target1 target2 : prerequisites<br>    commands<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>多个目标共享相同的依赖关系</li>\n<li>命令会对每个目标分别执行一次</li>\n<li>可以使用 <code>$@</code> 引用当前正在构建的目标</li>\n</ul>\n</li>\n<li><p><strong>使用场景</strong>：</p>\n<ul>\n<li>生成相似但略有不同的文件</li>\n<li>多个目标需要类似的构建过程</li>\n<li>减少重复代码</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 生成不同大小的图片</span><br>big.jpg small.jpg : original.jpg<br>    convert original.jpg -resize <span class=\"hljs-variable\">$*</span> &gt; <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 生成不同格式的文档</span><br>manual.pdf manual.html : manual.txt<br>    pandoc manual.txt -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>代码更简洁</li>\n<li>易于维护</li>\n<li>避免重复规则</li>\n<li>更好的规则组织</li>\n</ul>\n</li>\n<li><p><strong>注意事项</strong>：</p>\n<ul>\n<li>命令对每个目标都会执行一次</li>\n<li>需要合理使用自动变量（如 <code>$@</code>）来区分不同目标</li>\n<li>确保命令对所有目标都适用</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"静态模式\"><a href=\"#静态模式\" class=\"headerlink\" title=\"静态模式\"></a>静态模式</h2><p>好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。</p>\n<h3 id=\"1-引入背景\"><a href=\"#1-引入背景\" class=\"headerlink\" title=\"1. 引入背景\"></a>1. 引入背景</h3><p>在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">foo.o : foo.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> foo.c -o foo.o<br><br>bar.o : bar.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> bar.c -o bar.o<br><br>test.o : test.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> test.c -o test.o<br></code></pre></td></tr></table></figure>\n<p>这种写法存在明显问题：</p>\n<ul>\n<li>规则重复，维护困难</li>\n<li>当新增源文件时需要手动添加规则</li>\n<li>代码冗长，不够优雅</li>\n</ul>\n<p>虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。</p>\n<h3 id=\"2-基本语法\"><a href=\"#2-基本语法\" class=\"headerlink\" title=\"2. 基本语法\"></a>2. 基本语法</h3><p>静态模式规则的基本语法如下：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">targets ...: target-pattern: prereq-pattern<br>    commands<br></code></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li><code>targets</code>: 要生成的目标文件列表</li>\n<li><code>target-pattern</code>: 目标的模式，通常包含 <code>%</code> 通配符</li>\n<li><code>prereq-pattern</code>: 依赖的模式，通常也包含 <code>%</code> 通配符</li>\n<li><code>commands</code>: 构建命令</li>\n</ul>\n<p><code>%</code> 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。</p>\n<h3 id=\"3-综合示例\"><a href=\"#3-综合示例\" class=\"headerlink\" title=\"3. 综合示例\"></a>3. 综合示例</h3><p>让我们通过几个逐渐复杂的例子来说明静态模式的使用：</p>\n<h4 id=\"基础示例：编译-C-文件\"><a href=\"#基础示例：编译-C-文件\" class=\"headerlink\" title=\"基础示例：编译 C 文件\"></a>基础示例：编译 C 文件</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objects = foo.o bar.o test.o<br><br><span class=\"hljs-variable\">$(objects)</span>: %.o: %.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"复杂示例：多种源文件处理\"><a href=\"#复杂示例：多种源文件处理\" class=\"headerlink\" title=\"复杂示例：多种源文件处理\"></a>复杂示例：多种源文件处理</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义源文件和目标文件</span><br>cpp_sources := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.cpp)</span><br>c_sources := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br>cpp_objects := $(cpp_sources:.cpp=.o)<br>c_objects := $(c_sources:.c=.o)<br>all_objects := <span class=\"hljs-variable\">$(cpp_objects)</span> <span class=\"hljs-variable\">$(c_objects)</span><br><br><span class=\"hljs-comment\"># C++ 源文件的编译规则</span><br><span class=\"hljs-variable\">$(cpp_objects)</span>: %.o: %.cpp<br>    <span class=\"hljs-variable\">$(CXX)</span> -c <span class=\"hljs-variable\">$(CXXFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># C 源文件的编译规则</span><br><span class=\"hljs-variable\">$(c_objects)</span>: %.o: %.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 生成可执行文件</span><br><span class=\"hljs-section\">program: <span class=\"hljs-variable\">$(all_objects)</span></span><br>    <span class=\"hljs-variable\">$(CXX)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>$(cpp_sources:.cpp=.o)</code>是一种<strong>模式替换</strong>, 会将<code>cpp_sources</code>中的所有<code>.cpp</code>文件替换为<code>.o</code>文件;<ul>\n<li>即<code>$(varname:pattern1=pattern2)</code> 会将<code>varname</code>中的所有<code>pattern1</code>替换为<code>pattern2</code>;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"更复杂的示例：多目录处理\"><a href=\"#更复杂的示例：多目录处理\" class=\"headerlink\" title=\"更复杂的示例：多目录处理\"></a>更复杂的示例：多目录处理</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 目录结构</span><br>SRCDIR = src<br>OBJDIR = obj<br><br><span class=\"hljs-comment\"># 源文件和目标文件</span><br>SOURCES = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SRCDIR)</span>/*.c)</span><br>OBJECTS = $(SOURCES:<span class=\"hljs-variable\">$(SRCDIR)</span>/%.c=<span class=\"hljs-variable\">$(OBJDIR)</span>/%.o)<br><br><span class=\"hljs-comment\"># 确保目标目录存在</span><br><span class=\"hljs-variable\">$(OBJDIR)</span>:<br>    mkdir -p <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 静态模式规则</span><br><span class=\"hljs-variable\">$(OBJECTS)</span>: <span class=\"hljs-variable\">$(OBJDIR)</span>/%.o: <span class=\"hljs-variable\">$(SRCDIR)</span>/%.c | <span class=\"hljs-variable\">$(OBJDIR)</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 最终目标</span><br><span class=\"hljs-section\">program: <span class=\"hljs-variable\">$(OBJECTS)</span></span><br>    <span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>todo</p>\n</blockquote>\n<p>这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在<strong>文件组织</strong>方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 <code>src</code> 和 <code>obj</code>）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。</p>\n<p>在<strong>目录管理</strong>方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 <code>|</code> 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。</p>\n<p>在<strong>文件名处理</strong>方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 <code>src/main.c</code> 转换为 <code>obj/main.o</code>，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。</p>\n<hr>\n<h2 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">target ... : prerequisites ...<br>    recipe<br>    ...<br>    ...<br></code></pre></td></tr></table></figure>\n<p><code>target</code>: 目标文件 | 可执行文件 | 标签;<br><code>prerequisites</code>: 依赖文件 | <code>target</code>;<br><code>recipe</code>: 对应<code>target</code>所需的命令(以<code>Tap</code>缩进开头).</p>\n<p><br></p>\n<p>执行<code>recipe</code>命令的条件:</p>\n<ul>\n<li><code>prerequisites</code>中存在文件的日期早于<code>target</code>的日期;</li>\n<li><code>target</code>的文件不存在.</li>\n</ul>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义变量: 类似于C的宏定义</span><br>objects = main.o display.o<br><br><span class=\"hljs-comment\"># 使用变量</span><br><span class=\"hljs-section\">edit: <span class=\"hljs-variable\">$(objects)</span></span><br>    cc -o edit <span class=\"hljs-variable\">$(objects)</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>必须使用<code>Tab</code>缩进;</li>\n<li>采取<code>$(variable)</code>的形式引用变量, 将会展开为变量的值;</li>\n<li><code>cc -o edit</code> 声明采用C语言编译器同时指定输出文件名为<code>edit</code>.</li>\n</ol>\n<h2 id=\"Make的自动推导\"><a href=\"#Make的自动推导\" class=\"headerlink\" title=\"Make的自动推导\"></a>Make的自动推导</h2><h3 id=\"自动推导规则\"><a href=\"#自动推导规则\" class=\"headerlink\" title=\"自动推导规则\"></a>自动推导规则</h3><ol>\n<li><p><strong>文件关联</strong>：</p>\n<ul>\n<li>当make看到<code>.o</code>文件时，会自动将对应的<code>.c</code>文件加入依赖关系</li>\n<li>例如：发现<code>whatever.o</code>时，会自动关联<code>whatever.c</code>作为依赖文件</li>\n</ul>\n</li>\n<li><p><strong>命令推导</strong>：</p>\n<ul>\n<li>自动推导编译命令，如<code>cc -c whatever.c</code></li>\n<li>无需在每个<code>.o</code>文件后都手动写编译命令</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例结构\"><a href=\"#示例结构\" class=\"headerlink\" title=\"示例结构\"></a>示例结构</h3><ul>\n<li><p><strong>依赖关系</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 自动推导之前</span><br>main.o : main.c defs.h<br>    cc -c main.c<br><br><span class=\"hljs-comment\"># 自动推导下的简化书写</span><br>main.o : defs.h<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>清理目标</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">.PHONY : clean<br>clean :<br>    rm edit <span class=\"hljs-variable\">$(objects)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>.PHONY</code>表示<code>clean</code>是伪目标文件;</p>\n</li>\n<li>这种自动推导方式大大简化了Makefile的编写;</li>\n<li><code>clean</code>总是放在文件的末尾.</li>\n</ul>\n<p><code>make</code>命令在默认情况下会在当前目录下<strong>依次</strong>寻找文件名为<code>GNUmakefile</code>,<code>makefile</code>,<code>Makefile</code>的文件.</p>\n<ul>\n<li>推荐使用<code>Makefile</code>作为文件名;</li>\n<li>也可以使用<code>-f</code>或者<code>-file</code>参数来指定特定的<code>Makefile</code>文件.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">make -f Make.Linux<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"include命令\"><a href=\"#include命令\" class=\"headerlink\" title=\"include命令\"></a>include命令</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 使用include命令可以将其他Makefile包含进来</span><br><span class=\"hljs-keyword\">include</span> &lt;file-name&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>include</code>命令前可以存在空字符, 但是不能为<code>Tab</code>缩进;</li>\n<li><code>include</code>与文件之间可以存在多个空格.</li>\n</ul>\n<h3 id=\"直接指定文件\"><a href=\"#直接指定文件\" class=\"headerlink\" title=\"直接指定文件\"></a>直接指定文件</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 最基本的include用法是直接指定文件名</span><br><span class=\"hljs-keyword\">include</span> config.mk<br><span class=\"hljs-keyword\">include</span> ./build/rules.mk<br><br><span class=\"hljs-comment\"># 同时包含多个文件</span><br><span class=\"hljs-keyword\">include</span> config.mk rules.mk tests.mk<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用通配符\"><a href=\"#使用通配符\" class=\"headerlink\" title=\"使用通配符 *\"></a>使用通配符 *</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># * 匹配任意字符串</span><br><span class=\"hljs-keyword\">include</span> *.mk              <span class=\"hljs-comment\"># 包含当前目录下所有.mk文件</span><br><span class=\"hljs-keyword\">include</span> src/*.mk         <span class=\"hljs-comment\"># 包含src目录下的所有.mk文件</span><br><span class=\"hljs-keyword\">include</span> **/build/*.mk    <span class=\"hljs-comment\"># 包含任意子目录中build目录下的所有.mk文件</span><br></code></pre></td></tr></table></figure>\n<p>我们同样可以在变量中使用通配符 <code>*</code>:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 使用时展开</span><br>objects = *.o<br><br><span class=\"hljs-comment\"># 定义时展开(除非重新赋值, 否则保持定义时的展开状态)</span><br>objects := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.o)</span><br></code></pre></td></tr></table></figure></p>\n<p>e.g:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.c,%.o,$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span>)<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>patsubst</code>是一个函数, 用于模式替换;</li>\n<li>语法为<code>patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;</code>;</li>\n<li>此处表示利用通配符, 将所有的<code>.c</code>文件名称替换为<code>.o</code>文件.</li>\n</ul>\n<h3 id=\"使用单字符通配符\"><a href=\"#使用单字符通配符\" class=\"headerlink\" title=\"使用单字符通配符\"></a>使用单字符通配符</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># ? 匹配单个字符</span><br><span class=\"hljs-keyword\">include</span> test?.mk         <span class=\"hljs-comment\"># 匹配test1.mk, testA.mk等</span><br><span class=\"hljs-keyword\">include</span> rule_?.mk        <span class=\"hljs-comment\"># 匹配rule_1.mk, rule_2.mk等</span><br><span class=\"hljs-keyword\">include</span> config???.mk     <span class=\"hljs-comment\"># 匹配config后带三个字符的.mk文件</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"使用目录路径\"><a href=\"#使用目录路径\" class=\"headerlink\" title=\"使用目录路径\"></a>使用目录路径</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 可以指定不同的目录路径</span><br><span class=\"hljs-keyword\">include</span> ./configs/*.mk    <span class=\"hljs-comment\"># 当前目录下的configs子目录</span><br><span class=\"hljs-keyword\">include</span> ../shared/*.mk    <span class=\"hljs-comment\"># 上级目录的shared子目录</span><br><span class=\"hljs-keyword\">include</span> /usr/local/<span class=\"hljs-keyword\">include</span>/make/*.mk  <span class=\"hljs-comment\"># 绝对路径</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"使用字符集\"><a href=\"#使用字符集\" class=\"headerlink\" title=\"使用字符集[]\"></a>使用字符集[]</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># [] 用于匹配字符集中的任意一个字符</span><br><span class=\"hljs-keyword\">include</span> make[123].mk     <span class=\"hljs-comment\"># 匹配make1.mk, make2.mk, make3.mk</span><br><span class=\"hljs-keyword\">include</span> test[a-z].mk     <span class=\"hljs-comment\"># 匹配testa.mk到testz.mk</span><br><span class=\"hljs-keyword\">include</span> config[0-9].mk   <span class=\"hljs-comment\"># 匹配config0.mk到config9.mk</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 默认情况下，如果include的文件不存在，make会报错</span><br><br><span class=\"hljs-comment\"># 使用-include或sinclude可以忽略文件不存在的错误</span><br><span class=\"hljs-keyword\">-include</span> optional.mk     <span class=\"hljs-comment\"># 如果文件不存在，继续执行不报错</span><br><span class=\"hljs-keyword\">sinclude</span> optional.mk     <span class=\"hljs-comment\"># 与-include完全相同</span><br><br><span class=\"hljs-comment\"># 多个可选文件</span><br><span class=\"hljs-keyword\">-include</span> config/*.mk     <span class=\"hljs-comment\"># 如果config目录下有任何.mk文件不存在，继续执行</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"组合使用示例\"><a href=\"#组合使用示例\" class=\"headerlink\" title=\"组合使用示例\"></a>组合使用示例</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 可以组合使用多种模式</span><br><span class=\"hljs-keyword\">include</span> config.mk \\<br>        rules/*.mk \\<br>        test[0-9].mk \\<br>        ./build/**/*.mk<br><br><span class=\"hljs-comment\"># 使用变量</span><br>INCLUDE_DIR = ./includes<br><span class=\"hljs-keyword\">include</span> <span class=\"hljs-variable\">$(INCLUDE_DIR)</span>/*.mk<br><br><span class=\"hljs-comment\"># 条件包含</span><br><span class=\"hljs-keyword\">ifdef</span> CUSTOM_RULES<br>    <span class=\"hljs-keyword\">include</span> <span class=\"hljs-variable\">$(CUSTOM_RULES)</span><br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"make的工作方式\"><a href=\"#make的工作方式\" class=\"headerlink\" title=\"make的工作方式\"></a>make的工作方式</h2><ol>\n<li>读取所有的<code>Makefile</code>;</li>\n<li>读取<code>include</code>涉及的<code>Makefile</code>文件;</li>\n<li>初始化文件当中的<strong>变量</strong>;</li>\n<li>推导<strong>隐式规则</strong>并分析所有规则;</li>\n<li>为目标文件创建依赖关系链;</li>\n<li>根据依赖关系, 决定需要重新生成的文件;</li>\n<li>执行生成命令.</li>\n</ol>\n<h2 id=\"文件搜寻\"><a href=\"#文件搜寻\" class=\"headerlink\" title=\"文件搜寻\"></a>文件搜寻</h2><h3 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h3><p>默认情况下, <code>make</code>会在当前目录和所有子目录下寻找依赖文件和目标文件.<br>为了能够在较大工程中扩大<code>make</code>的搜索范围, 我们可以通过特殊变量<code>VPATH</code>来指定搜索路径.</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">VPATH = src:../headers<br></code></pre></td></tr></table></figure>\n<ol>\n<li>不同的目录之间由<code>:</code>分隔, 上述定义指定了额外的<code>src</code>以及<code>../headers</code>目录;</li>\n<li>当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中<strong>从左到右</strong>继续寻找.</li>\n</ol>\n<h3 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h3><p>上述的<code>VPATH</code>指定了全局文件的搜索路径, 而<code>vpath</code>允许为<strong>不同类型</strong>的文件指定不同的搜索路径.</p>\n<p><strong>语法</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 1. 为指定模式的文件设置搜索路径</span><br><span class=\"hljs-keyword\">vpath</span> pattern directory1:directory2<br><br><span class=\"hljs-comment\"># 2. 清除指定模式的搜索路径</span><br><span class=\"hljs-keyword\">vpath</span> pattern<br><br><span class=\"hljs-comment\"># 3. 清除所有已设置的 vpath</span><br><span class=\"hljs-keyword\">vpath</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>特点</strong></p>\n<ul>\n<li>可以为不同类型的文件指定不同的搜索路径;</li>\n<li>支持使用 <code>%</code> 通配符匹配文件名;</li>\n<li>可以有多条 vpath 指令, 且针对相同模式的命令将会起到<strong>附加</strong>而非覆盖的作用.</li>\n</ul>\n<p><strong>e.g.</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器</span><br>CC = gcc<br><br><span class=\"hljs-keyword\">vpath</span> %.h <span class=\"hljs-keyword\">include</span><br><span class=\"hljs-keyword\">vpath</span> %.c src<br><span class=\"hljs-keyword\">vpath</span> %.o build<br><span class=\"hljs-keyword\">vpath</span> %.a lib<br><br><span class=\"hljs-section\">program: main.o utils.o</span><br>    <span class=\"hljs-variable\">$(CC)</span> -o program main.o utils.o -L. -lmylib<br><br><span class=\"hljs-section\">main.o: main.c project.h</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c main.c<br><br><span class=\"hljs-section\">utils.o: utils.c utils.h</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c utils.c<br></code></pre></td></tr></table></figure></p>\n<hr>\n<p><code>vpath</code>的指令必须都写在<code>Makefile</code>当中, 在<code>Make</code>解析<code>Makefile</code>文件时被处理, 例如:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 如果需要清理 .o 文件的搜索路径并重新设置</span><br><span class=\"hljs-section\">clean-paths:</span><br>\t<span class=\"hljs-comment\"># 清除 .o 文件的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.o<br>\t<span class=\"hljs-comment\"># 设置新的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.o new/build<br><br><span class=\"hljs-comment\"># 如果需要完全重置所有搜索路径</span><br><span class=\"hljs-section\">reset-paths:</span><br>\t<span class=\"hljs-comment\"># 清除所有 vpath 设置</span><br>\t<span class=\"hljs-keyword\">vpath</span><br>\t<span class=\"hljs-comment\"># 重新设置所需的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.h <span class=\"hljs-keyword\">include</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.c src<br>\t<span class=\"hljs-keyword\">vpath</span> %.o build<br></code></pre></td></tr></table></figure><br>在终端中对应的指令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make              <span class=\"hljs-comment\"># 使用默认搜索路径编译</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make clean-paths  <span class=\"hljs-comment\"># 执行搜索路径清理和重设</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make reset-paths  <span class=\"hljs-comment\"># 重置所有搜索路径</span></span><br></code></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>优先级</strong>: 当前目录 &gt; <code>vpath</code> &gt; <code>VPATH</code>. </p>\n","more":"<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h1><h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h2 id=\"默认目标\"><a href=\"#默认目标\" class=\"headerlink\" title=\"默认目标\"></a>默认目标</h2><ul>\n<li><code>Makefile</code>当中的第一个目标会成为<strong>默认目标</strong>;</li>\n<li>不指定参数的<code>make</code>命令会执行默认目标;</li>\n<li>通常使用<code>all</code>的伪目标作为默认目标.</li>\n</ul>\n<h2 id=\"伪目标\"><a href=\"#伪目标\" class=\"headerlink\" title=\"伪目标\"></a>伪目标</h2><p>当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 <strong>伪目标</strong>.</p>\n<p><strong>语法</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: 目标名</span><br><span class=\"hljs-section\">目标名:</span><br>    命令<br></code></pre></td></tr></table></figure></p>\n<p><strong>使用示例</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 情景：需要清理编译产生的 .o 文件和可执行文件</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: clean</span><br><span class=\"hljs-section\">clean:</span><br>    rm -f *.o program<br><br><span class=\"hljs-comment\"># 情景：需要运行测试</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: test</span><br><span class=\"hljs-section\">test:</span><br>    ./run_tests.sh<br><br><span class=\"hljs-comment\"># 使用方法：</span><br><span class=\"hljs-comment\"># make clean  # 清理文件</span><br><span class=\"hljs-comment\"># make test   # 运行测试</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>其中<code>-f</code>表示强制删除, 其他的参数如<code>-r</code>表示递归删除目录, <code>-rf</code>表示强制递归删除目录.</p>\n</blockquote>\n<h3 id=\"多重构建\"><a href=\"#多重构建\" class=\"headerlink\" title=\"多重构建\"></a>多重构建</h3><p>我们还可以利用伪目标使得默认目标具有多个对象:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">.PHONY</span>: all debug release clean</span><br><br><span class=\"hljs-comment\"># 默认目标包含常用的构建类型</span><br><span class=\"hljs-section\">all: debug release</span><br><br><span class=\"hljs-comment\"># 调试版本</span><br><span class=\"hljs-section\">debug: main.c</span><br>    @echo <span class=\"hljs-string\">&quot;构建调试版本...&quot;</span><br>    gcc -g main.c -o debug-program<br><br><span class=\"hljs-comment\"># 发布版本</span><br><span class=\"hljs-section\">release: main.c</span><br>    @echo <span class=\"hljs-string\">&quot;构建发布版本...&quot;</span><br>    gcc -O2 main.c -o release-program<br><br><span class=\"hljs-section\">clean:</span><br>    rm -f debug-program release-program<br><br><span class=\"hljs-comment\"># 使用：</span><br><span class=\"hljs-comment\"># make          # 构建调试版和发布版</span><br><span class=\"hljs-comment\"># make debug    # 只构建调试版</span><br><span class=\"hljs-comment\"># make release  # 只构建发布版</span><br><span class=\"hljs-comment\"># make clean    # 清理</span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"多目标\"><a href=\"#多目标\" class=\"headerlink\" title=\"多目标\"></a>多目标</h2><p>e.g:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput littleoutput : text.g<br>    generate text.g -<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">subst</span> output,,<span class=\"hljs-variable\">$@</span>)</span> &gt; <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput littleoutput : text.g<br>    generate text.g -<span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">subst</span> output,,<span class=\"hljs-variable\">$@</span>)</span> &gt; <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li><code>bigoutput littleoutput</code> - 两个目标文件</li>\n<li><code>text.g</code> - 依赖文件</li>\n<li><code>$(subst output,,$@)</code> -变量展开：<ul>\n<li><code>$@</code> 是自动变量，表示当前目标名</li>\n<li><code>subst</code> 是替换函数，格式为 <code>$(subst from,to,text)</code></li>\n<li>此处将目标名中的 “output” 替换为空</li>\n</ul>\n</li>\n</ol>\n<p>当规则执行时：</p>\n<ul>\n<li><p>对于 <code>bigoutput</code> 目标：</p>\n<ul>\n<li><code>$@</code> 展开为 <code>bigoutput</code></li>\n<li><code>$(subst output,,$@)</code> 结果为 <code>big</code></li>\n<li>最终命令变为：<code>generate text.g -big &gt; bigoutput</code></li>\n</ul>\n</li>\n<li><p>对于 <code>littleoutput</code> 目标：</p>\n<ul>\n<li><code>$@</code> 展开为 <code>littleoutput</code></li>\n<li><code>$(subst output,,$@)</code> 结果为 <code>little</code></li>\n<li>最终命令变为：<code>generate text.g -little &gt; littleoutput</code></li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p>因此, 上述的多目标规则<strong>等价</strong>于:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">bigoutput : text.g<br>    generate text.g -big &gt; bigoutput<br>littleoutput : text.g<br>    generate text.g -little &gt; littleoutput<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"规则语法\"><a href=\"#规则语法\" class=\"headerlink\" title=\"规则语法\"></a>规则语法</h3><p>多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：</p>\n<ol>\n<li><p><strong>基本语法</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">target1 target2 : prerequisites<br>    commands<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>特点</strong>：</p>\n<ul>\n<li>多个目标共享相同的依赖关系</li>\n<li>命令会对每个目标分别执行一次</li>\n<li>可以使用 <code>$@</code> 引用当前正在构建的目标</li>\n</ul>\n</li>\n<li><p><strong>使用场景</strong>：</p>\n<ul>\n<li>生成相似但略有不同的文件</li>\n<li>多个目标需要类似的构建过程</li>\n<li>减少重复代码</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 生成不同大小的图片</span><br>big.jpg small.jpg : original.jpg<br>    convert original.jpg -resize <span class=\"hljs-variable\">$*</span> &gt; <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 生成不同格式的文档</span><br>manual.pdf manual.html : manual.txt<br>    pandoc manual.txt -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>优势</strong>：</p>\n<ul>\n<li>代码更简洁</li>\n<li>易于维护</li>\n<li>避免重复规则</li>\n<li>更好的规则组织</li>\n</ul>\n</li>\n<li><p><strong>注意事项</strong>：</p>\n<ul>\n<li>命令对每个目标都会执行一次</li>\n<li>需要合理使用自动变量（如 <code>$@</code>）来区分不同目标</li>\n<li>确保命令对所有目标都适用</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"静态模式\"><a href=\"#静态模式\" class=\"headerlink\" title=\"静态模式\"></a>静态模式</h2><p>好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。</p>\n<h3 id=\"1-引入背景\"><a href=\"#1-引入背景\" class=\"headerlink\" title=\"1. 引入背景\"></a>1. 引入背景</h3><p>在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">foo.o : foo.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> foo.c -o foo.o<br><br>bar.o : bar.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> bar.c -o bar.o<br><br>test.o : test.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> test.c -o test.o<br></code></pre></td></tr></table></figure>\n<p>这种写法存在明显问题：</p>\n<ul>\n<li>规则重复，维护困难</li>\n<li>当新增源文件时需要手动添加规则</li>\n<li>代码冗长，不够优雅</li>\n</ul>\n<p>虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。</p>\n<h3 id=\"2-基本语法\"><a href=\"#2-基本语法\" class=\"headerlink\" title=\"2. 基本语法\"></a>2. 基本语法</h3><p>静态模式规则的基本语法如下：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">targets ...: target-pattern: prereq-pattern<br>    commands<br></code></pre></td></tr></table></figure></p>\n<p>其中：</p>\n<ul>\n<li><code>targets</code>: 要生成的目标文件列表</li>\n<li><code>target-pattern</code>: 目标的模式，通常包含 <code>%</code> 通配符</li>\n<li><code>prereq-pattern</code>: 依赖的模式，通常也包含 <code>%</code> 通配符</li>\n<li><code>commands</code>: 构建命令</li>\n</ul>\n<p><code>%</code> 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。</p>\n<h3 id=\"3-综合示例\"><a href=\"#3-综合示例\" class=\"headerlink\" title=\"3. 综合示例\"></a>3. 综合示例</h3><p>让我们通过几个逐渐复杂的例子来说明静态模式的使用：</p>\n<h4 id=\"基础示例：编译-C-文件\"><a href=\"#基础示例：编译-C-文件\" class=\"headerlink\" title=\"基础示例：编译 C 文件\"></a>基础示例：编译 C 文件</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">objects = foo.o bar.o test.o<br><br><span class=\"hljs-variable\">$(objects)</span>: %.o: %.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"复杂示例：多种源文件处理\"><a href=\"#复杂示例：多种源文件处理\" class=\"headerlink\" title=\"复杂示例：多种源文件处理\"></a>复杂示例：多种源文件处理</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义源文件和目标文件</span><br>cpp_sources := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.cpp)</span><br>c_sources := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span><br>cpp_objects := $(cpp_sources:.cpp=.o)<br>c_objects := $(c_sources:.c=.o)<br>all_objects := <span class=\"hljs-variable\">$(cpp_objects)</span> <span class=\"hljs-variable\">$(c_objects)</span><br><br><span class=\"hljs-comment\"># C++ 源文件的编译规则</span><br><span class=\"hljs-variable\">$(cpp_objects)</span>: %.o: %.cpp<br>    <span class=\"hljs-variable\">$(CXX)</span> -c <span class=\"hljs-variable\">$(CXXFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># C 源文件的编译规则</span><br><span class=\"hljs-variable\">$(c_objects)</span>: %.o: %.c<br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 生成可执行文件</span><br><span class=\"hljs-section\">program: <span class=\"hljs-variable\">$(all_objects)</span></span><br>    <span class=\"hljs-variable\">$(CXX)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>$(cpp_sources:.cpp=.o)</code>是一种<strong>模式替换</strong>, 会将<code>cpp_sources</code>中的所有<code>.cpp</code>文件替换为<code>.o</code>文件;<ul>\n<li>即<code>$(varname:pattern1=pattern2)</code> 会将<code>varname</code>中的所有<code>pattern1</code>替换为<code>pattern2</code>;</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"更复杂的示例：多目录处理\"><a href=\"#更复杂的示例：多目录处理\" class=\"headerlink\" title=\"更复杂的示例：多目录处理\"></a>更复杂的示例：多目录处理</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 目录结构</span><br>SRCDIR = src<br>OBJDIR = obj<br><br><span class=\"hljs-comment\"># 源文件和目标文件</span><br>SOURCES = <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> <span class=\"hljs-variable\">$(SRCDIR)</span>/*.c)</span><br>OBJECTS = $(SOURCES:<span class=\"hljs-variable\">$(SRCDIR)</span>/%.c=<span class=\"hljs-variable\">$(OBJDIR)</span>/%.o)<br><br><span class=\"hljs-comment\"># 确保目标目录存在</span><br><span class=\"hljs-variable\">$(OBJDIR)</span>:<br>    mkdir -p <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 静态模式规则</span><br><span class=\"hljs-variable\">$(OBJECTS)</span>: <span class=\"hljs-variable\">$(OBJDIR)</span>/%.o: <span class=\"hljs-variable\">$(SRCDIR)</span>/%.c | <span class=\"hljs-variable\">$(OBJDIR)</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c <span class=\"hljs-variable\">$(CFLAGS)</span> <span class=\"hljs-variable\">$&lt;</span> -o <span class=\"hljs-variable\">$@</span><br><br><span class=\"hljs-comment\"># 最终目标</span><br><span class=\"hljs-section\">program: <span class=\"hljs-variable\">$(OBJECTS)</span></span><br>    <span class=\"hljs-variable\">$(CC)</span> <span class=\"hljs-variable\">$^</span> -o <span class=\"hljs-variable\">$@</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>todo</p>\n</blockquote>\n<p>这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在<strong>文件组织</strong>方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 <code>src</code> 和 <code>obj</code>）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。</p>\n<p>在<strong>目录管理</strong>方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 <code>|</code> 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。</p>\n<p>在<strong>文件名处理</strong>方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 <code>src/main.c</code> 转换为 <code>obj/main.o</code>，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。</p>\n<hr>\n<h2 id=\"基本规则\"><a href=\"#基本规则\" class=\"headerlink\" title=\"基本规则\"></a>基本规则</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">target ... : prerequisites ...<br>    recipe<br>    ...<br>    ...<br></code></pre></td></tr></table></figure>\n<p><code>target</code>: 目标文件 | 可执行文件 | 标签;<br><code>prerequisites</code>: 依赖文件 | <code>target</code>;<br><code>recipe</code>: 对应<code>target</code>所需的命令(以<code>Tap</code>缩进开头).</p>\n<p><br></p>\n<p>执行<code>recipe</code>命令的条件:</p>\n<ul>\n<li><code>prerequisites</code>中存在文件的日期早于<code>target</code>的日期;</li>\n<li><code>target</code>的文件不存在.</li>\n</ul>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义变量: 类似于C的宏定义</span><br>objects = main.o display.o<br><br><span class=\"hljs-comment\"># 使用变量</span><br><span class=\"hljs-section\">edit: <span class=\"hljs-variable\">$(objects)</span></span><br>    cc -o edit <span class=\"hljs-variable\">$(objects)</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>必须使用<code>Tab</code>缩进;</li>\n<li>采取<code>$(variable)</code>的形式引用变量, 将会展开为变量的值;</li>\n<li><code>cc -o edit</code> 声明采用C语言编译器同时指定输出文件名为<code>edit</code>.</li>\n</ol>\n<h2 id=\"Make的自动推导\"><a href=\"#Make的自动推导\" class=\"headerlink\" title=\"Make的自动推导\"></a>Make的自动推导</h2><h3 id=\"自动推导规则\"><a href=\"#自动推导规则\" class=\"headerlink\" title=\"自动推导规则\"></a>自动推导规则</h3><ol>\n<li><p><strong>文件关联</strong>：</p>\n<ul>\n<li>当make看到<code>.o</code>文件时，会自动将对应的<code>.c</code>文件加入依赖关系</li>\n<li>例如：发现<code>whatever.o</code>时，会自动关联<code>whatever.c</code>作为依赖文件</li>\n</ul>\n</li>\n<li><p><strong>命令推导</strong>：</p>\n<ul>\n<li>自动推导编译命令，如<code>cc -c whatever.c</code></li>\n<li>无需在每个<code>.o</code>文件后都手动写编译命令</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"示例结构\"><a href=\"#示例结构\" class=\"headerlink\" title=\"示例结构\"></a>示例结构</h3><ul>\n<li><p><strong>依赖关系</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 自动推导之前</span><br>main.o : main.c defs.h<br>    cc -c main.c<br><br><span class=\"hljs-comment\"># 自动推导下的简化书写</span><br>main.o : defs.h<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>清理目标</strong>：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">.PHONY : clean<br>clean :<br>    rm edit <span class=\"hljs-variable\">$(objects)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>.PHONY</code>表示<code>clean</code>是伪目标文件;</p>\n</li>\n<li>这种自动推导方式大大简化了Makefile的编写;</li>\n<li><code>clean</code>总是放在文件的末尾.</li>\n</ul>\n<p><code>make</code>命令在默认情况下会在当前目录下<strong>依次</strong>寻找文件名为<code>GNUmakefile</code>,<code>makefile</code>,<code>Makefile</code>的文件.</p>\n<ul>\n<li>推荐使用<code>Makefile</code>作为文件名;</li>\n<li>也可以使用<code>-f</code>或者<code>-file</code>参数来指定特定的<code>Makefile</code>文件.<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">make -f Make.Linux<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"include命令\"><a href=\"#include命令\" class=\"headerlink\" title=\"include命令\"></a>include命令</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 使用include命令可以将其他Makefile包含进来</span><br><span class=\"hljs-keyword\">include</span> &lt;file-name&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>include</code>命令前可以存在空字符, 但是不能为<code>Tab</code>缩进;</li>\n<li><code>include</code>与文件之间可以存在多个空格.</li>\n</ul>\n<h3 id=\"直接指定文件\"><a href=\"#直接指定文件\" class=\"headerlink\" title=\"直接指定文件\"></a>直接指定文件</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 最基本的include用法是直接指定文件名</span><br><span class=\"hljs-keyword\">include</span> config.mk<br><span class=\"hljs-keyword\">include</span> ./build/rules.mk<br><br><span class=\"hljs-comment\"># 同时包含多个文件</span><br><span class=\"hljs-keyword\">include</span> config.mk rules.mk tests.mk<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用通配符\"><a href=\"#使用通配符\" class=\"headerlink\" title=\"使用通配符 *\"></a>使用通配符 *</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># * 匹配任意字符串</span><br><span class=\"hljs-keyword\">include</span> *.mk              <span class=\"hljs-comment\"># 包含当前目录下所有.mk文件</span><br><span class=\"hljs-keyword\">include</span> src/*.mk         <span class=\"hljs-comment\"># 包含src目录下的所有.mk文件</span><br><span class=\"hljs-keyword\">include</span> **/build/*.mk    <span class=\"hljs-comment\"># 包含任意子目录中build目录下的所有.mk文件</span><br></code></pre></td></tr></table></figure>\n<p>我们同样可以在变量中使用通配符 <code>*</code>:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 使用时展开</span><br>objects = *.o<br><br><span class=\"hljs-comment\"># 定义时展开(除非重新赋值, 否则保持定义时的展开状态)</span><br>objects := <span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">wildcard</span> *.o)</span><br></code></pre></td></tr></table></figure></p>\n<p>e.g:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-variable\">$(<span class=\"hljs-built_in\">patsubst</span> %.c,%.o,$(<span class=\"hljs-built_in\">wildcard</span> *.c)</span>)<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>patsubst</code>是一个函数, 用于模式替换;</li>\n<li>语法为<code>patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;</code>;</li>\n<li>此处表示利用通配符, 将所有的<code>.c</code>文件名称替换为<code>.o</code>文件.</li>\n</ul>\n<h3 id=\"使用单字符通配符\"><a href=\"#使用单字符通配符\" class=\"headerlink\" title=\"使用单字符通配符\"></a>使用单字符通配符</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># ? 匹配单个字符</span><br><span class=\"hljs-keyword\">include</span> test?.mk         <span class=\"hljs-comment\"># 匹配test1.mk, testA.mk等</span><br><span class=\"hljs-keyword\">include</span> rule_?.mk        <span class=\"hljs-comment\"># 匹配rule_1.mk, rule_2.mk等</span><br><span class=\"hljs-keyword\">include</span> config???.mk     <span class=\"hljs-comment\"># 匹配config后带三个字符的.mk文件</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"使用目录路径\"><a href=\"#使用目录路径\" class=\"headerlink\" title=\"使用目录路径\"></a>使用目录路径</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 可以指定不同的目录路径</span><br><span class=\"hljs-keyword\">include</span> ./configs/*.mk    <span class=\"hljs-comment\"># 当前目录下的configs子目录</span><br><span class=\"hljs-keyword\">include</span> ../shared/*.mk    <span class=\"hljs-comment\"># 上级目录的shared子目录</span><br><span class=\"hljs-keyword\">include</span> /usr/local/<span class=\"hljs-keyword\">include</span>/make/*.mk  <span class=\"hljs-comment\"># 绝对路径</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"使用字符集\"><a href=\"#使用字符集\" class=\"headerlink\" title=\"使用字符集[]\"></a>使用字符集[]</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># [] 用于匹配字符集中的任意一个字符</span><br><span class=\"hljs-keyword\">include</span> make[123].mk     <span class=\"hljs-comment\"># 匹配make1.mk, make2.mk, make3.mk</span><br><span class=\"hljs-keyword\">include</span> test[a-z].mk     <span class=\"hljs-comment\"># 匹配testa.mk到testz.mk</span><br><span class=\"hljs-keyword\">include</span> config[0-9].mk   <span class=\"hljs-comment\"># 匹配config0.mk到config9.mk</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 默认情况下，如果include的文件不存在，make会报错</span><br><br><span class=\"hljs-comment\"># 使用-include或sinclude可以忽略文件不存在的错误</span><br><span class=\"hljs-keyword\">-include</span> optional.mk     <span class=\"hljs-comment\"># 如果文件不存在，继续执行不报错</span><br><span class=\"hljs-keyword\">sinclude</span> optional.mk     <span class=\"hljs-comment\"># 与-include完全相同</span><br><br><span class=\"hljs-comment\"># 多个可选文件</span><br><span class=\"hljs-keyword\">-include</span> config/*.mk     <span class=\"hljs-comment\"># 如果config目录下有任何.mk文件不存在，继续执行</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"组合使用示例\"><a href=\"#组合使用示例\" class=\"headerlink\" title=\"组合使用示例\"></a>组合使用示例</h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 可以组合使用多种模式</span><br><span class=\"hljs-keyword\">include</span> config.mk \\<br>        rules/*.mk \\<br>        test[0-9].mk \\<br>        ./build/**/*.mk<br><br><span class=\"hljs-comment\"># 使用变量</span><br>INCLUDE_DIR = ./includes<br><span class=\"hljs-keyword\">include</span> <span class=\"hljs-variable\">$(INCLUDE_DIR)</span>/*.mk<br><br><span class=\"hljs-comment\"># 条件包含</span><br><span class=\"hljs-keyword\">ifdef</span> CUSTOM_RULES<br>    <span class=\"hljs-keyword\">include</span> <span class=\"hljs-variable\">$(CUSTOM_RULES)</span><br><span class=\"hljs-keyword\">endif</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"make的工作方式\"><a href=\"#make的工作方式\" class=\"headerlink\" title=\"make的工作方式\"></a>make的工作方式</h2><ol>\n<li>读取所有的<code>Makefile</code>;</li>\n<li>读取<code>include</code>涉及的<code>Makefile</code>文件;</li>\n<li>初始化文件当中的<strong>变量</strong>;</li>\n<li>推导<strong>隐式规则</strong>并分析所有规则;</li>\n<li>为目标文件创建依赖关系链;</li>\n<li>根据依赖关系, 决定需要重新生成的文件;</li>\n<li>执行生成命令.</li>\n</ol>\n<h2 id=\"文件搜寻\"><a href=\"#文件搜寻\" class=\"headerlink\" title=\"文件搜寻\"></a>文件搜寻</h2><h3 id=\"VPATH\"><a href=\"#VPATH\" class=\"headerlink\" title=\"VPATH\"></a>VPATH</h3><p>默认情况下, <code>make</code>会在当前目录和所有子目录下寻找依赖文件和目标文件.<br>为了能够在较大工程中扩大<code>make</code>的搜索范围, 我们可以通过特殊变量<code>VPATH</code>来指定搜索路径.</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">VPATH = src:../headers<br></code></pre></td></tr></table></figure>\n<ol>\n<li>不同的目录之间由<code>:</code>分隔, 上述定义指定了额外的<code>src</code>以及<code>../headers</code>目录;</li>\n<li>当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中<strong>从左到右</strong>继续寻找.</li>\n</ol>\n<h3 id=\"vpath\"><a href=\"#vpath\" class=\"headerlink\" title=\"vpath\"></a>vpath</h3><p>上述的<code>VPATH</code>指定了全局文件的搜索路径, 而<code>vpath</code>允许为<strong>不同类型</strong>的文件指定不同的搜索路径.</p>\n<p><strong>语法</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 1. 为指定模式的文件设置搜索路径</span><br><span class=\"hljs-keyword\">vpath</span> pattern directory1:directory2<br><br><span class=\"hljs-comment\"># 2. 清除指定模式的搜索路径</span><br><span class=\"hljs-keyword\">vpath</span> pattern<br><br><span class=\"hljs-comment\"># 3. 清除所有已设置的 vpath</span><br><span class=\"hljs-keyword\">vpath</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>特点</strong></p>\n<ul>\n<li>可以为不同类型的文件指定不同的搜索路径;</li>\n<li>支持使用 <code>%</code> 通配符匹配文件名;</li>\n<li>可以有多条 vpath 指令, 且针对相同模式的命令将会起到<strong>附加</strong>而非覆盖的作用.</li>\n</ul>\n<p><strong>e.g.</strong><br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 定义编译器</span><br>CC = gcc<br><br><span class=\"hljs-keyword\">vpath</span> %.h <span class=\"hljs-keyword\">include</span><br><span class=\"hljs-keyword\">vpath</span> %.c src<br><span class=\"hljs-keyword\">vpath</span> %.o build<br><span class=\"hljs-keyword\">vpath</span> %.a lib<br><br><span class=\"hljs-section\">program: main.o utils.o</span><br>    <span class=\"hljs-variable\">$(CC)</span> -o program main.o utils.o -L. -lmylib<br><br><span class=\"hljs-section\">main.o: main.c project.h</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c main.c<br><br><span class=\"hljs-section\">utils.o: utils.c utils.h</span><br>    <span class=\"hljs-variable\">$(CC)</span> -c utils.c<br></code></pre></td></tr></table></figure></p>\n<hr>\n<p><code>vpath</code>的指令必须都写在<code>Makefile</code>当中, 在<code>Make</code>解析<code>Makefile</code>文件时被处理, 例如:<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\"><span class=\"hljs-comment\"># 如果需要清理 .o 文件的搜索路径并重新设置</span><br><span class=\"hljs-section\">clean-paths:</span><br>\t<span class=\"hljs-comment\"># 清除 .o 文件的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.o<br>\t<span class=\"hljs-comment\"># 设置新的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.o new/build<br><br><span class=\"hljs-comment\"># 如果需要完全重置所有搜索路径</span><br><span class=\"hljs-section\">reset-paths:</span><br>\t<span class=\"hljs-comment\"># 清除所有 vpath 设置</span><br>\t<span class=\"hljs-keyword\">vpath</span><br>\t<span class=\"hljs-comment\"># 重新设置所需的搜索路径</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.h <span class=\"hljs-keyword\">include</span><br>\t<span class=\"hljs-keyword\">vpath</span> %.c src<br>\t<span class=\"hljs-keyword\">vpath</span> %.o build<br></code></pre></td></tr></table></figure><br>在终端中对应的指令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make              <span class=\"hljs-comment\"># 使用默认搜索路径编译</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make clean-paths  <span class=\"hljs-comment\"># 执行搜索路径清理和重设</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">make reset-paths  <span class=\"hljs-comment\"># 重置所有搜索路径</span></span><br></code></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>优先级</strong>: 当前目录 &gt; <code>vpath</code> &gt; <code>VPATH</code>. </p>\n"},{"title":"React 主题切换实现：从基础到实践","date":"2025-01-23T02:06:34.000Z","excerpt":"通过CSS变量和上下文管理, 以React框架为例介绍主题的变色设置.","math":true,"index_img":"/img/闪光拉姆.jpg","_content":"$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个\"环境变量\", 且`index.css`中的 CSS 应随这个\"环境变量\"而改变。\n\n要实现这个需求,我们需要解决以下几个问题：\n\n1. 如何定义和管理这个\"环境变量\"？\n2. 组件如何控制这个变量？\n3. CSS 如何响应变量的变化？\n\n这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。\n\n## 基础知识\n### Context 的创建和使用\n\n**Context** 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。\n\n```tsx\n// 创建 Context\nconst ThemeContext = createContext<ThemeType | undefined>(undefined);\n\n// 提供 Context\nconst ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\n// 使用 Context\nconst ChildComponent = () => {\n  const { theme } = useContext(ThemeContext);\n  return <div>Current theme: {theme}</div>;\n};\n```\n因此, 我们可以在`src/context/`目录下创建一个`ThemeContext`来定义和管理相关上下文.\n- 在其中利用`useState`定义主题反转的函数;\n- 在点击按钮组件中使用上述的函数,\n\n### CSS 变量\n\nCSS 变量(也称为自定义属性)允许我们定义可重用的值：\n\n```css\n/* 定义变量 */\n:root {\n  --primary-color: #007bff;\n}\n\n/* 使用变量 */\n.button {\n  background-color: var(--primary-color);\n}\n```\n1. 为了区分CSS的变量与常量, `--xx-y`的命名格式是CSS变量的规范;\n2. 通过`var(<c--xx-y>)`的形式使用CSS变量.\n\n### HTML data-* 属性\n\n`document.documentElement.setAttribute('data-theme', theme)` 的作用是在 HTML 根元素上设置一个自定义数据属性：\n\n```js\n// JavaScript 设置\ndocument.documentElement.setAttribute('data-theme', 'dark');\n\n// 结果的 HTML\n<html data-theme=\"dark\">\n  ...\n</html>\n\n// 对应的 CSS\n[data-theme='dark'] {\n  --bg-color: #141414;\n}\n```\n\n## 主题切换实现\n\n### 主题变量设计\n\n首先设计主题相关的 CSS 变量：\n\n```css\n:root {\n  /* Light theme variables */\n  --bg-color: #ffffff;\n  --text-color: #000000;\n  --sidebar-bg: #f0f2f5;\n  --border-color: #e5e2e2;\n  --shadow-color: rgba(0, 0, 0, 0.1);\n}\n\n[data-theme='dark'] {\n  --bg-color: #141414;\n  --text-color: #ffffff;\n  --sidebar-bg: #1f1f1f;\n  --border-color: #434343;\n  --shadow-color: rgba(0, 0, 0, 0.3);\n}\n```\n> 可根据实际需要增减CSS变量.\n\n### 主题状态管理\n\n创建主题 Context 进行状态管理：\n\n```typescript\nimport React, { createContext, useState, useContext, useEffect } from 'react';\n\ntype Theme = 'light' | 'dark';\n\ninterface ThemeContextType {\n  theme: Theme;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [theme, setTheme] = useState<Theme>(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return (savedTheme as Theme) || 'light';\n  });\n\n  useEffect(() => {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n```\n\n<br>\n\n在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:\n```html\n<!-- App.tsx -->\nimport { ThemeProvider } from './context/ThemeContext';\n\nfunction App(){\n    ...\n    return (\n        <ThemeProvider>\n            <div className = \"App\">\n                ...\n            </div>\n        </ThemeProvider>\n    )\n}\n\n```\n### 主题切换组件\n\n实现主题切换按钮：\n\n```typescript\nimport React from 'react';\nimport { Tooltip } from 'antd';\nimport { useTheme } from '../context/ThemeContext';\nimport { BsSun, BsMoonStars } from 'react-icons/bs';\nimport styles from './ThemeToggle.module.css';\n\nconst ThemeToggle: React.FC = () => {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <Tooltip title={theme === 'light' ? '切换到暗色模式' : '切换到亮色模式'} placement=\"right\">\n      <button \n        className={styles.themeToggle} \n        onClick={toggleTheme}\n        aria-label=\"Toggle theme\"\n      >\n        {theme === 'light' ? <BsMoonStars /> : <BsSun />}\n      </button>\n    </Tooltip>\n  );\n};\n\nexport default ThemeToggle;\n```\n1. 此处使用`antd`的`Tooltip`, 用于在鼠标悬浮按钮组件时显示文字提示;\n2. `aria-label=\"Toggle theme\"` 在`<button>`内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 \"Toggle theme“.\n\n\n### 组件样式应用\n在组件内部使用CSS变量的方式已经在 [CSS变量](#CSS-变量) 中介绍, 在此给出示例:\n```css\n.sidebar_container {\n    background-color: var(--sidebar-bg);\n    color: var(--text-color);\n}\n\n.icon_button {\n    color: var(--text-color);\n    background-color: transparent;\n}\n\n.icon_button:hover {\n    background-color: var(--sidebar-hover-color);\n}\n```\n\n<br>\n\n如果某个CSS不需要作为变量进行统一管理, 可以直接使用 **属性选择器** 进行单独设置:\n```css\n[data-theme='dark'] .icon_example{\n  --bg-color: #141414;\n}\n``` \n\n## 总结与参考\n通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：\n\n1. 使用 CSS 变量管理主题样式\n2. 通过 Context API 实现状态管理\n3. 利用 data-theme 属性切换主题\n4. 本地存储保持主题持久化\n\n### 参考 🔗\n1. [React Context API](https://react.dev/reference/react/useContext)\n2. [CSS Custom Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties)\n3. [HTML data-* Attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)","source":"_posts/其他/themechange.md","raw":"---\ntitle: React 主题切换实现：从基础到实践\ndate: 2025-01-23 10:06:34\ntags:\ncategories:\nexcerpt: 通过CSS变量和上下文管理, 以React框架为例介绍主题的变色设置.\nmath: true\nindex_img: /img/闪光拉姆.jpg\n---\n$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个\"环境变量\", 且`index.css`中的 CSS 应随这个\"环境变量\"而改变。\n\n要实现这个需求,我们需要解决以下几个问题：\n\n1. 如何定义和管理这个\"环境变量\"？\n2. 组件如何控制这个变量？\n3. CSS 如何响应变量的变化？\n\n这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。\n\n## 基础知识\n### Context 的创建和使用\n\n**Context** 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。\n\n```tsx\n// 创建 Context\nconst ThemeContext = createContext<ThemeType | undefined>(undefined);\n\n// 提供 Context\nconst ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n  \n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\n// 使用 Context\nconst ChildComponent = () => {\n  const { theme } = useContext(ThemeContext);\n  return <div>Current theme: {theme}</div>;\n};\n```\n因此, 我们可以在`src/context/`目录下创建一个`ThemeContext`来定义和管理相关上下文.\n- 在其中利用`useState`定义主题反转的函数;\n- 在点击按钮组件中使用上述的函数,\n\n### CSS 变量\n\nCSS 变量(也称为自定义属性)允许我们定义可重用的值：\n\n```css\n/* 定义变量 */\n:root {\n  --primary-color: #007bff;\n}\n\n/* 使用变量 */\n.button {\n  background-color: var(--primary-color);\n}\n```\n1. 为了区分CSS的变量与常量, `--xx-y`的命名格式是CSS变量的规范;\n2. 通过`var(<c--xx-y>)`的形式使用CSS变量.\n\n### HTML data-* 属性\n\n`document.documentElement.setAttribute('data-theme', theme)` 的作用是在 HTML 根元素上设置一个自定义数据属性：\n\n```js\n// JavaScript 设置\ndocument.documentElement.setAttribute('data-theme', 'dark');\n\n// 结果的 HTML\n<html data-theme=\"dark\">\n  ...\n</html>\n\n// 对应的 CSS\n[data-theme='dark'] {\n  --bg-color: #141414;\n}\n```\n\n## 主题切换实现\n\n### 主题变量设计\n\n首先设计主题相关的 CSS 变量：\n\n```css\n:root {\n  /* Light theme variables */\n  --bg-color: #ffffff;\n  --text-color: #000000;\n  --sidebar-bg: #f0f2f5;\n  --border-color: #e5e2e2;\n  --shadow-color: rgba(0, 0, 0, 0.1);\n}\n\n[data-theme='dark'] {\n  --bg-color: #141414;\n  --text-color: #ffffff;\n  --sidebar-bg: #1f1f1f;\n  --border-color: #434343;\n  --shadow-color: rgba(0, 0, 0, 0.3);\n}\n```\n> 可根据实际需要增减CSS变量.\n\n### 主题状态管理\n\n创建主题 Context 进行状态管理：\n\n```typescript\nimport React, { createContext, useState, useContext, useEffect } from 'react';\n\ntype Theme = 'light' | 'dark';\n\ninterface ThemeContextType {\n  theme: Theme;\n  toggleTheme: () => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [theme, setTheme] = useState<Theme>(() => {\n    const savedTheme = localStorage.getItem('theme');\n    return (savedTheme as Theme) || 'light';\n  });\n\n  useEffect(() => {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n\n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n  }\n  return context;\n};\n```\n\n<br>\n\n在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:\n```html\n<!-- App.tsx -->\nimport { ThemeProvider } from './context/ThemeContext';\n\nfunction App(){\n    ...\n    return (\n        <ThemeProvider>\n            <div className = \"App\">\n                ...\n            </div>\n        </ThemeProvider>\n    )\n}\n\n```\n### 主题切换组件\n\n实现主题切换按钮：\n\n```typescript\nimport React from 'react';\nimport { Tooltip } from 'antd';\nimport { useTheme } from '../context/ThemeContext';\nimport { BsSun, BsMoonStars } from 'react-icons/bs';\nimport styles from './ThemeToggle.module.css';\n\nconst ThemeToggle: React.FC = () => {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <Tooltip title={theme === 'light' ? '切换到暗色模式' : '切换到亮色模式'} placement=\"right\">\n      <button \n        className={styles.themeToggle} \n        onClick={toggleTheme}\n        aria-label=\"Toggle theme\"\n      >\n        {theme === 'light' ? <BsMoonStars /> : <BsSun />}\n      </button>\n    </Tooltip>\n  );\n};\n\nexport default ThemeToggle;\n```\n1. 此处使用`antd`的`Tooltip`, 用于在鼠标悬浮按钮组件时显示文字提示;\n2. `aria-label=\"Toggle theme\"` 在`<button>`内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 \"Toggle theme“.\n\n\n### 组件样式应用\n在组件内部使用CSS变量的方式已经在 [CSS变量](#CSS-变量) 中介绍, 在此给出示例:\n```css\n.sidebar_container {\n    background-color: var(--sidebar-bg);\n    color: var(--text-color);\n}\n\n.icon_button {\n    color: var(--text-color);\n    background-color: transparent;\n}\n\n.icon_button:hover {\n    background-color: var(--sidebar-hover-color);\n}\n```\n\n<br>\n\n如果某个CSS不需要作为变量进行统一管理, 可以直接使用 **属性选择器** 进行单独设置:\n```css\n[data-theme='dark'] .icon_example{\n  --bg-color: #141414;\n}\n``` \n\n## 总结与参考\n通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：\n\n1. 使用 CSS 变量管理主题样式\n2. 通过 Context API 实现状态管理\n3. 利用 data-theme 属性切换主题\n4. 本地存储保持主题持久化\n\n### 参考 🔗\n1. [React Context API](https://react.dev/reference/react/useContext)\n2. [CSS Custom Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties)\n3. [HTML data-* Attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes)","slug":"其他/themechange","published":1,"updated":"2025-02-07T07:48:49.024Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vx000xdwqg6p3dep0e","content":"<p>$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个”环境变量”, 且<code>index.css</code>中的 CSS 应随这个”环境变量”而改变。</p>\n<p>要实现这个需求,我们需要解决以下几个问题：</p>\n<ol>\n<li>如何定义和管理这个”环境变量”？</li>\n<li>组件如何控制这个变量？</li>\n<li>CSS 如何响应变量的变化？</li>\n</ol>\n<p>这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"Context-的创建和使用\"><a href=\"#Context-的创建和使用\" class=\"headerlink\" title=\"Context 的创建和使用\"></a>Context 的创建和使用</h3><p><strong>Context</strong> 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-comment\">// 创建 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeContext</span> = createContext&lt;<span class=\"hljs-title class_\">ThemeType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-comment\">// 提供 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ThemeProvider</span> = (<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [theme, setTheme] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;light&#x27;</span>);<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">theme</span>, <span class=\"hljs-attr\">setTheme</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ChildComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; theme &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">ThemeContext</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Current theme: &#123;theme&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>因此, 我们可以在<code>src/context/</code>目录下创建一个<code>ThemeContext</code>来定义和管理相关上下文.</p>\n<ul>\n<li>在其中利用<code>useState</code>定义主题反转的函数;</li>\n<li>在点击按钮组件中使用上述的函数,</li>\n</ul>\n<h3 id=\"CSS-变量\"><a href=\"#CSS-变量\" class=\"headerlink\" title=\"CSS 变量\"></a>CSS 变量</h3><p>CSS 变量(也称为自定义属性)允许我们定义可重用的值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 定义变量 */</span><br><span class=\"hljs-selector-pseudo\">:root</span> &#123;<br>  <span class=\"hljs-attr\">--primary-color</span>: <span class=\"hljs-number\">#007bff</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用变量 */</span><br><span class=\"hljs-selector-class\">.button</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--primary-color);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>为了区分CSS的变量与常量, <code>--xx-y</code>的命名格式是CSS变量的规范;</li>\n<li>通过<code>var(&lt;c--xx-y&gt;)</code>的形式使用CSS变量.</li>\n</ol>\n<h3 id=\"HTML-data-属性\"><a href=\"#HTML-data-属性\" class=\"headerlink\" title=\"HTML data-* 属性\"></a>HTML data-* 属性</h3><p><code>document.documentElement.setAttribute(&#39;data-theme&#39;, theme)</code> 的作用是在 HTML 根元素上设置一个自定义数据属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// JavaScript 设置</span><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;data-theme&#x27;</span>, <span class=\"hljs-string\">&#x27;dark&#x27;</span>);<br><br><span class=\"hljs-comment\">// 结果的 HTML</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">data-theme</span>=<span class=\"hljs-string\">&quot;dark&quot;</span>&gt;</span></span><br><span class=\"language-xml\">  ...</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span><br><br><span class=\"hljs-comment\">// 对应的 CSS</span><br>[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>] &#123;<br>  --bg-<span class=\"hljs-attr\">color</span>: #<span class=\"hljs-number\">141414</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"主题切换实现\"><a href=\"#主题切换实现\" class=\"headerlink\" title=\"主题切换实现\"></a>主题切换实现</h2><h3 id=\"主题变量设计\"><a href=\"#主题变量设计\" class=\"headerlink\" title=\"主题变量设计\"></a>主题变量设计</h3><p>首先设计主题相关的 CSS 变量：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-pseudo\">:root</span> &#123;<br>  <span class=\"hljs-comment\">/* Light theme variables */</span><br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#ffffff</span>;<br>  <span class=\"hljs-attr\">--text-color</span>: <span class=\"hljs-number\">#000000</span>;<br>  <span class=\"hljs-attr\">--sidebar-bg</span>: <span class=\"hljs-number\">#f0f2f5</span>;<br>  <span class=\"hljs-attr\">--border-color</span>: <span class=\"hljs-number\">#e5e2e2</span>;<br>  <span class=\"hljs-attr\">--shadow-color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.1</span>);<br>&#125;<br><br><span class=\"hljs-selector-attr\">[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>]</span> &#123;<br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#141414</span>;<br>  <span class=\"hljs-attr\">--text-color</span>: <span class=\"hljs-number\">#ffffff</span>;<br>  <span class=\"hljs-attr\">--sidebar-bg</span>: <span class=\"hljs-number\">#1f1f1f</span>;<br>  <span class=\"hljs-attr\">--border-color</span>: <span class=\"hljs-number\">#434343</span>;<br>  <span class=\"hljs-attr\">--shadow-color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>可根据实际需要增减CSS变量.</p>\n</blockquote>\n<h3 id=\"主题状态管理\"><a href=\"#主题状态管理\" class=\"headerlink\" title=\"主题状态管理\"></a>主题状态管理</h3><p>创建主题 Context 进行状态管理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; createContext, useState, useContext, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Theme</span> = <span class=\"hljs-string\">&#x27;light&#x27;</span> | <span class=\"hljs-string\">&#x27;dark&#x27;</span>;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ThemeContextType</span> &#123;<br>  <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-title class_\">Theme</span>;<br>  <span class=\"hljs-attr\">toggleTheme</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeContext</span> = createContext&lt;<span class=\"hljs-title class_\">ThemeContextType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeProvider</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&lt;&#123; <span class=\"hljs-attr\">children</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">ReactNode</span> &#125;&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [theme, setTheme] = useState&lt;<span class=\"hljs-title class_\">Theme</span>&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> savedTheme = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;theme&#x27;</span>);<br>    <span class=\"hljs-keyword\">return</span> (savedTheme <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Theme</span>) || <span class=\"hljs-string\">&#x27;light&#x27;</span>;<br>  &#125;);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;data-theme&#x27;</span>, theme);<br>    <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-string\">&#x27;theme&#x27;</span>, theme);<br>  &#125;, [theme]);<br><br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggleTheme</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setTheme</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prev</span> =&gt;</span> prev === <span class=\"hljs-string\">&#x27;light&#x27;</span> ? <span class=\"hljs-string\">&#x27;dark&#x27;</span> : <span class=\"hljs-string\">&#x27;light&#x27;</span>);<br>  &#125;;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">theme</span>, <span class=\"hljs-attr\">toggleTheme</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useTheme</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">ThemeContext</span>);<br>  <span class=\"hljs-keyword\">if</span> (context === <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;useTheme must be used within a ThemeProvider&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><br></p>\n<p>在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- App.tsx --&gt;</span><br>import &#123; ThemeProvider &#125; from &#x27;./context/ThemeContext&#x27;;<br><br>function App()&#123;<br>    ...<br>    return (<br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeProvider</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span> = <span class=\"hljs-string\">&quot;App&quot;</span>&gt;</span><br>                ...<br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeProvider</span>&gt;</span><br>    )<br>&#125;<br><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"主题切换组件\"><a href=\"#主题切换组件\" class=\"headerlink\" title=\"主题切换组件\"></a>主题切换组件</h3><p>实现主题切换按钮：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Tooltip</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;antd&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useTheme &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../context/ThemeContext&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">BsSun</span>, <span class=\"hljs-title class_\">BsMoonStars</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-icons/bs&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./ThemeToggle.module.css&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeToggle</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; theme, toggleTheme &#125; = <span class=\"hljs-title function_\">useTheme</span>();<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tooltip</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&#123;theme</span> === <span class=\"hljs-string\">&#x27;light&#x27;</span> ? &#x27;<span class=\"hljs-attr\">切换到暗色模式</span>&#x27; <span class=\"hljs-attr\">:</span> &#x27;<span class=\"hljs-attr\">切换到亮色模式</span>&#x27;&#125; <span class=\"hljs-attr\">placement</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> </span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&#123;styles.themeToggle&#125;</span> </span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;toggleTheme&#125;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">&quot;Toggle theme&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &gt;</span></span><br><span class=\"language-xml\">        &#123;theme === &#x27;light&#x27; ? <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BsMoonStars</span> /&gt;</span> : <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BsSun</span> /&gt;</span>&#125;</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tooltip</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ThemeToggle</span>;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>此处使用<code>antd</code>的<code>Tooltip</code>, 用于在鼠标悬浮按钮组件时显示文字提示;</li>\n<li><code>aria-label=&quot;Toggle theme&quot;</code> 在<code>&lt;button&gt;</code>内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 “Toggle theme“.</li>\n</ol>\n<h3 id=\"组件样式应用\"><a href=\"#组件样式应用\" class=\"headerlink\" title=\"组件样式应用\"></a>组件样式应用</h3><p>在组件内部使用CSS变量的方式已经在 <a href=\"#CSS-变量\">CSS变量</a> 中介绍, 在此给出示例:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.sidebar_container</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--sidebar-bg);<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--text-color);<br>&#125;<br><br><span class=\"hljs-selector-class\">.icon_button</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--text-color);<br>    <span class=\"hljs-attribute\">background-color</span>: transparent;<br>&#125;<br><br><span class=\"hljs-selector-class\">.icon_button</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--sidebar-hover-color);<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>如果某个CSS不需要作为变量进行统一管理, 可以直接使用 <strong>属性选择器</strong> 进行单独设置:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>]</span> <span class=\"hljs-selector-class\">.icon_example</span>&#123;<br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#141414</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"总结与参考\"><a href=\"#总结与参考\" class=\"headerlink\" title=\"总结与参考\"></a>总结与参考</h2><p>通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：</p>\n<ol>\n<li>使用 CSS 变量管理主题样式</li>\n<li>通过 Context API 实现状态管理</li>\n<li>利用 data-theme 属性切换主题</li>\n<li>本地存储保持主题持久化</li>\n</ol>\n<h3 id=\"参考-🔗\"><a href=\"#参考-🔗\" class=\"headerlink\" title=\"参考 🔗\"></a>参考 🔗</h3><ol>\n<li><a href=\"https://react.dev/reference/react/useContext\">React Context API</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\">CSS Custom Properties</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes\">HTML data-* Attributes</a></li>\n</ol>\n","more":"<p>$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个”环境变量”, 且<code>index.css</code>中的 CSS 应随这个”环境变量”而改变。</p>\n<p>要实现这个需求,我们需要解决以下几个问题：</p>\n<ol>\n<li>如何定义和管理这个”环境变量”？</li>\n<li>组件如何控制这个变量？</li>\n<li>CSS 如何响应变量的变化？</li>\n</ol>\n<p>这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"Context-的创建和使用\"><a href=\"#Context-的创建和使用\" class=\"headerlink\" title=\"Context 的创建和使用\"></a>Context 的创建和使用</h3><p><strong>Context</strong> 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tsx\"><span class=\"hljs-comment\">// 创建 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeContext</span> = createContext&lt;<span class=\"hljs-title class_\">ThemeType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-comment\">// 提供 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ThemeProvider</span> = (<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [theme, setTheme] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;light&#x27;</span>);<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">theme</span>, <span class=\"hljs-attr\">setTheme</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用 Context</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ChildComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; theme &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">ThemeContext</span>);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Current theme: &#123;theme&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>因此, 我们可以在<code>src/context/</code>目录下创建一个<code>ThemeContext</code>来定义和管理相关上下文.</p>\n<ul>\n<li>在其中利用<code>useState</code>定义主题反转的函数;</li>\n<li>在点击按钮组件中使用上述的函数,</li>\n</ul>\n<h3 id=\"CSS-变量\"><a href=\"#CSS-变量\" class=\"headerlink\" title=\"CSS 变量\"></a>CSS 变量</h3><p>CSS 变量(也称为自定义属性)允许我们定义可重用的值：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 定义变量 */</span><br><span class=\"hljs-selector-pseudo\">:root</span> &#123;<br>  <span class=\"hljs-attr\">--primary-color</span>: <span class=\"hljs-number\">#007bff</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/* 使用变量 */</span><br><span class=\"hljs-selector-class\">.button</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--primary-color);<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>为了区分CSS的变量与常量, <code>--xx-y</code>的命名格式是CSS变量的规范;</li>\n<li>通过<code>var(&lt;c--xx-y&gt;)</code>的形式使用CSS变量.</li>\n</ol>\n<h3 id=\"HTML-data-属性\"><a href=\"#HTML-data-属性\" class=\"headerlink\" title=\"HTML data-* 属性\"></a>HTML data-* 属性</h3><p><code>document.documentElement.setAttribute(&#39;data-theme&#39;, theme)</code> 的作用是在 HTML 根元素上设置一个自定义数据属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// JavaScript 设置</span><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;data-theme&#x27;</span>, <span class=\"hljs-string\">&#x27;dark&#x27;</span>);<br><br><span class=\"hljs-comment\">// 结果的 HTML</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">data-theme</span>=<span class=\"hljs-string\">&quot;dark&quot;</span>&gt;</span></span><br><span class=\"language-xml\">  ...</span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span><br><br><span class=\"hljs-comment\">// 对应的 CSS</span><br>[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>] &#123;<br>  --bg-<span class=\"hljs-attr\">color</span>: #<span class=\"hljs-number\">141414</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"主题切换实现\"><a href=\"#主题切换实现\" class=\"headerlink\" title=\"主题切换实现\"></a>主题切换实现</h2><h3 id=\"主题变量设计\"><a href=\"#主题变量设计\" class=\"headerlink\" title=\"主题变量设计\"></a>主题变量设计</h3><p>首先设计主题相关的 CSS 变量：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-pseudo\">:root</span> &#123;<br>  <span class=\"hljs-comment\">/* Light theme variables */</span><br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#ffffff</span>;<br>  <span class=\"hljs-attr\">--text-color</span>: <span class=\"hljs-number\">#000000</span>;<br>  <span class=\"hljs-attr\">--sidebar-bg</span>: <span class=\"hljs-number\">#f0f2f5</span>;<br>  <span class=\"hljs-attr\">--border-color</span>: <span class=\"hljs-number\">#e5e2e2</span>;<br>  <span class=\"hljs-attr\">--shadow-color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.1</span>);<br>&#125;<br><br><span class=\"hljs-selector-attr\">[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>]</span> &#123;<br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#141414</span>;<br>  <span class=\"hljs-attr\">--text-color</span>: <span class=\"hljs-number\">#ffffff</span>;<br>  <span class=\"hljs-attr\">--sidebar-bg</span>: <span class=\"hljs-number\">#1f1f1f</span>;<br>  <span class=\"hljs-attr\">--border-color</span>: <span class=\"hljs-number\">#434343</span>;<br>  <span class=\"hljs-attr\">--shadow-color</span>: <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>可根据实际需要增减CSS变量.</p>\n</blockquote>\n<h3 id=\"主题状态管理\"><a href=\"#主题状态管理\" class=\"headerlink\" title=\"主题状态管理\"></a>主题状态管理</h3><p>创建主题 Context 进行状态管理：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; createContext, useState, useContext, useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><br><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Theme</span> = <span class=\"hljs-string\">&#x27;light&#x27;</span> | <span class=\"hljs-string\">&#x27;dark&#x27;</span>;<br><br><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ThemeContextType</span> &#123;<br>  <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-title class_\">Theme</span>;<br>  <span class=\"hljs-attr\">toggleTheme</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-built_in\">void</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeContext</span> = createContext&lt;<span class=\"hljs-title class_\">ThemeContextType</span> | <span class=\"hljs-literal\">undefined</span>&gt;(<span class=\"hljs-literal\">undefined</span>);<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeProvider</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span>&lt;&#123; <span class=\"hljs-attr\">children</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">ReactNode</span> &#125;&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; children &#125;</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> [theme, setTheme] = useState&lt;<span class=\"hljs-title class_\">Theme</span>&gt;(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> savedTheme = <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">getItem</span>(<span class=\"hljs-string\">&#x27;theme&#x27;</span>);<br>    <span class=\"hljs-keyword\">return</span> (savedTheme <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Theme</span>) || <span class=\"hljs-string\">&#x27;light&#x27;</span>;<br>  &#125;);<br><br>  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">documentElement</span>.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;data-theme&#x27;</span>, theme);<br>    <span class=\"hljs-variable language_\">localStorage</span>.<span class=\"hljs-title function_\">setItem</span>(<span class=\"hljs-string\">&#x27;theme&#x27;</span>, theme);<br>  &#125;, [theme]);<br><br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">toggleTheme</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-title function_\">setTheme</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">prev</span> =&gt;</span> prev === <span class=\"hljs-string\">&#x27;light&#x27;</span> ? <span class=\"hljs-string\">&#x27;dark&#x27;</span> : <span class=\"hljs-string\">&#x27;light&#x27;</span>);<br>  &#125;;<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">theme</span>, <span class=\"hljs-attr\">toggleTheme</span> &#125;&#125;&gt;</span></span><br><span class=\"language-xml\">      &#123;children&#125;</span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">useTheme</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">ThemeContext</span>);<br>  <span class=\"hljs-keyword\">if</span> (context === <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;useTheme must be used within a ThemeProvider&#x27;</span>);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> context;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><br></p>\n<p>在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- App.tsx --&gt;</span><br>import &#123; ThemeProvider &#125; from &#x27;./context/ThemeContext&#x27;;<br><br>function App()&#123;<br>    ...<br>    return (<br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ThemeProvider</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span> = <span class=\"hljs-string\">&quot;App&quot;</span>&gt;</span><br>                ...<br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ThemeProvider</span>&gt;</span><br>    )<br>&#125;<br><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"主题切换组件\"><a href=\"#主题切换组件\" class=\"headerlink\" title=\"主题切换组件\"></a>主题切换组件</h3><p>实现主题切换按钮：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Tooltip</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;antd&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useTheme &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../context/ThemeContext&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">BsSun</span>, <span class=\"hljs-title class_\">BsMoonStars</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-icons/bs&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./ThemeToggle.module.css&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ThemeToggle</span>: <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">FC</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; theme, toggleTheme &#125; = <span class=\"hljs-title function_\">useTheme</span>();<br><br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Tooltip</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&#123;theme</span> === <span class=\"hljs-string\">&#x27;light&#x27;</span> ? &#x27;<span class=\"hljs-attr\">切换到暗色模式</span>&#x27; <span class=\"hljs-attr\">:</span> &#x27;<span class=\"hljs-attr\">切换到亮色模式</span>&#x27;&#125; <span class=\"hljs-attr\">placement</span>=<span class=\"hljs-string\">&quot;right&quot;</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> </span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&#123;styles.themeToggle&#125;</span> </span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;toggleTheme&#125;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">        <span class=\"hljs-attr\">aria-label</span>=<span class=\"hljs-string\">&quot;Toggle theme&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">      &gt;</span></span><br><span class=\"language-xml\">        &#123;theme === &#x27;light&#x27; ? <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BsMoonStars</span> /&gt;</span> : <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BsSun</span> /&gt;</span>&#125;</span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Tooltip</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ThemeToggle</span>;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>此处使用<code>antd</code>的<code>Tooltip</code>, 用于在鼠标悬浮按钮组件时显示文字提示;</li>\n<li><code>aria-label=&quot;Toggle theme&quot;</code> 在<code>&lt;button&gt;</code>内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 “Toggle theme“.</li>\n</ol>\n<h3 id=\"组件样式应用\"><a href=\"#组件样式应用\" class=\"headerlink\" title=\"组件样式应用\"></a>组件样式应用</h3><p>在组件内部使用CSS变量的方式已经在 <a href=\"#CSS-变量\">CSS变量</a> 中介绍, 在此给出示例:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.sidebar_container</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--sidebar-bg);<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--text-color);<br>&#125;<br><br><span class=\"hljs-selector-class\">.icon_button</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">var</span>(--text-color);<br>    <span class=\"hljs-attribute\">background-color</span>: transparent;<br>&#125;<br><br><span class=\"hljs-selector-class\">.icon_button</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>    <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">var</span>(--sidebar-hover-color);<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>如果某个CSS不需要作为变量进行统一管理, 可以直接使用 <strong>属性选择器</strong> 进行单独设置:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[data-theme=<span class=\"hljs-string\">&#x27;dark&#x27;</span>]</span> <span class=\"hljs-selector-class\">.icon_example</span>&#123;<br>  <span class=\"hljs-attr\">--bg-color</span>: <span class=\"hljs-number\">#141414</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"总结与参考\"><a href=\"#总结与参考\" class=\"headerlink\" title=\"总结与参考\"></a>总结与参考</h2><p>通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：</p>\n<ol>\n<li>使用 CSS 变量管理主题样式</li>\n<li>通过 Context API 实现状态管理</li>\n<li>利用 data-theme 属性切换主题</li>\n<li>本地存储保持主题持久化</li>\n</ol>\n<h3 id=\"参考-🔗\"><a href=\"#参考-🔗\" class=\"headerlink\" title=\"参考 🔗\"></a>参考 🔗</h3><ol>\n<li><a href=\"https://react.dev/reference/react/useContext\">React Context API</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties\">CSS Custom Properties</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes\">HTML data-* Attributes</a></li>\n</ol>\n"},{"title":"媒体查询","date":"2025-01-08T11:16:49.000Z","excerpt":"利用媒体查询建立响应式的设计","index_img":"/img/Aniya_放大镜.jpg","_content":"> [媒体查询入门指南](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Media_queries)\n> [使用编程方法测试媒体查询](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries)\n\n# 媒体查询入门\n对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.\n\n媒体查询的范式:\n```css\n@media media-type and (media-feature) {\n    /*css rules*/\n}\n```\n> 1. 媒体类型用于声明css文件被用作什么类型的媒体;\n> 2. 媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;\n> 3. 通过测试且符合媒体类型的情况下应用内部的CSS样式.\n\n**media-type**: all, print, screen, speech.\n\n## 媒体特征\n### 屏幕尺寸\n使用`min`,`max`在一定的数值范围内启用当前的CSS样式.\n> 如果去掉前缀, 将仅在恰好为当前数值中启用.\n```css\n/* 启用宽度大于或等于600px的屏幕 */\n@media screen and (max-width: 600px){\n    ...\n}\n\n/* 启用宽度小于或等于600px的屏幕 */\n@media screen and (min-width: 600px){\n    ...\n}\n\n/* 窗口恰好等于600px时 */\n@media screen and (width: 600px) {\n    ...\n}\n```\n\n### 朝向\n`orientation`可以检测设备的方向, 如竖屏或横屏.\n```css\n@media screen and (orientation: portrait) {\n    /* 竖放时的CSS样式 */\n}\n@media screen and (orientation: landscape) {\n    /* 横屏时的CSS样式 */\n}\n```\n\n## 更复杂的媒体查询\n- `and`实现与逻辑:\n```css\n@media screen and (min-width: 400px) and (orientation: landscape) {\n  body {\n    color: blue;\n  }\n}\n```\n\n- `,`实现或逻辑:\n```css\n@media (min-width: 768px) and (orientation: landscape), (max-width: 480px) {\n  /* \n  (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)\n  */\n}\n```\n> 与C中的`&`和`|`类似, 与的优先级更高, 先将`and`的条件进行判断, 然后视作整体.\n\n- `not`实现非逻辑:\n```css\n@media not all and (orientation: landscape) {\n/* 非全部屏幕且屏幕方向为横向 */\n}\n```\n\n- `not`实现 **反转查询**:\n> 与最近的`and`组合所绑定, 注意优先级\n\n```css\n@media not screen and (color), print and (color) { ... }\n```\n`,`将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:\n```css\n@media (not (screen and (color))), print and (color) { ... }\n```\n\n\n---\n\n# 利用查询结果扩展设计\n上述在CSS中利用`@media`可以实现响应式的设计, 如果我们希望在js/ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.\n\n- 使用`window.matchMedia()`方法存放媒体查询结果:\n```js\n// 检测设备的旋转方向是否为纵向\nvar mediaQueryList = window.matchMedia(\"(orientation: portrait)\");\n```\n\n- 检查属性`matches`获取对应的查询结果:\n```css\nif (mediaQueryList.matches) {\n  /* 设备的旋转方向为纵向 portrait */\n} else {\n  /* 设备的旋转方向不是纵向，也就是横向 landscape */\n}\n```\n\n- 通过`addListener()`方法注册监听器, 持续监听查询列表的结果\n```ts\n// 定义媒体查询字符串\nconst mediaQueryString: string = \"(orientation: portrait)\";\n\n// 创建查询列表\nconst mediaQueryList: MediaQueryList = window.matchMedia(mediaQueryString);\n\n// 定义回调函数，使用 MediaQueryListEvent 类型\nfunction handleOrientationChange(event: MediaQueryListEvent): void {\n  if (event.matches) {\n    // 媒体查询匹配（竖屏）\n    console.log(\"Orientation changed to portrait\");\n    // 在这里执行竖屏时的逻辑\n  } else {\n    // 媒体查询不匹配（横屏）\n    console.log(\"Orientation changed to landscape\");\n    // 在这里执行横屏时的逻辑\n  }\n}\n\n// 先运行一次回调函数，传入 MediaQueryList 对象\nhandleOrientationChange({\n    matches: mediaQueryList.matches,\n    media: mediaQueryList.media,\n    type: 'change',\n} as MediaQueryListEvent);\n\n// 为查询列表注册监听器，同时将回调函数传给监听器\nmediaQueryList.addEventListener('change', handleOrientationChange);\n\n// (可选) 在组件卸载时或不再需要监听时，移除事件监听器\n// mediaQueryList.removeEventListener('change', handleOrientationChange);\n```\n\n","source":"_posts/其他/媒体查询.md","raw":"---\ntitle: 媒体查询\ndate: 2025-01-08 19:16:49\ncategories: 学习笔记\ntags: \n- 前端\n- CSS\nexcerpt: 利用媒体查询建立响应式的设计\nindex_img: /img/Aniya_放大镜.jpg\n---\n> [媒体查询入门指南](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Media_queries)\n> [使用编程方法测试媒体查询](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries)\n\n# 媒体查询入门\n对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.\n\n媒体查询的范式:\n```css\n@media media-type and (media-feature) {\n    /*css rules*/\n}\n```\n> 1. 媒体类型用于声明css文件被用作什么类型的媒体;\n> 2. 媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;\n> 3. 通过测试且符合媒体类型的情况下应用内部的CSS样式.\n\n**media-type**: all, print, screen, speech.\n\n## 媒体特征\n### 屏幕尺寸\n使用`min`,`max`在一定的数值范围内启用当前的CSS样式.\n> 如果去掉前缀, 将仅在恰好为当前数值中启用.\n```css\n/* 启用宽度大于或等于600px的屏幕 */\n@media screen and (max-width: 600px){\n    ...\n}\n\n/* 启用宽度小于或等于600px的屏幕 */\n@media screen and (min-width: 600px){\n    ...\n}\n\n/* 窗口恰好等于600px时 */\n@media screen and (width: 600px) {\n    ...\n}\n```\n\n### 朝向\n`orientation`可以检测设备的方向, 如竖屏或横屏.\n```css\n@media screen and (orientation: portrait) {\n    /* 竖放时的CSS样式 */\n}\n@media screen and (orientation: landscape) {\n    /* 横屏时的CSS样式 */\n}\n```\n\n## 更复杂的媒体查询\n- `and`实现与逻辑:\n```css\n@media screen and (min-width: 400px) and (orientation: landscape) {\n  body {\n    color: blue;\n  }\n}\n```\n\n- `,`实现或逻辑:\n```css\n@media (min-width: 768px) and (orientation: landscape), (max-width: 480px) {\n  /* \n  (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)\n  */\n}\n```\n> 与C中的`&`和`|`类似, 与的优先级更高, 先将`and`的条件进行判断, 然后视作整体.\n\n- `not`实现非逻辑:\n```css\n@media not all and (orientation: landscape) {\n/* 非全部屏幕且屏幕方向为横向 */\n}\n```\n\n- `not`实现 **反转查询**:\n> 与最近的`and`组合所绑定, 注意优先级\n\n```css\n@media not screen and (color), print and (color) { ... }\n```\n`,`将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:\n```css\n@media (not (screen and (color))), print and (color) { ... }\n```\n\n\n---\n\n# 利用查询结果扩展设计\n上述在CSS中利用`@media`可以实现响应式的设计, 如果我们希望在js/ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.\n\n- 使用`window.matchMedia()`方法存放媒体查询结果:\n```js\n// 检测设备的旋转方向是否为纵向\nvar mediaQueryList = window.matchMedia(\"(orientation: portrait)\");\n```\n\n- 检查属性`matches`获取对应的查询结果:\n```css\nif (mediaQueryList.matches) {\n  /* 设备的旋转方向为纵向 portrait */\n} else {\n  /* 设备的旋转方向不是纵向，也就是横向 landscape */\n}\n```\n\n- 通过`addListener()`方法注册监听器, 持续监听查询列表的结果\n```ts\n// 定义媒体查询字符串\nconst mediaQueryString: string = \"(orientation: portrait)\";\n\n// 创建查询列表\nconst mediaQueryList: MediaQueryList = window.matchMedia(mediaQueryString);\n\n// 定义回调函数，使用 MediaQueryListEvent 类型\nfunction handleOrientationChange(event: MediaQueryListEvent): void {\n  if (event.matches) {\n    // 媒体查询匹配（竖屏）\n    console.log(\"Orientation changed to portrait\");\n    // 在这里执行竖屏时的逻辑\n  } else {\n    // 媒体查询不匹配（横屏）\n    console.log(\"Orientation changed to landscape\");\n    // 在这里执行横屏时的逻辑\n  }\n}\n\n// 先运行一次回调函数，传入 MediaQueryList 对象\nhandleOrientationChange({\n    matches: mediaQueryList.matches,\n    media: mediaQueryList.media,\n    type: 'change',\n} as MediaQueryListEvent);\n\n// 为查询列表注册监听器，同时将回调函数传给监听器\nmediaQueryList.addEventListener('change', handleOrientationChange);\n\n// (可选) 在组件卸载时或不再需要监听时，移除事件监听器\n// mediaQueryList.removeEventListener('change', handleOrientationChange);\n```\n\n","slug":"其他/媒体查询","published":1,"updated":"2025-01-19T11:46:34.125Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vy0010dwqgep7z2dyf","content":"<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Media_queries\">媒体查询入门指南</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries\">使用编程方法测试媒体查询</a></p>\n</blockquote>\n<h1 id=\"媒体查询入门\"><a href=\"#媒体查询入门\" class=\"headerlink\" title=\"媒体查询入门\"></a>媒体查询入门</h1><p>对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.</p>\n<p>媒体查询的范式:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> media-type <span class=\"hljs-keyword\">and</span> (media-feature) &#123;<br>    <span class=\"hljs-comment\">/*css rules*/</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>媒体类型用于声明css文件被用作什么类型的媒体;</li>\n<li>媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;</li>\n<li>通过测试且符合媒体类型的情况下应用内部的CSS样式.</li>\n</ol>\n</blockquote>\n<p><strong>media-type</strong>: all, print, screen, speech.</p>\n<h2 id=\"媒体特征\"><a href=\"#媒体特征\" class=\"headerlink\" title=\"媒体特征\"></a>媒体特征</h2><h3 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h3><p>使用<code>min</code>,<code>max</code>在一定的数值范围内启用当前的CSS样式.</p>\n<blockquote>\n<p>如果去掉前缀, 将仅在恰好为当前数值中启用.<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 启用宽度大于或等于600px的屏幕 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class=\"hljs-comment\">/* 启用宽度小于或等于600px的屏幕 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class=\"hljs-comment\">/* 窗口恰好等于600px时 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"朝向\"><a href=\"#朝向\" class=\"headerlink\" title=\"朝向\"></a>朝向</h3><p><code>orientation</code>可以检测设备的方向, 如竖屏或横屏.<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: portrait) &#123;<br>    <span class=\"hljs-comment\">/* 竖放时的CSS样式 */</span><br>&#125;<br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-comment\">/* 横屏时的CSS样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"更复杂的媒体查询\"><a href=\"#更复杂的媒体查询\" class=\"headerlink\" title=\"更复杂的媒体查询\"></a>更复杂的媒体查询</h2><ul>\n<li><p><code>and</code>实现与逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">400px</span>) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>  <span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>,</code>实现或逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">768px</span>) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape), (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>  <span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)</span><br><span class=\"hljs-comment\">  */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>与C中的<code>&amp;</code>和<code>|</code>类似, 与的优先级更高, 先将<code>and</code>的条件进行判断, 然后视作整体.</p>\n</blockquote>\n</li>\n<li><p><code>not</code>实现非逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> all <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br><span class=\"hljs-comment\">/* 非全部屏幕且屏幕方向为横向 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>not</code>实现 <strong>反转查询</strong>:</p>\n<blockquote>\n<p>与最近的<code>and</code>组合所绑定, 注意优先级</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>), print <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure>\n<p><code>,</code>将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-keyword\">not</span> (screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>))), print <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"利用查询结果扩展设计\"><a href=\"#利用查询结果扩展设计\" class=\"headerlink\" title=\"利用查询结果扩展设计\"></a>利用查询结果扩展设计</h1><p>上述在CSS中利用<code>@media</code>可以实现响应式的设计, 如果我们希望在js/ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.</p>\n<ul>\n<li><p>使用<code>window.matchMedia()</code>方法存放媒体查询结果:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 检测设备的旋转方向是否为纵向</span><br><span class=\"hljs-keyword\">var</span> mediaQueryList = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">matchMedia</span>(<span class=\"hljs-string\">&quot;(orientation: portrait)&quot;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>检查属性<code>matches</code>获取对应的查询结果:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">if (mediaQueryList<span class=\"hljs-selector-class\">.matches</span>) &#123;<br>  <span class=\"hljs-comment\">/* 设备的旋转方向为纵向 portrait */</span><br>&#125; else &#123;<br>  <span class=\"hljs-comment\">/* 设备的旋转方向不是纵向，也就是横向 landscape */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>通过<code>addListener()</code>方法注册监听器, 持续监听查询列表的结果</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 定义媒体查询字符串</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">mediaQueryString</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;(orientation: portrait)&quot;</span>;<br><br><span class=\"hljs-comment\">// 创建查询列表</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">mediaQueryList</span>: <span class=\"hljs-title class_\">MediaQueryList</span> = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">matchMedia</span>(mediaQueryString);<br><br><span class=\"hljs-comment\">// 定义回调函数，使用 MediaQueryListEvent 类型</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleOrientationChange</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">event</span>: <span class=\"hljs-title class_\">MediaQueryListEvent</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">matches</span>) &#123;<br>    <span class=\"hljs-comment\">// 媒体查询匹配（竖屏）</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Orientation changed to portrait&quot;</span>);<br>    <span class=\"hljs-comment\">// 在这里执行竖屏时的逻辑</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// 媒体查询不匹配（横屏）</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Orientation changed to landscape&quot;</span>);<br>    <span class=\"hljs-comment\">// 在这里执行横屏时的逻辑</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 先运行一次回调函数，传入 MediaQueryList 对象</span><br><span class=\"hljs-title function_\">handleOrientationChange</span>(&#123;<br>    <span class=\"hljs-attr\">matches</span>: mediaQueryList.<span class=\"hljs-property\">matches</span>,<br>    <span class=\"hljs-attr\">media</span>: mediaQueryList.<span class=\"hljs-property\">media</span>,<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;change&#x27;</span>,<br>&#125; <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">MediaQueryListEvent</span>);<br><br><span class=\"hljs-comment\">// 为查询列表注册监听器，同时将回调函数传给监听器</span><br>mediaQueryList.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;change&#x27;</span>, handleOrientationChange);<br><br><span class=\"hljs-comment\">// (可选) 在组件卸载时或不再需要监听时，移除事件监听器</span><br><span class=\"hljs-comment\">// mediaQueryList.removeEventListener(&#x27;change&#x27;, handleOrientationChange);</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","more":"<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Media_queries\">媒体查询入门指南</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries\">使用编程方法测试媒体查询</a></p>\n</blockquote>\n<h1 id=\"媒体查询入门\"><a href=\"#媒体查询入门\" class=\"headerlink\" title=\"媒体查询入门\"></a>媒体查询入门</h1><p>对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.</p>\n<p>媒体查询的范式:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> media-type <span class=\"hljs-keyword\">and</span> (media-feature) &#123;<br>    <span class=\"hljs-comment\">/*css rules*/</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>媒体类型用于声明css文件被用作什么类型的媒体;</li>\n<li>媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;</li>\n<li>通过测试且符合媒体类型的情况下应用内部的CSS样式.</li>\n</ol>\n</blockquote>\n<p><strong>media-type</strong>: all, print, screen, speech.</p>\n<h2 id=\"媒体特征\"><a href=\"#媒体特征\" class=\"headerlink\" title=\"媒体特征\"></a>媒体特征</h2><h3 id=\"屏幕尺寸\"><a href=\"#屏幕尺寸\" class=\"headerlink\" title=\"屏幕尺寸\"></a>屏幕尺寸</h3><p>使用<code>min</code>,<code>max</code>在一定的数值范围内启用当前的CSS样式.</p>\n<blockquote>\n<p>如果去掉前缀, 将仅在恰好为当前数值中启用.<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-comment\">/* 启用宽度大于或等于600px的屏幕 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class=\"hljs-comment\">/* 启用宽度小于或等于600px的屏幕 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class=\"hljs-comment\">/* 窗口恰好等于600px时 */</span><br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"朝向\"><a href=\"#朝向\" class=\"headerlink\" title=\"朝向\"></a>朝向</h3><p><code>orientation</code>可以检测设备的方向, 如竖屏或横屏.<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: portrait) &#123;<br>    <span class=\"hljs-comment\">/* 竖放时的CSS样式 */</span><br>&#125;<br><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>    <span class=\"hljs-comment\">/* 横屏时的CSS样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"更复杂的媒体查询\"><a href=\"#更复杂的媒体查询\" class=\"headerlink\" title=\"更复杂的媒体查询\"></a>更复杂的媒体查询</h2><ul>\n<li><p><code>and</code>实现与逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">400px</span>) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br>  <span class=\"hljs-selector-tag\">body</span> &#123;<br>    <span class=\"hljs-attribute\">color</span>: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>,</code>实现或逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">min-width</span>: <span class=\"hljs-number\">768px</span>) <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape), (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">480px</span>) &#123;<br>  <span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">  (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)</span><br><span class=\"hljs-comment\">  */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>与C中的<code>&amp;</code>和<code>|</code>类似, 与的优先级更高, 先将<code>and</code>的条件进行判断, 然后视作整体.</p>\n</blockquote>\n</li>\n<li><p><code>not</code>实现非逻辑:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> all <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">orientation</span>: landscape) &#123;<br><span class=\"hljs-comment\">/* 非全部屏幕且屏幕方向为横向 */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>not</code>实现 <strong>反转查询</strong>:</p>\n<blockquote>\n<p>与最近的<code>and</code>组合所绑定, 注意优先级</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> <span class=\"hljs-keyword\">not</span> screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>), print <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure>\n<p><code>,</code>将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-keyword\">not</span> (screen <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>))), print <span class=\"hljs-keyword\">and</span> (<span class=\"hljs-attribute\">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"利用查询结果扩展设计\"><a href=\"#利用查询结果扩展设计\" class=\"headerlink\" title=\"利用查询结果扩展设计\"></a>利用查询结果扩展设计</h1><p>上述在CSS中利用<code>@media</code>可以实现响应式的设计, 如果我们希望在js/ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.</p>\n<ul>\n<li><p>使用<code>window.matchMedia()</code>方法存放媒体查询结果:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 检测设备的旋转方向是否为纵向</span><br><span class=\"hljs-keyword\">var</span> mediaQueryList = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">matchMedia</span>(<span class=\"hljs-string\">&quot;(orientation: portrait)&quot;</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>检查属性<code>matches</code>获取对应的查询结果:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">if (mediaQueryList<span class=\"hljs-selector-class\">.matches</span>) &#123;<br>  <span class=\"hljs-comment\">/* 设备的旋转方向为纵向 portrait */</span><br>&#125; else &#123;<br>  <span class=\"hljs-comment\">/* 设备的旋转方向不是纵向，也就是横向 landscape */</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>通过<code>addListener()</code>方法注册监听器, 持续监听查询列表的结果</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 定义媒体查询字符串</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">mediaQueryString</span>: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">&quot;(orientation: portrait)&quot;</span>;<br><br><span class=\"hljs-comment\">// 创建查询列表</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">mediaQueryList</span>: <span class=\"hljs-title class_\">MediaQueryList</span> = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-title function_\">matchMedia</span>(mediaQueryString);<br><br><span class=\"hljs-comment\">// 定义回调函数，使用 MediaQueryListEvent 类型</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">handleOrientationChange</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">event</span>: <span class=\"hljs-title class_\">MediaQueryListEvent</span></span>): <span class=\"hljs-built_in\">void</span> &#123;<br>  <span class=\"hljs-keyword\">if</span> (event.<span class=\"hljs-property\">matches</span>) &#123;<br>    <span class=\"hljs-comment\">// 媒体查询匹配（竖屏）</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Orientation changed to portrait&quot;</span>);<br>    <span class=\"hljs-comment\">// 在这里执行竖屏时的逻辑</span><br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">// 媒体查询不匹配（横屏）</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Orientation changed to landscape&quot;</span>);<br>    <span class=\"hljs-comment\">// 在这里执行横屏时的逻辑</span><br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 先运行一次回调函数，传入 MediaQueryList 对象</span><br><span class=\"hljs-title function_\">handleOrientationChange</span>(&#123;<br>    <span class=\"hljs-attr\">matches</span>: mediaQueryList.<span class=\"hljs-property\">matches</span>,<br>    <span class=\"hljs-attr\">media</span>: mediaQueryList.<span class=\"hljs-property\">media</span>,<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;change&#x27;</span>,<br>&#125; <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">MediaQueryListEvent</span>);<br><br><span class=\"hljs-comment\">// 为查询列表注册监听器，同时将回调函数传给监听器</span><br>mediaQueryList.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;change&#x27;</span>, handleOrientationChange);<br><br><span class=\"hljs-comment\">// (可选) 在组件卸载时或不再需要监听时，移除事件监听器</span><br><span class=\"hljs-comment\">// mediaQueryList.removeEventListener(&#x27;change&#x27;, handleOrientationChange);</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"Tmux","date":"2025-01-17T07:56:29.000Z","excerpt":"在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~","index_img":"/img/不死鸟.jpg","_content":">在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~\n<img src = \"/img/不死鸟.jpg\" width = \"70%\">\n\n# Tmux 入门指南：多会话终端管理利器\n## 什么是 Tmux？\n\nTmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。\n## 为什么需要 Tmux？\n\n在以下场景中，tmux 特别有用：\n\n1. **远程服务器管理**\n   - SSH 连接意外断开时，tmux 会话仍然保持运行\n   - 可以随时重新连接到之前的工作环境\n\n2. **多任务管理**\n   - 在同一个终端窗口中同时运行多个程序\n   - 方便地在不同任务之间切换\n\n3. **结对编程**\n   - 多人可以同时连接到同一个 tmux 会话\n   - 实时查看和协作编辑\n\n## 基本概念\n\ntmux 采用三层架构：\n\n- **会话（Session）**：最顶层的概念，包含多个窗口\n- **窗口（Window）**：类似于浏览器的标签页\n- **窗格（Pane）**：窗口内的分割区域\n\n## 常用操作指南\n\n### 1. 安装\n\n不同系统的安装命令：\n\n```bash\n# MacOS\nbrew install tmux\n\n# Ubuntu/Debian\nsudo apt install tmux\n\n# CentOS/RHEL\nsudo yum install tmux\n```\n\n### 2. 会话管理\n\n#### 启动新会话\n```bash\n# 创建默认会话\ntmux\n\n# 创建命名会话\ntmux new -s session_name\n```\n\n#### 会话操作\n```bash\n# 断开当前会话\nCtrl+b d\n\n# 列出所有会话\ntmux ls\n\n# 连接到指定会话\ntmux attach -t session_name\n\n# 关闭指定会话\ntmux kill-session -t session_name\n```\n\n### 3. 窗口管理\n\n所有命令都需要先按前缀键 `Ctrl+b`：\n\n- `c`: 创建新窗口\n- `&`: 关闭当前窗口\n- `p`: 切换到上一个窗口\n- `n`: 切换到下一个窗口\n- `数字键`: 切换到指定编号的窗口\n\n### 4. 窗格操作\n\n同样需要先按前缀键 `Ctrl+b`：\n\n- `%`: 垂直分割窗格\n- `\"`: 水平分割窗格\n- `方向键`: 在窗格之间移动\n- `x`: 关闭当前窗格\n- `z`: 最大化/还原当前窗格\n\n## 进阶技巧\n\n### 1. 自定义配置\n\n创建 `~/.tmux.conf` 文件来自定义 tmux 配置：\n\n```bash\n# 修改前缀键为 Ctrl+a\nset -g prefix C-a\nunbind C-b\nbind C-a send-prefix\n\n# 开启鼠标支持\nset -g mouse on\n\n# 设置窗口编号从 1 开始\nset -g base-index 1\n```\n\n### 2. 复制模式\n\n1. 按 `Ctrl+b [` 进入复制模式\n2. 使用方向键移动光标\n3. 按 `Space` 开始选择\n4. 按 `Enter` 复制选中内容\n5. 按 `Ctrl+b ]` 粘贴\n\n## 最佳实践\n\n1. **使用有意义的会话名**：便于识别和管理\n2. **合理使用窗格**：避免过度分割\n3. **保持配置文件的整洁**：注释清晰，逻辑分明\n4. **定期保存重要会话**：使用插件或脚本自动保存\n\n## 常见问题解决\n\n1. **无法创建会话**\n   - 检查 tmux 是否正确安装\n   - 确认用户权限\n\n2. **快捷键不响应**\n   - 确认是否正确按下前缀键\n   - 检查配置文件是否有冲突\n\n3. **会话丢失**\n   - 使用 `tmux ls` 检查会话状态\n   - 查看系统日志寻找错误信息\n\n## 结语\n\ntmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。\n\n## 参考资源\n\n- [Tmux 官方文档](https://github.com/tmux/tmux/wiki)\n- [Tmux 速查表](https://tmuxcheatsheet.com/)\n- [Awesome Tmux](https://github.com/rothgar/awesome-tmux)","source":"_posts/其他/Tmux.md","raw":"---\ntitle: Tmux\ndate: 2025-01-17 15:56:29\ntags:\n- 服务器\n- 多会话管理\ncategories: 通用技能\nexcerpt: 在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~\nindex_img: /img/不死鸟.jpg\n---\n>在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~\n<img src = \"/img/不死鸟.jpg\" width = \"70%\">\n\n# Tmux 入门指南：多会话终端管理利器\n## 什么是 Tmux？\n\nTmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。\n## 为什么需要 Tmux？\n\n在以下场景中，tmux 特别有用：\n\n1. **远程服务器管理**\n   - SSH 连接意外断开时，tmux 会话仍然保持运行\n   - 可以随时重新连接到之前的工作环境\n\n2. **多任务管理**\n   - 在同一个终端窗口中同时运行多个程序\n   - 方便地在不同任务之间切换\n\n3. **结对编程**\n   - 多人可以同时连接到同一个 tmux 会话\n   - 实时查看和协作编辑\n\n## 基本概念\n\ntmux 采用三层架构：\n\n- **会话（Session）**：最顶层的概念，包含多个窗口\n- **窗口（Window）**：类似于浏览器的标签页\n- **窗格（Pane）**：窗口内的分割区域\n\n## 常用操作指南\n\n### 1. 安装\n\n不同系统的安装命令：\n\n```bash\n# MacOS\nbrew install tmux\n\n# Ubuntu/Debian\nsudo apt install tmux\n\n# CentOS/RHEL\nsudo yum install tmux\n```\n\n### 2. 会话管理\n\n#### 启动新会话\n```bash\n# 创建默认会话\ntmux\n\n# 创建命名会话\ntmux new -s session_name\n```\n\n#### 会话操作\n```bash\n# 断开当前会话\nCtrl+b d\n\n# 列出所有会话\ntmux ls\n\n# 连接到指定会话\ntmux attach -t session_name\n\n# 关闭指定会话\ntmux kill-session -t session_name\n```\n\n### 3. 窗口管理\n\n所有命令都需要先按前缀键 `Ctrl+b`：\n\n- `c`: 创建新窗口\n- `&`: 关闭当前窗口\n- `p`: 切换到上一个窗口\n- `n`: 切换到下一个窗口\n- `数字键`: 切换到指定编号的窗口\n\n### 4. 窗格操作\n\n同样需要先按前缀键 `Ctrl+b`：\n\n- `%`: 垂直分割窗格\n- `\"`: 水平分割窗格\n- `方向键`: 在窗格之间移动\n- `x`: 关闭当前窗格\n- `z`: 最大化/还原当前窗格\n\n## 进阶技巧\n\n### 1. 自定义配置\n\n创建 `~/.tmux.conf` 文件来自定义 tmux 配置：\n\n```bash\n# 修改前缀键为 Ctrl+a\nset -g prefix C-a\nunbind C-b\nbind C-a send-prefix\n\n# 开启鼠标支持\nset -g mouse on\n\n# 设置窗口编号从 1 开始\nset -g base-index 1\n```\n\n### 2. 复制模式\n\n1. 按 `Ctrl+b [` 进入复制模式\n2. 使用方向键移动光标\n3. 按 `Space` 开始选择\n4. 按 `Enter` 复制选中内容\n5. 按 `Ctrl+b ]` 粘贴\n\n## 最佳实践\n\n1. **使用有意义的会话名**：便于识别和管理\n2. **合理使用窗格**：避免过度分割\n3. **保持配置文件的整洁**：注释清晰，逻辑分明\n4. **定期保存重要会话**：使用插件或脚本自动保存\n\n## 常见问题解决\n\n1. **无法创建会话**\n   - 检查 tmux 是否正确安装\n   - 确认用户权限\n\n2. **快捷键不响应**\n   - 确认是否正确按下前缀键\n   - 检查配置文件是否有冲突\n\n3. **会话丢失**\n   - 使用 `tmux ls` 检查会话状态\n   - 查看系统日志寻找错误信息\n\n## 结语\n\ntmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。\n\n## 参考资源\n\n- [Tmux 官方文档](https://github.com/tmux/tmux/wiki)\n- [Tmux 速查表](https://tmuxcheatsheet.com/)\n- [Awesome Tmux](https://github.com/rothgar/awesome-tmux)","slug":"其他/Tmux","published":1,"updated":"2025-01-19T11:46:34.124Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vy0013dwqg4h4k91s0","content":"<blockquote>\n<p>在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~<br><img src = \"/img/不死鸟.jpg\" width = \"70%\"></p>\n</blockquote>\n<h1 id=\"Tmux-入门指南：多会话终端管理利器\"><a href=\"#Tmux-入门指南：多会话终端管理利器\" class=\"headerlink\" title=\"Tmux 入门指南：多会话终端管理利器\"></a>Tmux 入门指南：多会话终端管理利器</h1><h2 id=\"什么是-Tmux？\"><a href=\"#什么是-Tmux？\" class=\"headerlink\" title=\"什么是 Tmux？\"></a>什么是 Tmux？</h2><p>Tmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。</p>\n<h2 id=\"为什么需要-Tmux？\"><a href=\"#为什么需要-Tmux？\" class=\"headerlink\" title=\"为什么需要 Tmux？\"></a>为什么需要 Tmux？</h2><p>在以下场景中，tmux 特别有用：</p>\n<ol>\n<li><p><strong>远程服务器管理</strong></p>\n<ul>\n<li>SSH 连接意外断开时，tmux 会话仍然保持运行</li>\n<li>可以随时重新连接到之前的工作环境</li>\n</ul>\n</li>\n<li><p><strong>多任务管理</strong></p>\n<ul>\n<li>在同一个终端窗口中同时运行多个程序</li>\n<li>方便地在不同任务之间切换</li>\n</ul>\n</li>\n<li><p><strong>结对编程</strong></p>\n<ul>\n<li>多人可以同时连接到同一个 tmux 会话</li>\n<li>实时查看和协作编辑</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>tmux 采用三层架构：</p>\n<ul>\n<li><strong>会话（Session）</strong>：最顶层的概念，包含多个窗口</li>\n<li><strong>窗口（Window）</strong>：类似于浏览器的标签页</li>\n<li><strong>窗格（Pane）</strong>：窗口内的分割区域</li>\n</ul>\n<h2 id=\"常用操作指南\"><a href=\"#常用操作指南\" class=\"headerlink\" title=\"常用操作指南\"></a>常用操作指南</h2><h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>不同系统的安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># MacOS</span><br>brew install tmux<br><br><span class=\"hljs-comment\"># Ubuntu/Debian</span><br><span class=\"hljs-built_in\">sudo</span> apt install tmux<br><br><span class=\"hljs-comment\"># CentOS/RHEL</span><br><span class=\"hljs-built_in\">sudo</span> yum install tmux<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-会话管理\"><a href=\"#2-会话管理\" class=\"headerlink\" title=\"2. 会话管理\"></a>2. 会话管理</h3><h4 id=\"启动新会话\"><a href=\"#启动新会话\" class=\"headerlink\" title=\"启动新会话\"></a>启动新会话</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 创建默认会话</span><br>tmux<br><br><span class=\"hljs-comment\"># 创建命名会话</span><br>tmux new -s session_name<br></code></pre></td></tr></table></figure>\n<h4 id=\"会话操作\"><a href=\"#会话操作\" class=\"headerlink\" title=\"会话操作\"></a>会话操作</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 断开当前会话</span><br>Ctrl+b d<br><br><span class=\"hljs-comment\"># 列出所有会话</span><br>tmux <span class=\"hljs-built_in\">ls</span><br><br><span class=\"hljs-comment\"># 连接到指定会话</span><br>tmux attach -t session_name<br><br><span class=\"hljs-comment\"># 关闭指定会话</span><br>tmux kill-session -t session_name<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-窗口管理\"><a href=\"#3-窗口管理\" class=\"headerlink\" title=\"3. 窗口管理\"></a>3. 窗口管理</h3><p>所有命令都需要先按前缀键 <code>Ctrl+b</code>：</p>\n<ul>\n<li><code>c</code>: 创建新窗口</li>\n<li><code>&amp;</code>: 关闭当前窗口</li>\n<li><code>p</code>: 切换到上一个窗口</li>\n<li><code>n</code>: 切换到下一个窗口</li>\n<li><code>数字键</code>: 切换到指定编号的窗口</li>\n</ul>\n<h3 id=\"4-窗格操作\"><a href=\"#4-窗格操作\" class=\"headerlink\" title=\"4. 窗格操作\"></a>4. 窗格操作</h3><p>同样需要先按前缀键 <code>Ctrl+b</code>：</p>\n<ul>\n<li><code>%</code>: 垂直分割窗格</li>\n<li><code>&quot;</code>: 水平分割窗格</li>\n<li><code>方向键</code>: 在窗格之间移动</li>\n<li><code>x</code>: 关闭当前窗格</li>\n<li><code>z</code>: 最大化/还原当前窗格</li>\n</ul>\n<h2 id=\"进阶技巧\"><a href=\"#进阶技巧\" class=\"headerlink\" title=\"进阶技巧\"></a>进阶技巧</h2><h3 id=\"1-自定义配置\"><a href=\"#1-自定义配置\" class=\"headerlink\" title=\"1. 自定义配置\"></a>1. 自定义配置</h3><p>创建 <code>~/.tmux.conf</code> 文件来自定义 tmux 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 修改前缀键为 Ctrl+a</span><br><span class=\"hljs-built_in\">set</span> -g prefix C-a<br>unbind C-b<br><span class=\"hljs-built_in\">bind</span> C-a send-prefix<br><br><span class=\"hljs-comment\"># 开启鼠标支持</span><br><span class=\"hljs-built_in\">set</span> -g mouse on<br><br><span class=\"hljs-comment\"># 设置窗口编号从 1 开始</span><br><span class=\"hljs-built_in\">set</span> -g base-index 1<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-复制模式\"><a href=\"#2-复制模式\" class=\"headerlink\" title=\"2. 复制模式\"></a>2. 复制模式</h3><ol>\n<li>按 <code>Ctrl+b [</code> 进入复制模式</li>\n<li>使用方向键移动光标</li>\n<li>按 <code>Space</code> 开始选择</li>\n<li>按 <code>Enter</code> 复制选中内容</li>\n<li>按 <code>Ctrl+b ]</code> 粘贴</li>\n</ol>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ol>\n<li><strong>使用有意义的会话名</strong>：便于识别和管理</li>\n<li><strong>合理使用窗格</strong>：避免过度分割</li>\n<li><strong>保持配置文件的整洁</strong>：注释清晰，逻辑分明</li>\n<li><strong>定期保存重要会话</strong>：使用插件或脚本自动保存</li>\n</ol>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><ol>\n<li><p><strong>无法创建会话</strong></p>\n<ul>\n<li>检查 tmux 是否正确安装</li>\n<li>确认用户权限</li>\n</ul>\n</li>\n<li><p><strong>快捷键不响应</strong></p>\n<ul>\n<li>确认是否正确按下前缀键</li>\n<li>检查配置文件是否有冲突</li>\n</ul>\n</li>\n<li><p><strong>会话丢失</strong></p>\n<ul>\n<li>使用 <code>tmux ls</code> 检查会话状态</li>\n<li>查看系统日志寻找错误信息</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>tmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。</p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"https://github.com/tmux/tmux/wiki\">Tmux 官方文档</a></li>\n<li><a href=\"https://tmuxcheatsheet.com/\">Tmux 速查表</a></li>\n<li><a href=\"https://github.com/rothgar/awesome-tmux\">Awesome Tmux</a></li>\n</ul>\n","more":"<blockquote>\n<p>在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~<br><img src = \"/img/不死鸟.jpg\" width = \"70%\"></p>\n</blockquote>\n<h1 id=\"Tmux-入门指南：多会话终端管理利器\"><a href=\"#Tmux-入门指南：多会话终端管理利器\" class=\"headerlink\" title=\"Tmux 入门指南：多会话终端管理利器\"></a>Tmux 入门指南：多会话终端管理利器</h1><h2 id=\"什么是-Tmux？\"><a href=\"#什么是-Tmux？\" class=\"headerlink\" title=\"什么是 Tmux？\"></a>什么是 Tmux？</h2><p>Tmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。</p>\n<h2 id=\"为什么需要-Tmux？\"><a href=\"#为什么需要-Tmux？\" class=\"headerlink\" title=\"为什么需要 Tmux？\"></a>为什么需要 Tmux？</h2><p>在以下场景中，tmux 特别有用：</p>\n<ol>\n<li><p><strong>远程服务器管理</strong></p>\n<ul>\n<li>SSH 连接意外断开时，tmux 会话仍然保持运行</li>\n<li>可以随时重新连接到之前的工作环境</li>\n</ul>\n</li>\n<li><p><strong>多任务管理</strong></p>\n<ul>\n<li>在同一个终端窗口中同时运行多个程序</li>\n<li>方便地在不同任务之间切换</li>\n</ul>\n</li>\n<li><p><strong>结对编程</strong></p>\n<ul>\n<li>多人可以同时连接到同一个 tmux 会话</li>\n<li>实时查看和协作编辑</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>tmux 采用三层架构：</p>\n<ul>\n<li><strong>会话（Session）</strong>：最顶层的概念，包含多个窗口</li>\n<li><strong>窗口（Window）</strong>：类似于浏览器的标签页</li>\n<li><strong>窗格（Pane）</strong>：窗口内的分割区域</li>\n</ul>\n<h2 id=\"常用操作指南\"><a href=\"#常用操作指南\" class=\"headerlink\" title=\"常用操作指南\"></a>常用操作指南</h2><h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>不同系统的安装命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># MacOS</span><br>brew install tmux<br><br><span class=\"hljs-comment\"># Ubuntu/Debian</span><br><span class=\"hljs-built_in\">sudo</span> apt install tmux<br><br><span class=\"hljs-comment\"># CentOS/RHEL</span><br><span class=\"hljs-built_in\">sudo</span> yum install tmux<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-会话管理\"><a href=\"#2-会话管理\" class=\"headerlink\" title=\"2. 会话管理\"></a>2. 会话管理</h3><h4 id=\"启动新会话\"><a href=\"#启动新会话\" class=\"headerlink\" title=\"启动新会话\"></a>启动新会话</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 创建默认会话</span><br>tmux<br><br><span class=\"hljs-comment\"># 创建命名会话</span><br>tmux new -s session_name<br></code></pre></td></tr></table></figure>\n<h4 id=\"会话操作\"><a href=\"#会话操作\" class=\"headerlink\" title=\"会话操作\"></a>会话操作</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 断开当前会话</span><br>Ctrl+b d<br><br><span class=\"hljs-comment\"># 列出所有会话</span><br>tmux <span class=\"hljs-built_in\">ls</span><br><br><span class=\"hljs-comment\"># 连接到指定会话</span><br>tmux attach -t session_name<br><br><span class=\"hljs-comment\"># 关闭指定会话</span><br>tmux kill-session -t session_name<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-窗口管理\"><a href=\"#3-窗口管理\" class=\"headerlink\" title=\"3. 窗口管理\"></a>3. 窗口管理</h3><p>所有命令都需要先按前缀键 <code>Ctrl+b</code>：</p>\n<ul>\n<li><code>c</code>: 创建新窗口</li>\n<li><code>&amp;</code>: 关闭当前窗口</li>\n<li><code>p</code>: 切换到上一个窗口</li>\n<li><code>n</code>: 切换到下一个窗口</li>\n<li><code>数字键</code>: 切换到指定编号的窗口</li>\n</ul>\n<h3 id=\"4-窗格操作\"><a href=\"#4-窗格操作\" class=\"headerlink\" title=\"4. 窗格操作\"></a>4. 窗格操作</h3><p>同样需要先按前缀键 <code>Ctrl+b</code>：</p>\n<ul>\n<li><code>%</code>: 垂直分割窗格</li>\n<li><code>&quot;</code>: 水平分割窗格</li>\n<li><code>方向键</code>: 在窗格之间移动</li>\n<li><code>x</code>: 关闭当前窗格</li>\n<li><code>z</code>: 最大化/还原当前窗格</li>\n</ul>\n<h2 id=\"进阶技巧\"><a href=\"#进阶技巧\" class=\"headerlink\" title=\"进阶技巧\"></a>进阶技巧</h2><h3 id=\"1-自定义配置\"><a href=\"#1-自定义配置\" class=\"headerlink\" title=\"1. 自定义配置\"></a>1. 自定义配置</h3><p>创建 <code>~/.tmux.conf</code> 文件来自定义 tmux 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 修改前缀键为 Ctrl+a</span><br><span class=\"hljs-built_in\">set</span> -g prefix C-a<br>unbind C-b<br><span class=\"hljs-built_in\">bind</span> C-a send-prefix<br><br><span class=\"hljs-comment\"># 开启鼠标支持</span><br><span class=\"hljs-built_in\">set</span> -g mouse on<br><br><span class=\"hljs-comment\"># 设置窗口编号从 1 开始</span><br><span class=\"hljs-built_in\">set</span> -g base-index 1<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-复制模式\"><a href=\"#2-复制模式\" class=\"headerlink\" title=\"2. 复制模式\"></a>2. 复制模式</h3><ol>\n<li>按 <code>Ctrl+b [</code> 进入复制模式</li>\n<li>使用方向键移动光标</li>\n<li>按 <code>Space</code> 开始选择</li>\n<li>按 <code>Enter</code> 复制选中内容</li>\n<li>按 <code>Ctrl+b ]</code> 粘贴</li>\n</ol>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><ol>\n<li><strong>使用有意义的会话名</strong>：便于识别和管理</li>\n<li><strong>合理使用窗格</strong>：避免过度分割</li>\n<li><strong>保持配置文件的整洁</strong>：注释清晰，逻辑分明</li>\n<li><strong>定期保存重要会话</strong>：使用插件或脚本自动保存</li>\n</ol>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><ol>\n<li><p><strong>无法创建会话</strong></p>\n<ul>\n<li>检查 tmux 是否正确安装</li>\n<li>确认用户权限</li>\n</ul>\n</li>\n<li><p><strong>快捷键不响应</strong></p>\n<ul>\n<li>确认是否正确按下前缀键</li>\n<li>检查配置文件是否有冲突</li>\n</ul>\n</li>\n<li><p><strong>会话丢失</strong></p>\n<ul>\n<li>使用 <code>tmux ls</code> 检查会话状态</li>\n<li>查看系统日志寻找错误信息</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>tmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。</p>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"https://github.com/tmux/tmux/wiki\">Tmux 官方文档</a></li>\n<li><a href=\"https://tmuxcheatsheet.com/\">Tmux 速查表</a></li>\n<li><a href=\"https://github.com/rothgar/awesome-tmux\">Awesome Tmux</a></li>\n</ul>\n"},{"title":"pip-tools","date":"2025-01-15T14:29:31.000Z","excerpt":"常常在python的虚拟环境中碰到依赖包版本冲突的问题吗? 试试pip-tools这个工具吧!","index_img":"/img/great.jpg","_content":"# Python依赖管理利器：pip-tools完全指南\n>  本文由 *Claude 3.5 Sonnet* 协助生成.\n\n![Python Version](https://img.shields.io/badge/Python-3.6+-blue.svg)\n![pip-tools](https://img.shields.io/badge/pip--tools-6.13.0-green.svg)\n\n在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致\"在我这里能运行\"的经典问题。\n<img src=\"/img/2025-01-16-23-58-21.png\" width=\"70%\" />\n针对上述问题, 本文将详细介绍如何使用 `pip-tools`，实现精确的依赖版本控制。\n\n## 目录\n1. [为什么需要 pip-tools？](#为什么需要-pip-tools)\n2. [环境准备](#环境准备)\n3. [pip-tools 的安装与使用](#pip-tools-的安装与使用)\n4. [最佳实践](#最佳实践)\n5. [常见问题解决](#常见问题解决)\n6. [高级用法](#高级用法)\n\n## 为什么需要 pip-tools？\n\n传统的依赖管理方式存在以下问题：\n- `requirements.txt` 手动维护容易出错\n- 间接依赖版本难以控制\n- 团队成员环境不一致\n- 依赖更新流程繁琐\n\n`pip-tools` 通过以下特性解决这些问题：\n- 自动生成完整的依赖关系\n- 锁定所有依赖的具体版本\n- 支持开发环境和生产环境分离\n- 提供简单的依赖更新机制\n\n## 环境准备\n\n### 1. 创建虚拟环境\n\n首先，我们需要创建一个独立的 Python 虚拟环境：\n\n```bash\n# 安装 virtualenv（如果还没有安装）\npip install virtualenv\n\n# 创建虚拟环境\nvirtualenv venv\n\n# 激活虚拟环境\n# Linux/macOS:\nsource venv/bin/activate\n# Windows:\n.\\venv\\Scripts\\activate\n```\n\n### 2. 项目结构\n\n推荐的项目结构如下：\n\n```\nmy_project/\n├── venv/\n├── requirements.in\n├── requirements.txt\n├── requirements-dev.in   # 可选：开发环境依赖\n├── requirements-dev.txt  # 可选：开发环境依赖锁定文件\n└── src/\n```\n\n## pip-tools 的安装与使用\n\n### 1. 安装 pip-tools\n\n```bash\npip install pip-tools\n```\n\n### 2. 创建依赖文件\n\n创建 `requirements.in` 文件，列出直接依赖：\n\n```bash\n# requirements.in\nflask\npython-dotenv\nopenai\nmarkdown-it-py\nfairy-doc[cpu]\n```\n> 注意, 此处不同的依赖包必须分行呈现.\n\n\n### 3. 生成锁定文件\n\n```bash\n# 生成 requirements.txt\npip-compile requirements.in\n\n# 如果有开发依赖\npip-compile requirements-dev.in\n```\n\n生成的 `requirements.txt` 示例：\n\n```bash\n#\n# This file is autogenerated by pip-compile\n# To update, run:\n#\n#    pip-compile requirements.in\n#\nflask==2.3.3\n  --hash=sha256:...\npython-dotenv==1.0.0\n  --hash=sha256:...\nopenai==0.27.8\n  --hash=sha256:...\nmarkdown-it-py==3.0.0\n  --hash=sha256:...\nfairy-doc[cpu]==1.2.0\n  --hash=sha256:...\n```\n\n### 4. 安装依赖\n\n```bash\n# 安装所有依赖\npip-sync requirements.txt\n\n# 如果同时需要开发依赖\npip-sync requirements.txt requirements-dev.txt\n```\n\n## 最佳实践\n\n### 1. 版本控制\n\n```bash\n# requirements.in\nflask>=2.0.0,<3.0.0  # 指定版本范围\npython-dotenv~=1.0.0  # 允许补丁版本更新\nopenai==0.27.8       # 锁定具体版本\n```\n\n### 2. 依赖分组\n\n```bash\n# requirements-dev.in\n-r requirements.in    # 包含基础依赖\npytest               # 测试框架\nblack                # 代码格式化\nflake8               # 代码检查\n```\n\n### 3. 更新依赖\n\n```bash\n# 更新单个包\npip-compile --upgrade-package flask requirements.in\n\n# 更新所有包\npip-compile --upgrade requirements.in\n```\n\n## 常见问题解决\n\n### 1. 依赖冲突\n\n如果遇到依赖冲突，可以：\n- 检查 `requirements.in` 中的版本约束\n- 使用 `pip-compile --verbose` 查看详细信息\n- 考虑降级某些包的版本\n\n### 2. Hash 不匹配\n\n如果出现 hash 不匹配：\n```bash\npip-compile --generate-hashes requirements.in\n```\n\n### 3. 环境不一致\n\n确保团队成员：\n- 使用相同的 Python 版本\n- 严格执行 `pip-sync`\n- 不要手动 `pip install`\n\n## 高级用法\n\n### 1. 自定义输出格式\n\n```bash\n# 生成带注释的依赖文件\npip-compile --annotate requirements.in\n\n# 生成带 hashes 的依赖文件\npip-compile --generate-hashes requirements.in\n```\n\n### 2. 多环境配置\n\n```bash\n# 开发环境\npip-compile requirements-dev.in\n\n# 生产环境\npip-compile requirements.in --output-file requirements-prod.txt\n```\n\n### 3. 依赖更新策略\n\n```bash\n# 只更新安全相关的包\npip-compile --upgrade-package flask --upgrade-package \"requests>=2.31.0\"\n\n# 保持现有版本\npip-compile --no-upgrade requirements.in\n```\n\n## 结语\n\n通过使用 `pip-tools`，我们可以：\n- 实现精确的依赖版本控制\n- 简化依赖管理流程\n- 确保团队环境一致性\n- 提高项目的可维护性\n\n希望这篇指南能帮助你更好地管理 Python 项目的依赖！\n<img src = \"/img/great.jpg\" width = \"70%\">\n## 参考资料\n\n- [pip-tools 官方文档](https://github.com/jazzband/pip-tools)\n- [Python Packaging User Guide](https://packaging.python.org/)\n- [PEP 508 – Dependency specification for Python Software Packages](https://www.python.org/dev/peps/pep-0508/)\n","source":"_posts/其他/pip-tools.md","raw":"---\ntitle: pip-tools\ndate: 2025-01-15 22:29:31\ntags: \n- python\n- 环境配置\ncategories: 通用技能\nexcerpt: 常常在python的虚拟环境中碰到依赖包版本冲突的问题吗? 试试pip-tools这个工具吧!\nindex_img: /img/great.jpg\n---\n# Python依赖管理利器：pip-tools完全指南\n>  本文由 *Claude 3.5 Sonnet* 协助生成.\n\n![Python Version](https://img.shields.io/badge/Python-3.6+-blue.svg)\n![pip-tools](https://img.shields.io/badge/pip--tools-6.13.0-green.svg)\n\n在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致\"在我这里能运行\"的经典问题。\n<img src=\"/img/2025-01-16-23-58-21.png\" width=\"70%\" />\n针对上述问题, 本文将详细介绍如何使用 `pip-tools`，实现精确的依赖版本控制。\n\n## 目录\n1. [为什么需要 pip-tools？](#为什么需要-pip-tools)\n2. [环境准备](#环境准备)\n3. [pip-tools 的安装与使用](#pip-tools-的安装与使用)\n4. [最佳实践](#最佳实践)\n5. [常见问题解决](#常见问题解决)\n6. [高级用法](#高级用法)\n\n## 为什么需要 pip-tools？\n\n传统的依赖管理方式存在以下问题：\n- `requirements.txt` 手动维护容易出错\n- 间接依赖版本难以控制\n- 团队成员环境不一致\n- 依赖更新流程繁琐\n\n`pip-tools` 通过以下特性解决这些问题：\n- 自动生成完整的依赖关系\n- 锁定所有依赖的具体版本\n- 支持开发环境和生产环境分离\n- 提供简单的依赖更新机制\n\n## 环境准备\n\n### 1. 创建虚拟环境\n\n首先，我们需要创建一个独立的 Python 虚拟环境：\n\n```bash\n# 安装 virtualenv（如果还没有安装）\npip install virtualenv\n\n# 创建虚拟环境\nvirtualenv venv\n\n# 激活虚拟环境\n# Linux/macOS:\nsource venv/bin/activate\n# Windows:\n.\\venv\\Scripts\\activate\n```\n\n### 2. 项目结构\n\n推荐的项目结构如下：\n\n```\nmy_project/\n├── venv/\n├── requirements.in\n├── requirements.txt\n├── requirements-dev.in   # 可选：开发环境依赖\n├── requirements-dev.txt  # 可选：开发环境依赖锁定文件\n└── src/\n```\n\n## pip-tools 的安装与使用\n\n### 1. 安装 pip-tools\n\n```bash\npip install pip-tools\n```\n\n### 2. 创建依赖文件\n\n创建 `requirements.in` 文件，列出直接依赖：\n\n```bash\n# requirements.in\nflask\npython-dotenv\nopenai\nmarkdown-it-py\nfairy-doc[cpu]\n```\n> 注意, 此处不同的依赖包必须分行呈现.\n\n\n### 3. 生成锁定文件\n\n```bash\n# 生成 requirements.txt\npip-compile requirements.in\n\n# 如果有开发依赖\npip-compile requirements-dev.in\n```\n\n生成的 `requirements.txt` 示例：\n\n```bash\n#\n# This file is autogenerated by pip-compile\n# To update, run:\n#\n#    pip-compile requirements.in\n#\nflask==2.3.3\n  --hash=sha256:...\npython-dotenv==1.0.0\n  --hash=sha256:...\nopenai==0.27.8\n  --hash=sha256:...\nmarkdown-it-py==3.0.0\n  --hash=sha256:...\nfairy-doc[cpu]==1.2.0\n  --hash=sha256:...\n```\n\n### 4. 安装依赖\n\n```bash\n# 安装所有依赖\npip-sync requirements.txt\n\n# 如果同时需要开发依赖\npip-sync requirements.txt requirements-dev.txt\n```\n\n## 最佳实践\n\n### 1. 版本控制\n\n```bash\n# requirements.in\nflask>=2.0.0,<3.0.0  # 指定版本范围\npython-dotenv~=1.0.0  # 允许补丁版本更新\nopenai==0.27.8       # 锁定具体版本\n```\n\n### 2. 依赖分组\n\n```bash\n# requirements-dev.in\n-r requirements.in    # 包含基础依赖\npytest               # 测试框架\nblack                # 代码格式化\nflake8               # 代码检查\n```\n\n### 3. 更新依赖\n\n```bash\n# 更新单个包\npip-compile --upgrade-package flask requirements.in\n\n# 更新所有包\npip-compile --upgrade requirements.in\n```\n\n## 常见问题解决\n\n### 1. 依赖冲突\n\n如果遇到依赖冲突，可以：\n- 检查 `requirements.in` 中的版本约束\n- 使用 `pip-compile --verbose` 查看详细信息\n- 考虑降级某些包的版本\n\n### 2. Hash 不匹配\n\n如果出现 hash 不匹配：\n```bash\npip-compile --generate-hashes requirements.in\n```\n\n### 3. 环境不一致\n\n确保团队成员：\n- 使用相同的 Python 版本\n- 严格执行 `pip-sync`\n- 不要手动 `pip install`\n\n## 高级用法\n\n### 1. 自定义输出格式\n\n```bash\n# 生成带注释的依赖文件\npip-compile --annotate requirements.in\n\n# 生成带 hashes 的依赖文件\npip-compile --generate-hashes requirements.in\n```\n\n### 2. 多环境配置\n\n```bash\n# 开发环境\npip-compile requirements-dev.in\n\n# 生产环境\npip-compile requirements.in --output-file requirements-prod.txt\n```\n\n### 3. 依赖更新策略\n\n```bash\n# 只更新安全相关的包\npip-compile --upgrade-package flask --upgrade-package \"requests>=2.31.0\"\n\n# 保持现有版本\npip-compile --no-upgrade requirements.in\n```\n\n## 结语\n\n通过使用 `pip-tools`，我们可以：\n- 实现精确的依赖版本控制\n- 简化依赖管理流程\n- 确保团队环境一致性\n- 提高项目的可维护性\n\n希望这篇指南能帮助你更好地管理 Python 项目的依赖！\n<img src = \"/img/great.jpg\" width = \"70%\">\n## 参考资料\n\n- [pip-tools 官方文档](https://github.com/jazzband/pip-tools)\n- [Python Packaging User Guide](https://packaging.python.org/)\n- [PEP 508 – Dependency specification for Python Software Packages](https://www.python.org/dev/peps/pep-0508/)\n","slug":"其他/pip-tools","published":1,"updated":"2025-01-19T11:46:34.124Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4vy0017dwqge5pibh1g","content":"<h1 id=\"Python依赖管理利器：pip-tools完全指南\"><a href=\"#Python依赖管理利器：pip-tools完全指南\" class=\"headerlink\" title=\"Python依赖管理利器：pip-tools完全指南\"></a>Python依赖管理利器：pip-tools完全指南</h1><blockquote>\n<p> 本文由 <em>Claude 3.5 Sonnet</em> 协助生成.</p>\n</blockquote>\n<p><img src=\"https://img.shields.io/badge/Python-3.6+-blue.svg\" alt=\"Python Version\"><br><img src=\"https://img.shields.io/badge/pip--tools-6.13.0-green.svg\" alt=\"pip-tools\"></p>\n<p>在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致”在我这里能运行”的经典问题。<br><img src=\"/img/2025-01-16-23-58-21.png\" width=\"70%\" /><br>针对上述问题, 本文将详细介绍如何使用 <code>pip-tools</code>，实现精确的依赖版本控制。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#为什么需要-pip-tools\">为什么需要 pip-tools？</a></li>\n<li><a href=\"#环境准备\">环境准备</a></li>\n<li><a href=\"#pip-tools-的安装与使用\">pip-tools 的安装与使用</a></li>\n<li><a href=\"#最佳实践\">最佳实践</a></li>\n<li><a href=\"#常见问题解决\">常见问题解决</a></li>\n<li><a href=\"#高级用法\">高级用法</a></li>\n</ol>\n<h2 id=\"为什么需要-pip-tools？\"><a href=\"#为什么需要-pip-tools？\" class=\"headerlink\" title=\"为什么需要 pip-tools？\"></a>为什么需要 pip-tools？</h2><p>传统的依赖管理方式存在以下问题：</p>\n<ul>\n<li><code>requirements.txt</code> 手动维护容易出错</li>\n<li>间接依赖版本难以控制</li>\n<li>团队成员环境不一致</li>\n<li>依赖更新流程繁琐</li>\n</ul>\n<p><code>pip-tools</code> 通过以下特性解决这些问题：</p>\n<ul>\n<li>自动生成完整的依赖关系</li>\n<li>锁定所有依赖的具体版本</li>\n<li>支持开发环境和生产环境分离</li>\n<li>提供简单的依赖更新机制</li>\n</ul>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"1-创建虚拟环境\"><a href=\"#1-创建虚拟环境\" class=\"headerlink\" title=\"1. 创建虚拟环境\"></a>1. 创建虚拟环境</h3><p>首先，我们需要创建一个独立的 Python 虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装 virtualenv（如果还没有安装）</span><br>pip install virtualenv<br><br><span class=\"hljs-comment\"># 创建虚拟环境</span><br>virtualenv venv<br><br><span class=\"hljs-comment\"># 激活虚拟环境</span><br><span class=\"hljs-comment\"># Linux/macOS:</span><br><span class=\"hljs-built_in\">source</span> venv/bin/activate<br><span class=\"hljs-comment\"># Windows:</span><br>.\\venv\\Scripts\\activate<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-项目结构\"><a href=\"#2-项目结构\" class=\"headerlink\" title=\"2. 项目结构\"></a>2. 项目结构</h3><p>推荐的项目结构如下：</p>\n<figure class=\"highlight mizar\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mizar\">my_project/<br>├── venv/<br>├── <span class=\"hljs-keyword\">requirements</span>.<span class=\"hljs-keyword\">in</span><br>├── <span class=\"hljs-keyword\">requirements</span>.txt<br>├── <span class=\"hljs-keyword\">requirements</span>-dev.<span class=\"hljs-keyword\">in</span>   # 可选：开发环境依赖<br>├── <span class=\"hljs-keyword\">requirements</span>-dev.txt  # 可选：开发环境依赖锁定文件<br>└── src/<br></code></pre></td></tr></table></figure>\n<h2 id=\"pip-tools-的安装与使用\"><a href=\"#pip-tools-的安装与使用\" class=\"headerlink\" title=\"pip-tools 的安装与使用\"></a>pip-tools 的安装与使用</h2><h3 id=\"1-安装-pip-tools\"><a href=\"#1-安装-pip-tools\" class=\"headerlink\" title=\"1. 安装 pip-tools\"></a>1. 安装 pip-tools</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pip-tools<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-创建依赖文件\"><a href=\"#2-创建依赖文件\" class=\"headerlink\" title=\"2. 创建依赖文件\"></a>2. 创建依赖文件</h3><p>创建 <code>requirements.in</code> 文件，列出直接依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements.in</span><br>flask<br>python-dotenv<br>openai<br>markdown-it-py<br>fairy-doc[cpu]<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意, 此处不同的依赖包必须分行呈现.</p>\n</blockquote>\n<h3 id=\"3-生成锁定文件\"><a href=\"#3-生成锁定文件\" class=\"headerlink\" title=\"3. 生成锁定文件\"></a>3. 生成锁定文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成 requirements.txt</span><br>pip-compile requirements.in<br><br><span class=\"hljs-comment\"># 如果有开发依赖</span><br>pip-compile requirements-dev.in<br></code></pre></td></tr></table></figure>\n<p>生成的 <code>requirements.txt</code> 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># This file is autogenerated by pip-compile</span><br><span class=\"hljs-comment\"># To update, run:</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\">#    pip-compile requirements.in</span><br><span class=\"hljs-comment\">#</span><br>flask==2.3.3<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>python-dotenv==1.0.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>openai==0.27.8<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>markdown-it-py==3.0.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>fairy-doc[cpu]==1.2.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-安装依赖\"><a href=\"#4-安装依赖\" class=\"headerlink\" title=\"4. 安装依赖\"></a>4. 安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装所有依赖</span><br>pip-sync requirements.txt<br><br><span class=\"hljs-comment\"># 如果同时需要开发依赖</span><br>pip-sync requirements.txt requirements-dev.txt<br></code></pre></td></tr></table></figure>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-版本控制\"><a href=\"#1-版本控制\" class=\"headerlink\" title=\"1. 版本控制\"></a>1. 版本控制</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements.in</span><br>flask&gt;=2.0.0,&lt;3.0.0  <span class=\"hljs-comment\"># 指定版本范围</span><br>python-dotenv~=1.0.0  <span class=\"hljs-comment\"># 允许补丁版本更新</span><br>openai==0.27.8       <span class=\"hljs-comment\"># 锁定具体版本</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"2-依赖分组\"><a href=\"#2-依赖分组\" class=\"headerlink\" title=\"2. 依赖分组\"></a>2. 依赖分组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements-dev.in</span><br>-r requirements.in    <span class=\"hljs-comment\"># 包含基础依赖</span><br>pytest               <span class=\"hljs-comment\"># 测试框架</span><br>black                <span class=\"hljs-comment\"># 代码格式化</span><br>flake8               <span class=\"hljs-comment\"># 代码检查</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"3-更新依赖\"><a href=\"#3-更新依赖\" class=\"headerlink\" title=\"3. 更新依赖\"></a>3. 更新依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 更新单个包</span><br>pip-compile --upgrade-package flask requirements.in<br><br><span class=\"hljs-comment\"># 更新所有包</span><br>pip-compile --upgrade requirements.in<br></code></pre></td></tr></table></figure>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><h3 id=\"1-依赖冲突\"><a href=\"#1-依赖冲突\" class=\"headerlink\" title=\"1. 依赖冲突\"></a>1. 依赖冲突</h3><p>如果遇到依赖冲突，可以：</p>\n<ul>\n<li>检查 <code>requirements.in</code> 中的版本约束</li>\n<li>使用 <code>pip-compile --verbose</code> 查看详细信息</li>\n<li>考虑降级某些包的版本</li>\n</ul>\n<h3 id=\"2-Hash-不匹配\"><a href=\"#2-Hash-不匹配\" class=\"headerlink\" title=\"2. Hash 不匹配\"></a>2. Hash 不匹配</h3><p>如果出现 hash 不匹配：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"3-环境不一致\"><a href=\"#3-环境不一致\" class=\"headerlink\" title=\"3. 环境不一致\"></a>3. 环境不一致</h3><p>确保团队成员：</p>\n<ul>\n<li>使用相同的 Python 版本</li>\n<li>严格执行 <code>pip-sync</code></li>\n<li>不要手动 <code>pip install</code></li>\n</ul>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"1-自定义输出格式\"><a href=\"#1-自定义输出格式\" class=\"headerlink\" title=\"1. 自定义输出格式\"></a>1. 自定义输出格式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成带注释的依赖文件</span><br>pip-compile --annotate requirements.in<br><br><span class=\"hljs-comment\"># 生成带 hashes 的依赖文件</span><br>pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-多环境配置\"><a href=\"#2-多环境配置\" class=\"headerlink\" title=\"2. 多环境配置\"></a>2. 多环境配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 开发环境</span><br>pip-compile requirements-dev.in<br><br><span class=\"hljs-comment\"># 生产环境</span><br>pip-compile requirements.in --output-file requirements-prod.txt<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-依赖更新策略\"><a href=\"#3-依赖更新策略\" class=\"headerlink\" title=\"3. 依赖更新策略\"></a>3. 依赖更新策略</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只更新安全相关的包</span><br>pip-compile --upgrade-package flask --upgrade-package <span class=\"hljs-string\">&quot;requests&gt;=2.31.0&quot;</span><br><br><span class=\"hljs-comment\"># 保持现有版本</span><br>pip-compile --no-upgrade requirements.in<br></code></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过使用 <code>pip-tools</code>，我们可以：</p>\n<ul>\n<li>实现精确的依赖版本控制</li>\n<li>简化依赖管理流程</li>\n<li>确保团队环境一致性</li>\n<li>提高项目的可维护性</li>\n</ul>\n<p>希望这篇指南能帮助你更好地管理 Python 项目的依赖！<br><img src = \"/img/great.jpg\" width = \"70%\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/jazzband/pip-tools\">pip-tools 官方文档</a></li>\n<li><a href=\"https://packaging.python.org/\">Python Packaging User Guide</a></li>\n<li><a href=\"https://www.python.org/dev/peps/pep-0508/\">PEP 508 – Dependency specification for Python Software Packages</a></li>\n</ul>\n","more":"<h1 id=\"Python依赖管理利器：pip-tools完全指南\"><a href=\"#Python依赖管理利器：pip-tools完全指南\" class=\"headerlink\" title=\"Python依赖管理利器：pip-tools完全指南\"></a>Python依赖管理利器：pip-tools完全指南</h1><blockquote>\n<p> 本文由 <em>Claude 3.5 Sonnet</em> 协助生成.</p>\n</blockquote>\n<p><img src=\"https://img.shields.io/badge/Python-3.6+-blue.svg\" alt=\"Python Version\"><br><img src=\"https://img.shields.io/badge/pip--tools-6.13.0-green.svg\" alt=\"pip-tools\"></p>\n<p>在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致”在我这里能运行”的经典问题。<br><img src=\"/img/2025-01-16-23-58-21.png\" width=\"70%\" /><br>针对上述问题, 本文将详细介绍如何使用 <code>pip-tools</code>，实现精确的依赖版本控制。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#为什么需要-pip-tools\">为什么需要 pip-tools？</a></li>\n<li><a href=\"#环境准备\">环境准备</a></li>\n<li><a href=\"#pip-tools-的安装与使用\">pip-tools 的安装与使用</a></li>\n<li><a href=\"#最佳实践\">最佳实践</a></li>\n<li><a href=\"#常见问题解决\">常见问题解决</a></li>\n<li><a href=\"#高级用法\">高级用法</a></li>\n</ol>\n<h2 id=\"为什么需要-pip-tools？\"><a href=\"#为什么需要-pip-tools？\" class=\"headerlink\" title=\"为什么需要 pip-tools？\"></a>为什么需要 pip-tools？</h2><p>传统的依赖管理方式存在以下问题：</p>\n<ul>\n<li><code>requirements.txt</code> 手动维护容易出错</li>\n<li>间接依赖版本难以控制</li>\n<li>团队成员环境不一致</li>\n<li>依赖更新流程繁琐</li>\n</ul>\n<p><code>pip-tools</code> 通过以下特性解决这些问题：</p>\n<ul>\n<li>自动生成完整的依赖关系</li>\n<li>锁定所有依赖的具体版本</li>\n<li>支持开发环境和生产环境分离</li>\n<li>提供简单的依赖更新机制</li>\n</ul>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><h3 id=\"1-创建虚拟环境\"><a href=\"#1-创建虚拟环境\" class=\"headerlink\" title=\"1. 创建虚拟环境\"></a>1. 创建虚拟环境</h3><p>首先，我们需要创建一个独立的 Python 虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装 virtualenv（如果还没有安装）</span><br>pip install virtualenv<br><br><span class=\"hljs-comment\"># 创建虚拟环境</span><br>virtualenv venv<br><br><span class=\"hljs-comment\"># 激活虚拟环境</span><br><span class=\"hljs-comment\"># Linux/macOS:</span><br><span class=\"hljs-built_in\">source</span> venv/bin/activate<br><span class=\"hljs-comment\"># Windows:</span><br>.\\venv\\Scripts\\activate<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-项目结构\"><a href=\"#2-项目结构\" class=\"headerlink\" title=\"2. 项目结构\"></a>2. 项目结构</h3><p>推荐的项目结构如下：</p>\n<figure class=\"highlight mizar\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mizar\">my_project/<br>├── venv/<br>├── <span class=\"hljs-keyword\">requirements</span>.<span class=\"hljs-keyword\">in</span><br>├── <span class=\"hljs-keyword\">requirements</span>.txt<br>├── <span class=\"hljs-keyword\">requirements</span>-dev.<span class=\"hljs-keyword\">in</span>   # 可选：开发环境依赖<br>├── <span class=\"hljs-keyword\">requirements</span>-dev.txt  # 可选：开发环境依赖锁定文件<br>└── src/<br></code></pre></td></tr></table></figure>\n<h2 id=\"pip-tools-的安装与使用\"><a href=\"#pip-tools-的安装与使用\" class=\"headerlink\" title=\"pip-tools 的安装与使用\"></a>pip-tools 的安装与使用</h2><h3 id=\"1-安装-pip-tools\"><a href=\"#1-安装-pip-tools\" class=\"headerlink\" title=\"1. 安装 pip-tools\"></a>1. 安装 pip-tools</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pip-tools<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-创建依赖文件\"><a href=\"#2-创建依赖文件\" class=\"headerlink\" title=\"2. 创建依赖文件\"></a>2. 创建依赖文件</h3><p>创建 <code>requirements.in</code> 文件，列出直接依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements.in</span><br>flask<br>python-dotenv<br>openai<br>markdown-it-py<br>fairy-doc[cpu]<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意, 此处不同的依赖包必须分行呈现.</p>\n</blockquote>\n<h3 id=\"3-生成锁定文件\"><a href=\"#3-生成锁定文件\" class=\"headerlink\" title=\"3. 生成锁定文件\"></a>3. 生成锁定文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成 requirements.txt</span><br>pip-compile requirements.in<br><br><span class=\"hljs-comment\"># 如果有开发依赖</span><br>pip-compile requirements-dev.in<br></code></pre></td></tr></table></figure>\n<p>生成的 <code>requirements.txt</code> 示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># This file is autogenerated by pip-compile</span><br><span class=\"hljs-comment\"># To update, run:</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\">#    pip-compile requirements.in</span><br><span class=\"hljs-comment\">#</span><br>flask==2.3.3<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>python-dotenv==1.0.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>openai==0.27.8<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>markdown-it-py==3.0.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br>fairy-doc[cpu]==1.2.0<br>  --<span class=\"hljs-built_in\">hash</span>=sha256:...<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-安装依赖\"><a href=\"#4-安装依赖\" class=\"headerlink\" title=\"4. 安装依赖\"></a>4. 安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 安装所有依赖</span><br>pip-sync requirements.txt<br><br><span class=\"hljs-comment\"># 如果同时需要开发依赖</span><br>pip-sync requirements.txt requirements-dev.txt<br></code></pre></td></tr></table></figure>\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"1-版本控制\"><a href=\"#1-版本控制\" class=\"headerlink\" title=\"1. 版本控制\"></a>1. 版本控制</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements.in</span><br>flask&gt;=2.0.0,&lt;3.0.0  <span class=\"hljs-comment\"># 指定版本范围</span><br>python-dotenv~=1.0.0  <span class=\"hljs-comment\"># 允许补丁版本更新</span><br>openai==0.27.8       <span class=\"hljs-comment\"># 锁定具体版本</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"2-依赖分组\"><a href=\"#2-依赖分组\" class=\"headerlink\" title=\"2. 依赖分组\"></a>2. 依赖分组</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># requirements-dev.in</span><br>-r requirements.in    <span class=\"hljs-comment\"># 包含基础依赖</span><br>pytest               <span class=\"hljs-comment\"># 测试框架</span><br>black                <span class=\"hljs-comment\"># 代码格式化</span><br>flake8               <span class=\"hljs-comment\"># 代码检查</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"3-更新依赖\"><a href=\"#3-更新依赖\" class=\"headerlink\" title=\"3. 更新依赖\"></a>3. 更新依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 更新单个包</span><br>pip-compile --upgrade-package flask requirements.in<br><br><span class=\"hljs-comment\"># 更新所有包</span><br>pip-compile --upgrade requirements.in<br></code></pre></td></tr></table></figure>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><h3 id=\"1-依赖冲突\"><a href=\"#1-依赖冲突\" class=\"headerlink\" title=\"1. 依赖冲突\"></a>1. 依赖冲突</h3><p>如果遇到依赖冲突，可以：</p>\n<ul>\n<li>检查 <code>requirements.in</code> 中的版本约束</li>\n<li>使用 <code>pip-compile --verbose</code> 查看详细信息</li>\n<li>考虑降级某些包的版本</li>\n</ul>\n<h3 id=\"2-Hash-不匹配\"><a href=\"#2-Hash-不匹配\" class=\"headerlink\" title=\"2. Hash 不匹配\"></a>2. Hash 不匹配</h3><p>如果出现 hash 不匹配：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"3-环境不一致\"><a href=\"#3-环境不一致\" class=\"headerlink\" title=\"3. 环境不一致\"></a>3. 环境不一致</h3><p>确保团队成员：</p>\n<ul>\n<li>使用相同的 Python 版本</li>\n<li>严格执行 <code>pip-sync</code></li>\n<li>不要手动 <code>pip install</code></li>\n</ul>\n<h2 id=\"高级用法\"><a href=\"#高级用法\" class=\"headerlink\" title=\"高级用法\"></a>高级用法</h2><h3 id=\"1-自定义输出格式\"><a href=\"#1-自定义输出格式\" class=\"headerlink\" title=\"1. 自定义输出格式\"></a>1. 自定义输出格式</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成带注释的依赖文件</span><br>pip-compile --annotate requirements.in<br><br><span class=\"hljs-comment\"># 生成带 hashes 的依赖文件</span><br>pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-多环境配置\"><a href=\"#2-多环境配置\" class=\"headerlink\" title=\"2. 多环境配置\"></a>2. 多环境配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 开发环境</span><br>pip-compile requirements-dev.in<br><br><span class=\"hljs-comment\"># 生产环境</span><br>pip-compile requirements.in --output-file requirements-prod.txt<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-依赖更新策略\"><a href=\"#3-依赖更新策略\" class=\"headerlink\" title=\"3. 依赖更新策略\"></a>3. 依赖更新策略</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 只更新安全相关的包</span><br>pip-compile --upgrade-package flask --upgrade-package <span class=\"hljs-string\">&quot;requests&gt;=2.31.0&quot;</span><br><br><span class=\"hljs-comment\"># 保持现有版本</span><br>pip-compile --no-upgrade requirements.in<br></code></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>通过使用 <code>pip-tools</code>，我们可以：</p>\n<ul>\n<li>实现精确的依赖版本控制</li>\n<li>简化依赖管理流程</li>\n<li>确保团队环境一致性</li>\n<li>提高项目的可维护性</li>\n</ul>\n<p>希望这篇指南能帮助你更好地管理 Python 项目的依赖！<br><img src = \"/img/great.jpg\" width = \"70%\"></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/jazzband/pip-tools\">pip-tools 官方文档</a></li>\n<li><a href=\"https://packaging.python.org/\">Python Packaging User Guide</a></li>\n<li><a href=\"https://www.python.org/dev/peps/pep-0508/\">PEP 508 – Dependency specification for Python Software Packages</a></li>\n</ul>\n"},{"title":"协议切换与认证配置","date":"2025-01-18T04:47:21.000Z","excerpt":"已经为服务器配置了代理还是在初次push时显示 Connection timed out?😱 不要急, 可能需要在SSH与Https协议之间进行切换~","index_img":"/img/哭哭帕克.jpg","_content":"# Git 远程仓库认证：从 SSH 到 HTTPS\n\n## 背景介绍\n在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。\n\n## 认证机制解析\n\n### 双层认证架构\n1. **服务器层认证**\n   - 用于验证用户对服务器的访问权限\n   - 通常通过 SSH 密钥或密码完成\n\n2. **仓库层认证**\n   - 验证用户对特定 Git 仓库的操作权限\n   - 独立于服务器认证系统\n   - 确保代码安全性和提交者身份\n\n### SSH vs HTTPS \n\n\n1. **SSH 协议**\n   - 优势：\n     - 更安全，使用密钥对进行加密\n     - 配置一次可永久使用\n     - 可以避免每次输入密码\n   - 劣势：\n     - 可能被防火墙阻止（22端口）\n     - 在某些企业网络中可能无法使用\n     - 配置相对复杂\n\n2. **HTTPS 协议**\n   - 优势：\n     - 几乎总是可用（443端口）\n     - 穿透防火墙能力强\n     - 配置简单\n   - 劣势：\n     - 需要管理凭证\n     - 可能需要频繁输入认证信息\n\n## 连接问题分析\n\n### SSH 超时问题解析\nSSH 连接可能出现超时的原因：\n1. **网络限制**\n   - 企业防火墙可能会阻止或限制 SSH 连接\n   - 某些网络环境会定期切断长时间的 SSH 连接\n\n2. **代理影响**\n   - SSH 不会自动使用系统代理\n   - 需要额外配置 SSH 的代理设置\n\n3. **防火墙策略**\n   - 22 端口经常被封锁\n   - 某些地区可能限制 SSH 协议\n\n### HTTPS 连接优势\n1. **标准 Web 端口**\n   - 使用 443 端口，几乎总是开放的\n   - 与普通网页浏览使用相同的端口\n\n2. **代理兼容**\n   - 自动使用系统代理设置\n   - 更好的网络兼容性\n\n3. **连接特性**\n   - 非持久连接，每次请求独立\n   - 不受长连接限制影响\n\n## 协议转换实践\n在尝试直接`git push`时显示:\n![](/img/2025-01-18-12-58-38.png)\n通过执行命令`git remote -v`查看当前远程仓库的地址:\n![](/img/2025-01-18-13-01-29.png)\n> `git@`的前缀格式说明是通过`ssh`的方式, 我们尝试修改为`https`的协议来解决超时问题.\n\n更新仓库的URL:\n```bash\ngit remote set-url origin https://github.com/用户名/仓库名.git\n```\ne.g.: \n![](/img/2025-01-18-13-03-21.png)\n> 在更新之后执行`get remote -v`, 检查发现已经转换为`HTTPS`.\n\n\n### 配置凭证管理\n此时依旧无法直接`git push`, 因为仓库层认证的密码验证方式已经不受`github`支持, 如果尝试通过用户名-密码的方式验证, 将会失败:\n![](/img/2025-01-18-13-09-11.png)\n\n因此我们需要通过 **个人访问令牌**(PAT) 的方式来鉴权.\n1. **配置凭证管理:**\n```bash\n# 永久存储凭证\ngit config --global credential.helper store\n\n# 或临时缓存（如15分钟）\ngit config --global credential.helper 'cache --timeout=900'\n```\n> 如果不希望影响其他仓库, 去除`--global`即可.\n\n2. **获取PAT**:\n   1. 访问 GitHub Settings;\n   2. 下滑到底部,进入 `Developer settings`;\n   3. 选择 `Personal access tokens` → `Tokens (classic)`;\n   4. 在右上角选择生成新的`access token`;\n   5. 生成新令牌并设置适当的权限范围 (至少勾选`repo`).\n![](/img/2025-01-18-13-15-38.png)\n> 在生成PAT之后立即复制并保存.\n\n\n### 通过PAT鉴权\n此时, 我们可以`git push`然后利用PAT来鉴权:\n```bash\ngit push\nUsername: <GitHub用户名>\nPassword: <个人访问令牌>\n```\ne.g.\n![](/img/2025-01-18-13-23-22.png)\n\n## 安全相关建议\n\n### 凭证管理\n1. **凭证存储位置**\n   - Linux/Mac: `~/.git-credentials`\n   - Windows: `%USERPROFILE%\\.git-credentials`\n\n2. **安全建议**\n   - 定期更新访问令牌\n   - 在共享环境使用临时缓存\n   - 及时清理凭证缓存\n\n### 故障排除\n```bash\n# 删除全局凭证配置\ngit config --global --unset credential.helper\n\n# 删除凭证文件\nrm ~/.git-credentials  # Linux/Mac\ndel \"%USERPROFILE%\\.git-credentials\"  # Windows\n```\n","source":"_posts/其他/认证配置.md","raw":"---\ntitle: 协议切换与认证配置\ndate: 2025-01-18 12:47:21\ntags: \n- 服务器\n- PAT\ncategories: 通用技能\nexcerpt: 已经为服务器配置了代理还是在初次push时显示 Connection timed out?😱 不要急, 可能需要在SSH与Https协议之间进行切换~\nindex_img: /img/哭哭帕克.jpg\n---\n# Git 远程仓库认证：从 SSH 到 HTTPS\n\n## 背景介绍\n在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。\n\n## 认证机制解析\n\n### 双层认证架构\n1. **服务器层认证**\n   - 用于验证用户对服务器的访问权限\n   - 通常通过 SSH 密钥或密码完成\n\n2. **仓库层认证**\n   - 验证用户对特定 Git 仓库的操作权限\n   - 独立于服务器认证系统\n   - 确保代码安全性和提交者身份\n\n### SSH vs HTTPS \n\n\n1. **SSH 协议**\n   - 优势：\n     - 更安全，使用密钥对进行加密\n     - 配置一次可永久使用\n     - 可以避免每次输入密码\n   - 劣势：\n     - 可能被防火墙阻止（22端口）\n     - 在某些企业网络中可能无法使用\n     - 配置相对复杂\n\n2. **HTTPS 协议**\n   - 优势：\n     - 几乎总是可用（443端口）\n     - 穿透防火墙能力强\n     - 配置简单\n   - 劣势：\n     - 需要管理凭证\n     - 可能需要频繁输入认证信息\n\n## 连接问题分析\n\n### SSH 超时问题解析\nSSH 连接可能出现超时的原因：\n1. **网络限制**\n   - 企业防火墙可能会阻止或限制 SSH 连接\n   - 某些网络环境会定期切断长时间的 SSH 连接\n\n2. **代理影响**\n   - SSH 不会自动使用系统代理\n   - 需要额外配置 SSH 的代理设置\n\n3. **防火墙策略**\n   - 22 端口经常被封锁\n   - 某些地区可能限制 SSH 协议\n\n### HTTPS 连接优势\n1. **标准 Web 端口**\n   - 使用 443 端口，几乎总是开放的\n   - 与普通网页浏览使用相同的端口\n\n2. **代理兼容**\n   - 自动使用系统代理设置\n   - 更好的网络兼容性\n\n3. **连接特性**\n   - 非持久连接，每次请求独立\n   - 不受长连接限制影响\n\n## 协议转换实践\n在尝试直接`git push`时显示:\n![](/img/2025-01-18-12-58-38.png)\n通过执行命令`git remote -v`查看当前远程仓库的地址:\n![](/img/2025-01-18-13-01-29.png)\n> `git@`的前缀格式说明是通过`ssh`的方式, 我们尝试修改为`https`的协议来解决超时问题.\n\n更新仓库的URL:\n```bash\ngit remote set-url origin https://github.com/用户名/仓库名.git\n```\ne.g.: \n![](/img/2025-01-18-13-03-21.png)\n> 在更新之后执行`get remote -v`, 检查发现已经转换为`HTTPS`.\n\n\n### 配置凭证管理\n此时依旧无法直接`git push`, 因为仓库层认证的密码验证方式已经不受`github`支持, 如果尝试通过用户名-密码的方式验证, 将会失败:\n![](/img/2025-01-18-13-09-11.png)\n\n因此我们需要通过 **个人访问令牌**(PAT) 的方式来鉴权.\n1. **配置凭证管理:**\n```bash\n# 永久存储凭证\ngit config --global credential.helper store\n\n# 或临时缓存（如15分钟）\ngit config --global credential.helper 'cache --timeout=900'\n```\n> 如果不希望影响其他仓库, 去除`--global`即可.\n\n2. **获取PAT**:\n   1. 访问 GitHub Settings;\n   2. 下滑到底部,进入 `Developer settings`;\n   3. 选择 `Personal access tokens` → `Tokens (classic)`;\n   4. 在右上角选择生成新的`access token`;\n   5. 生成新令牌并设置适当的权限范围 (至少勾选`repo`).\n![](/img/2025-01-18-13-15-38.png)\n> 在生成PAT之后立即复制并保存.\n\n\n### 通过PAT鉴权\n此时, 我们可以`git push`然后利用PAT来鉴权:\n```bash\ngit push\nUsername: <GitHub用户名>\nPassword: <个人访问令牌>\n```\ne.g.\n![](/img/2025-01-18-13-23-22.png)\n\n## 安全相关建议\n\n### 凭证管理\n1. **凭证存储位置**\n   - Linux/Mac: `~/.git-credentials`\n   - Windows: `%USERPROFILE%\\.git-credentials`\n\n2. **安全建议**\n   - 定期更新访问令牌\n   - 在共享环境使用临时缓存\n   - 及时清理凭证缓存\n\n### 故障排除\n```bash\n# 删除全局凭证配置\ngit config --global --unset credential.helper\n\n# 删除凭证文件\nrm ~/.git-credentials  # Linux/Mac\ndel \"%USERPROFILE%\\.git-credentials\"  # Windows\n```\n","slug":"其他/认证配置","published":1,"updated":"2025-01-19T11:46:34.126Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4w00022dwqg3wok0aew","content":"<h1 id=\"Git-远程仓库认证：从-SSH-到-HTTPS\"><a href=\"#Git-远程仓库认证：从-SSH-到-HTTPS\" class=\"headerlink\" title=\"Git 远程仓库认证：从 SSH 到 HTTPS\"></a>Git 远程仓库认证：从 SSH 到 HTTPS</h1><h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。</p>\n<h2 id=\"认证机制解析\"><a href=\"#认证机制解析\" class=\"headerlink\" title=\"认证机制解析\"></a>认证机制解析</h2><h3 id=\"双层认证架构\"><a href=\"#双层认证架构\" class=\"headerlink\" title=\"双层认证架构\"></a>双层认证架构</h3><ol>\n<li><p><strong>服务器层认证</strong></p>\n<ul>\n<li>用于验证用户对服务器的访问权限</li>\n<li>通常通过 SSH 密钥或密码完成</li>\n</ul>\n</li>\n<li><p><strong>仓库层认证</strong></p>\n<ul>\n<li>验证用户对特定 Git 仓库的操作权限</li>\n<li>独立于服务器认证系统</li>\n<li>确保代码安全性和提交者身份</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"SSH-vs-HTTPS\"><a href=\"#SSH-vs-HTTPS\" class=\"headerlink\" title=\"SSH vs HTTPS\"></a>SSH vs HTTPS</h3><ol>\n<li><p><strong>SSH 协议</strong></p>\n<ul>\n<li>优势：<ul>\n<li>更安全，使用密钥对进行加密</li>\n<li>配置一次可永久使用</li>\n<li>可以避免每次输入密码</li>\n</ul>\n</li>\n<li>劣势：<ul>\n<li>可能被防火墙阻止（22端口）</li>\n<li>在某些企业网络中可能无法使用</li>\n<li>配置相对复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTPS 协议</strong></p>\n<ul>\n<li>优势：<ul>\n<li>几乎总是可用（443端口）</li>\n<li>穿透防火墙能力强</li>\n<li>配置简单</li>\n</ul>\n</li>\n<li>劣势：<ul>\n<li>需要管理凭证</li>\n<li>可能需要频繁输入认证信息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"连接问题分析\"><a href=\"#连接问题分析\" class=\"headerlink\" title=\"连接问题分析\"></a>连接问题分析</h2><h3 id=\"SSH-超时问题解析\"><a href=\"#SSH-超时问题解析\" class=\"headerlink\" title=\"SSH 超时问题解析\"></a>SSH 超时问题解析</h3><p>SSH 连接可能出现超时的原因：</p>\n<ol>\n<li><p><strong>网络限制</strong></p>\n<ul>\n<li>企业防火墙可能会阻止或限制 SSH 连接</li>\n<li>某些网络环境会定期切断长时间的 SSH 连接</li>\n</ul>\n</li>\n<li><p><strong>代理影响</strong></p>\n<ul>\n<li>SSH 不会自动使用系统代理</li>\n<li>需要额外配置 SSH 的代理设置</li>\n</ul>\n</li>\n<li><p><strong>防火墙策略</strong></p>\n<ul>\n<li>22 端口经常被封锁</li>\n<li>某些地区可能限制 SSH 协议</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"HTTPS-连接优势\"><a href=\"#HTTPS-连接优势\" class=\"headerlink\" title=\"HTTPS 连接优势\"></a>HTTPS 连接优势</h3><ol>\n<li><p><strong>标准 Web 端口</strong></p>\n<ul>\n<li>使用 443 端口，几乎总是开放的</li>\n<li>与普通网页浏览使用相同的端口</li>\n</ul>\n</li>\n<li><p><strong>代理兼容</strong></p>\n<ul>\n<li>自动使用系统代理设置</li>\n<li>更好的网络兼容性</li>\n</ul>\n</li>\n<li><p><strong>连接特性</strong></p>\n<ul>\n<li>非持久连接，每次请求独立</li>\n<li>不受长连接限制影响</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"协议转换实践\"><a href=\"#协议转换实践\" class=\"headerlink\" title=\"协议转换实践\"></a>协议转换实践</h2><p>在尝试直接<code>git push</code>时显示:<br><img src=\"/img/2025-01-18-12-58-38.png\" alt=\"\"><br>通过执行命令<code>git remote -v</code>查看当前远程仓库的地址:<br><img src=\"/img/2025-01-18-13-01-29.png\" alt=\"\"></p>\n<blockquote>\n<p><code>git@</code>的前缀格式说明是通过<code>ssh</code>的方式, 我们尝试修改为<code>https</code>的协议来解决超时问题.</p>\n</blockquote>\n<p>更新仓库的URL:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git remote set-url origin https://github.com/用户名/仓库名.git<br></code></pre></td></tr></table></figure><br>e.g.:<br><img src=\"/img/2025-01-18-13-03-21.png\" alt=\"\"></p>\n<blockquote>\n<p>在更新之后执行<code>get remote -v</code>, 检查发现已经转换为<code>HTTPS</code>.</p>\n</blockquote>\n<h3 id=\"配置凭证管理\"><a href=\"#配置凭证管理\" class=\"headerlink\" title=\"配置凭证管理\"></a>配置凭证管理</h3><p>此时依旧无法直接<code>git push</code>, 因为仓库层认证的密码验证方式已经不受<code>github</code>支持, 如果尝试通过用户名-密码的方式验证, 将会失败:<br><img src=\"/img/2025-01-18-13-09-11.png\" alt=\"\"></p>\n<p>因此我们需要通过 <strong>个人访问令牌</strong>(PAT) 的方式来鉴权.</p>\n<ol>\n<li><p><strong>配置凭证管理:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 永久存储凭证</span><br>git config --global credential.helper store<br><br><span class=\"hljs-comment\"># 或临时缓存（如15分钟）</span><br>git config --global credential.helper <span class=\"hljs-string\">&#x27;cache --timeout=900&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不希望影响其他仓库, 去除<code>--global</code>即可.</p>\n</blockquote>\n</li>\n<li><p><strong>获取PAT</strong>:</p>\n<ol>\n<li>访问 GitHub Settings;</li>\n<li>下滑到底部,进入 <code>Developer settings</code>;</li>\n<li>选择 <code>Personal access tokens</code> → <code>Tokens (classic)</code>;</li>\n<li>在右上角选择生成新的<code>access token</code>;</li>\n<li>生成新令牌并设置适当的权限范围 (至少勾选<code>repo</code>).<br><img src=\"/img/2025-01-18-13-15-38.png\" alt=\"\"><blockquote>\n<p>在生成PAT之后立即复制并保存.</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"通过PAT鉴权\"><a href=\"#通过PAT鉴权\" class=\"headerlink\" title=\"通过PAT鉴权\"></a>通过PAT鉴权</h3><p>此时, 我们可以<code>git push</code>然后利用PAT来鉴权:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push<br>Username: &lt;GitHub用户名&gt;<br>Password: &lt;个人访问令牌&gt;<br></code></pre></td></tr></table></figure><br>e.g.<br><img src=\"/img/2025-01-18-13-23-22.png\" alt=\"\"></p>\n<h2 id=\"安全相关建议\"><a href=\"#安全相关建议\" class=\"headerlink\" title=\"安全相关建议\"></a>安全相关建议</h2><h3 id=\"凭证管理\"><a href=\"#凭证管理\" class=\"headerlink\" title=\"凭证管理\"></a>凭证管理</h3><ol>\n<li><p><strong>凭证存储位置</strong></p>\n<ul>\n<li>Linux/Mac: <code>~/.git-credentials</code></li>\n<li>Windows: <code>%USERPROFILE%\\.git-credentials</code></li>\n</ul>\n</li>\n<li><p><strong>安全建议</strong></p>\n<ul>\n<li>定期更新访问令牌</li>\n<li>在共享环境使用临时缓存</li>\n<li>及时清理凭证缓存</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"故障排除\"><a href=\"#故障排除\" class=\"headerlink\" title=\"故障排除\"></a>故障排除</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 删除全局凭证配置</span><br>git config --global --<span class=\"hljs-built_in\">unset</span> credential.helper<br><br><span class=\"hljs-comment\"># 删除凭证文件</span><br><span class=\"hljs-built_in\">rm</span> ~/.git-credentials  <span class=\"hljs-comment\"># Linux/Mac</span><br>del <span class=\"hljs-string\">&quot;%USERPROFILE%\\.git-credentials&quot;</span>  <span class=\"hljs-comment\"># Windows</span><br></code></pre></td></tr></table></figure>\n","more":"<h1 id=\"Git-远程仓库认证：从-SSH-到-HTTPS\"><a href=\"#Git-远程仓库认证：从-SSH-到-HTTPS\" class=\"headerlink\" title=\"Git 远程仓库认证：从 SSH 到 HTTPS\"></a>Git 远程仓库认证：从 SSH 到 HTTPS</h1><h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。</p>\n<h2 id=\"认证机制解析\"><a href=\"#认证机制解析\" class=\"headerlink\" title=\"认证机制解析\"></a>认证机制解析</h2><h3 id=\"双层认证架构\"><a href=\"#双层认证架构\" class=\"headerlink\" title=\"双层认证架构\"></a>双层认证架构</h3><ol>\n<li><p><strong>服务器层认证</strong></p>\n<ul>\n<li>用于验证用户对服务器的访问权限</li>\n<li>通常通过 SSH 密钥或密码完成</li>\n</ul>\n</li>\n<li><p><strong>仓库层认证</strong></p>\n<ul>\n<li>验证用户对特定 Git 仓库的操作权限</li>\n<li>独立于服务器认证系统</li>\n<li>确保代码安全性和提交者身份</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"SSH-vs-HTTPS\"><a href=\"#SSH-vs-HTTPS\" class=\"headerlink\" title=\"SSH vs HTTPS\"></a>SSH vs HTTPS</h3><ol>\n<li><p><strong>SSH 协议</strong></p>\n<ul>\n<li>优势：<ul>\n<li>更安全，使用密钥对进行加密</li>\n<li>配置一次可永久使用</li>\n<li>可以避免每次输入密码</li>\n</ul>\n</li>\n<li>劣势：<ul>\n<li>可能被防火墙阻止（22端口）</li>\n<li>在某些企业网络中可能无法使用</li>\n<li>配置相对复杂</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>HTTPS 协议</strong></p>\n<ul>\n<li>优势：<ul>\n<li>几乎总是可用（443端口）</li>\n<li>穿透防火墙能力强</li>\n<li>配置简单</li>\n</ul>\n</li>\n<li>劣势：<ul>\n<li>需要管理凭证</li>\n<li>可能需要频繁输入认证信息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"连接问题分析\"><a href=\"#连接问题分析\" class=\"headerlink\" title=\"连接问题分析\"></a>连接问题分析</h2><h3 id=\"SSH-超时问题解析\"><a href=\"#SSH-超时问题解析\" class=\"headerlink\" title=\"SSH 超时问题解析\"></a>SSH 超时问题解析</h3><p>SSH 连接可能出现超时的原因：</p>\n<ol>\n<li><p><strong>网络限制</strong></p>\n<ul>\n<li>企业防火墙可能会阻止或限制 SSH 连接</li>\n<li>某些网络环境会定期切断长时间的 SSH 连接</li>\n</ul>\n</li>\n<li><p><strong>代理影响</strong></p>\n<ul>\n<li>SSH 不会自动使用系统代理</li>\n<li>需要额外配置 SSH 的代理设置</li>\n</ul>\n</li>\n<li><p><strong>防火墙策略</strong></p>\n<ul>\n<li>22 端口经常被封锁</li>\n<li>某些地区可能限制 SSH 协议</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"HTTPS-连接优势\"><a href=\"#HTTPS-连接优势\" class=\"headerlink\" title=\"HTTPS 连接优势\"></a>HTTPS 连接优势</h3><ol>\n<li><p><strong>标准 Web 端口</strong></p>\n<ul>\n<li>使用 443 端口，几乎总是开放的</li>\n<li>与普通网页浏览使用相同的端口</li>\n</ul>\n</li>\n<li><p><strong>代理兼容</strong></p>\n<ul>\n<li>自动使用系统代理设置</li>\n<li>更好的网络兼容性</li>\n</ul>\n</li>\n<li><p><strong>连接特性</strong></p>\n<ul>\n<li>非持久连接，每次请求独立</li>\n<li>不受长连接限制影响</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"协议转换实践\"><a href=\"#协议转换实践\" class=\"headerlink\" title=\"协议转换实践\"></a>协议转换实践</h2><p>在尝试直接<code>git push</code>时显示:<br><img src=\"/img/2025-01-18-12-58-38.png\" alt=\"\"><br>通过执行命令<code>git remote -v</code>查看当前远程仓库的地址:<br><img src=\"/img/2025-01-18-13-01-29.png\" alt=\"\"></p>\n<blockquote>\n<p><code>git@</code>的前缀格式说明是通过<code>ssh</code>的方式, 我们尝试修改为<code>https</code>的协议来解决超时问题.</p>\n</blockquote>\n<p>更新仓库的URL:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git remote set-url origin https://github.com/用户名/仓库名.git<br></code></pre></td></tr></table></figure><br>e.g.:<br><img src=\"/img/2025-01-18-13-03-21.png\" alt=\"\"></p>\n<blockquote>\n<p>在更新之后执行<code>get remote -v</code>, 检查发现已经转换为<code>HTTPS</code>.</p>\n</blockquote>\n<h3 id=\"配置凭证管理\"><a href=\"#配置凭证管理\" class=\"headerlink\" title=\"配置凭证管理\"></a>配置凭证管理</h3><p>此时依旧无法直接<code>git push</code>, 因为仓库层认证的密码验证方式已经不受<code>github</code>支持, 如果尝试通过用户名-密码的方式验证, 将会失败:<br><img src=\"/img/2025-01-18-13-09-11.png\" alt=\"\"></p>\n<p>因此我们需要通过 <strong>个人访问令牌</strong>(PAT) 的方式来鉴权.</p>\n<ol>\n<li><p><strong>配置凭证管理:</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 永久存储凭证</span><br>git config --global credential.helper store<br><br><span class=\"hljs-comment\"># 或临时缓存（如15分钟）</span><br>git config --global credential.helper <span class=\"hljs-string\">&#x27;cache --timeout=900&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不希望影响其他仓库, 去除<code>--global</code>即可.</p>\n</blockquote>\n</li>\n<li><p><strong>获取PAT</strong>:</p>\n<ol>\n<li>访问 GitHub Settings;</li>\n<li>下滑到底部,进入 <code>Developer settings</code>;</li>\n<li>选择 <code>Personal access tokens</code> → <code>Tokens (classic)</code>;</li>\n<li>在右上角选择生成新的<code>access token</code>;</li>\n<li>生成新令牌并设置适当的权限范围 (至少勾选<code>repo</code>).<br><img src=\"/img/2025-01-18-13-15-38.png\" alt=\"\"><blockquote>\n<p>在生成PAT之后立即复制并保存.</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"通过PAT鉴权\"><a href=\"#通过PAT鉴权\" class=\"headerlink\" title=\"通过PAT鉴权\"></a>通过PAT鉴权</h3><p>此时, 我们可以<code>git push</code>然后利用PAT来鉴权:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push<br>Username: &lt;GitHub用户名&gt;<br>Password: &lt;个人访问令牌&gt;<br></code></pre></td></tr></table></figure><br>e.g.<br><img src=\"/img/2025-01-18-13-23-22.png\" alt=\"\"></p>\n<h2 id=\"安全相关建议\"><a href=\"#安全相关建议\" class=\"headerlink\" title=\"安全相关建议\"></a>安全相关建议</h2><h3 id=\"凭证管理\"><a href=\"#凭证管理\" class=\"headerlink\" title=\"凭证管理\"></a>凭证管理</h3><ol>\n<li><p><strong>凭证存储位置</strong></p>\n<ul>\n<li>Linux/Mac: <code>~/.git-credentials</code></li>\n<li>Windows: <code>%USERPROFILE%\\.git-credentials</code></li>\n</ul>\n</li>\n<li><p><strong>安全建议</strong></p>\n<ul>\n<li>定期更新访问令牌</li>\n<li>在共享环境使用临时缓存</li>\n<li>及时清理凭证缓存</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"故障排除\"><a href=\"#故障排除\" class=\"headerlink\" title=\"故障排除\"></a>故障排除</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 删除全局凭证配置</span><br>git config --global --<span class=\"hljs-built_in\">unset</span> credential.helper<br><br><span class=\"hljs-comment\"># 删除凭证文件</span><br><span class=\"hljs-built_in\">rm</span> ~/.git-credentials  <span class=\"hljs-comment\"># Linux/Mac</span><br>del <span class=\"hljs-string\">&quot;%USERPROFILE%\\.git-credentials&quot;</span>  <span class=\"hljs-comment\"># Windows</span><br></code></pre></td></tr></table></figure>\n"},{"title":"JavaScript","date":"2025-01-09T06:06:30.000Z","excerpt":"一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)","math":true,"index_img":"/img/料理的加护.jpg","_content":"> JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「**料理的加护**」下, 尽可能将JS处理得更加**可口**一些)\n<img src=\"/img/料理的加护.jpg\" width = \"35%\">\n\n# 创建JS代码块\n## 变量\n### `var` or `let`?\n`var`先于`let`的产生, 后者是现代版本的JS中新的关键字.\n\n使用`var`, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是`let`并不适用.\n```js\nmyName = \"Chris\";\n\nfunction logName() {\n  console.log(myName);\n}\n\nlogName(); //输出\"Chris\"\n\nvar myName = \"Aniya\";\nlogName(); //输出\"Aniya\"\n```\n\n除此之外, 可以使用`var`前后声明相同的变量, 这并不会报错:\n```js\nvar myName = \"Chris\";\nvar myName = \"Bob\";\n```\n\n而`let`只能声明一次:\n```js\nlet myName = \"Chris\";\nmyName = \"Bob\";\n```\n\n因此, 在代码编写中应尽量**多使用**`let`而非`var`, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n\n\n### 变量命名的规则\n与C语言类似, 建议以 **字母、数字、下划线** 组成的标识符来命名变量.\n- 不可用`_`开头, 因为可能被JS设计为特殊的含义;\n- 不可用数字开头, 否则引发错误;\n- 大小写敏感;\n- 建议采用 **小写驼峰命名法** ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n- 避免使用保留字, 比如`var`,`let`,`for`等.\n\n### 变量类型\n\n```js\nlet myAge = 20 ;// 数字\nlet dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串\nlet test = 6 < 3; //boolean\n\n//数组类型\nlet myNameArray = [\"Chris\", \"Bob\", \"Jim\"];\nlet myNumberArray = [10, 15, 40];\n\n//对象类型\nlet dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n```\n> 对象类型的访问与结构体相似, `dog.name;`\n\n在上面的几种变量类型中, 我们都采用`let`关键字声明变量, 这体现了JS是一种 **动态类型语言** ,即无需指定变量包含的数据类型.\n\n同时, 这也意味着我们可以像`python`一样对同一个变量先后赋值不同类型的值:\n```js\nlet myNumber = \"500\";\ntypeof myNumber;\n// 输出 'string'\n\nmyNumber = 500; \ntypeof myNumber;\n//输出'number'\n```\n\n\n## 函数\n- $\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n```js\nexampleFunction();\n\nfunction exampleFunction() {\n  console.log(\"函数内\");\n  console.log(x);\n}\n```\n> 由于 **提升** 的存在, 上述的函数调用不会出错.\n\n\n### 默认参数\n在编写函数时, 可以通过在参数名称后添加`=`, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\n```js\nfunction greeding(name = \"my friend\") {\n    console.log(`Hello, ${name}!`);\n}\nhello(); //Hello, my friend!\nhello(\"world\"); //Hello, world!\n```\n\n<br>\n\n事件处理函数的默认接受值是`event`:\n```html\n<button>\nonclick\n</button>\n\n<p>\nnothing here\n</p>\n\n<script>\nbtn = document.querySelector(\"button\")\npara = document.querySelector(\"p\")\n\nbtn.onclick = click;\n\nfunction click(string){\n  console.log(\"clicked!\")\n  para.textContent = string;\n}\n</script>\n```\n1. 上述的`btn`在点击之后调用函数`click`, 该函数需要一个参数`string`, 由于`btn.onclick = click;`的绑定方式, 我们无法指定传参的值, 因此点击之后的`para`的内容显示为: `[object PointerEvent]`;\n2. `textContent`是属性而非方法, 因此采用赋值实现;\n\n\n```js\nbtn.onclick = function click(string) {\n  console.log(\"clicked!\")\n  para.textContent = \"You have clicked the button!\";\n}\n```\n> 将上述的绑定方式如此改写, 可以在`btn`外对`string`进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n\n\n### 箭头函数\n在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:\n```js\nfunction myFunction() {\n  alert(\"你好\");\n}\n\n// 匿名函数\n(function () {\n  alert(\"你好\");\n});\n```\n> 正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\n```js\nfunction logKey(event) {\n  console.log(`You pressed \"${event.key}\".`);\n}\n\ntextBox.addEventListener(\"keydown\", logKey);\n```\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\n```js\ntextBox.addEventListener(\"keydown\", function (event) {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而**箭头函数**则是在此情况下更简洁的函数定义方式:\n```js\ntextBox.addEventListener(\"keydown\", (event) => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n\n//如果函数只接受一个参数, 也可以省略参数周围的括号\ntextBox.addEventListener(\"keydown\", event => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n\n如果只包含一行的`return`,则可以忽略`{}`和`return`关键字:\n```js\nconst originals = [1, 2, 3];\n\nconst doubled = originals.map(item => item * 2);\n\nconsole.log(doubled); // [2, 4, 6]\n```\n> `item => item * 2`等价于:\n```js\nfunction doubleItem(item) {\n  return item * 2;\n}\n```\n\n#### 一个实例\n```html\n<input id=\"textBox\" type=\"text\" />\n<div id=\"output\"></div>\n```\n```js\nconst textBox = document.querySelector(\"#textBox\");\nconst output = document.querySelector(\"#output\");\n\ntextBox.addEventListener(\"keydown\", (event) => {\n  output.textContent = `You pressed \"${event.key}\".`;\n});\n```\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n\n### 函数作用域和冲突\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部`let`定义的变量, 以及`const`定义的常量可以在函数内部访问.\n\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n```html\n<!-- Excerpt from my HTML -->\n<script src=\"first.js\"></script>\n<script src=\"second.js\"></script>\n<script>\n  greeting();\n</script>\n```\n> 如果两个JS文件都定义了`greeting`函数, 则只有第一个文件中的函数才会被调用.\n\n## 数据类型\n### 数字和操作符\n大部分与C语言相同, 概括需要注意的差异:\n- JS当中只有一种数字类型 -- `number`, 对于整型或者浮点数的初始化得到的量, 由`typeof`均得到`number`;\n- 算术运算符: 求幂为`**`;\n- 常量无法使用自增或自减,~~好像也是C语言的 忘了~~\n- `===`表示严格等于, `!==`表示不等于;\n> 同时存在`==`和`!=`来判断是否相等, 但是它们只是测试 **值** 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用`===`和`!==`来避免类型不一致的错误.\n\n### 字符串\n创建字符串\n```js\nlet myString = \"A string\";\nconst constString = myString;\nconsole.log(constString);\n//A string\n``` \n可以使用单引号,双引号和**反引号**来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\n```js\nconst single = '单引号';\nconst double = \"双引号\";\nconst backtick = `反引号`;\n```\n\n反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n- 可以嵌入 **JavaScript**;\n- 可以声明**多行**的模板字面量.\n\n#### 字符串的拼接\n字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:\n```js\nconst name = \"克里斯\";\nconst greeting = `你好，${name}`;\nconsole.log(greeting); // \"你好，克里斯\"\n```\n> 在模板字面量中用`${}`包装JS的变量或者表达式.\n\n\n```js\nconst one = \"你好，\";\nconst two = \"请问最近如何？\";\nconst joined = `${one}${two}`;\nconsole.log(joined); // \"你好，请问最近如何？\"\n```\n> 连接2个变量.\n\n```js\nconst song = \"青花瓷\";\nconst score = 9;\nconst highestScore = 10;\nconst output = `我喜欢歌曲《${song}》。我给它打了 ${\n  (score / highestScore) * 100\n} 分。`;\nconsole.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n```\n> 在模板字面量的`${}`内部包含表达式.\n\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n```js\nconst greeting = \"你好\";\nconst name = \"克里斯\";\nconsole.log(greeting + \"，\" + name); // \"你好，克里斯\"\n```\n\n#### 多行字符串\n模板字符串会**保留**源代码中的换行符，因此可以编写跨越多行的字符串:\n```js\nconst newline = `终于有一天，\n你知道了必须做的事情，而且开始……`;\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含`\\n`,而非直接跨行:\n```js\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n#### 显示引号\n1. $\\underline{转义}$  通过在符号前加上反斜杠`\\`, 可以转义字符串中的特殊字符,包括字符串中的引号:\n```js\nconst bigmouth = 'I\\'ve got no right to take my place…';\n```\n2. 换用其他字符: 在字面量内用不同于包裹字符串的引号:\n```js\nconst goodQuotes1 = 'She said \"I think so!\"';\nconst goodQuotes2 = `She said \"I'm not going in there!\"`;\n```\n\n\n#### 常用方法\n对于字符串对象实例,其常用的方法:\n- `.length`: 获取字符串的长度;\n- `[]`: 返回字符串中对应索引的字符, 索引同样从`0`开始;\n- `.indexOf(\"\")`: 查找子字符串\n  - **input**: 希望查找的子字符串;\n  - **output**: 子字符串开始的下标(如果不存在则返回`-1`);\n- `.slice(indedxStart, indexEnd)`: 截取字符串\n  - **input**: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\n  - **output**: 截取的子字符串;\n\n更多的`slice`知识:\n1. $\\underline{标准化负值}$ 如果索引是个负数, 取`index+str.length`进行标准化;\n2. 如果`indexStart`大于`str.length`, 返回空字符串;\n3. 如果标准化负值之后, `indexStart`大于`indexEnd`, 也返回空字符串;\n \n- `.toLowerCase()` & `.toUpperCase()`: 转换字符串中的所有字符为小写或大写;\n- `.replace(original, new)`: 替换字符串中`original`子字符串为`new`;\n> 此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n#### Cases\n利用 **indexOf** 和 **slice** 方法, 获取新字符串:\n- **input**: `\"str3\"`三位长字符串+`\"...\"`(无关字符串)+`\";\"`+`strLast`(剩余字符串);\n- **output**: `\"str3\"+\";\"+strLast`\n\n```js\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',\n                'GNF576746573fhdg4737dh4;Greenfield',\n                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',\n                'SYB4f65hf75f736463;Stalybridge',\n                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];\n\nfor(var i = 0; i < stations.length; i++){\n    var input = stations[i];\n    var str3 = input.slice(0,3);\n    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置\n    var output = str3 + \";\" + strLast;\n}\n```\n\n---\n\n通过 **indexOf** 根据子字符串筛选字符串数组:\n- **input**: 可能包含 *Christmas* 的字符串数组;\n- **output**: 包含 *Christmas* 的字符串数组;\n\n```js\nvar list = document.querySelector('.output ul');\nlist.innerHTML = '';\nvar greetings = ['Happy Birthday!',\n                 'Merry Christmas my love',\n                 'A happy Christmas to all the family',\n                 'You\\'re all I want for Christmas',\n                 'Get well soon'];\n\nfor(var i = 0; i < greetings.length; i++) {\n  var input = greetings[i];\n  if(greetings[i].indexOf('Christmas') !== -1) {\n    var result = input;\n    var listItem = document.createElement('li');\n    listItem.textContent = result;\n    list.appendChild(listItem);\n  }\n}\n```\n\n### 数字与字符串\n#### 相互转换\n非常神奇, 在JS当中, 数字和字符串可以直接通过函数`Number()`和`String()`进行转换, 与C语言不同.\n```js\nconst myString = \"123\";\nconst myNum = Number(myString);\nconsole.log(typeof myNum);\n// number\nconsole.log(myNum);\n// 123\n```\n\n```js\nconst myNum2 = 123;\nconst myString2 = String(myNum2);\nconsole.log(typeof myString2);\n// string\nconsole.log(myString2);\n// \"123\"\n```\n> 对于浮点数同样成立.\n\n#### 前后拼接\n使用`+`将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\n```js\nconst name = \"Front \";\nconst number = 242;\nconst combine = name + number;\n\nconsole.log(combine); //Front 242\n\nconsole.log(typeof(combine));  //string\n```\n\n### 数组\n1. 存储任意类型元素--字符串，数字，对象，变量，**另一个数组**;\n2. 可以 **混合** 元素类型:\n```js\nlet random = [\"tree\", 795, [0, 1, 2]];\n```\n3. 像访问字符串一样, 利用索引访问数组元素;\n4. $\\underline{多维数组}$ 包含数组的数组结构称为~\n\n#### split()\n- 作用: 将一个字符串根据给定的字符分隔为字符串数组;\n```js\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";\nlet myArray = myData.split(\",\");\nconsole.log(myArray);\n // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n```\n\n#### join()\n`split`的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\n```js\nlet myNewString = myArray.join(\",\");\nmyNewString;\n```\n\n#### toString()\n与`join`方法相似, 但是无法自定义分隔符, 默认为`,`:\n```js\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];\ndogNames.toString(); //Rocket,Flash,Bella,Slugger\n```\n\n#### push & pop\n`push()`方法可以将1或多个元素添加到数组的 **末尾**:\n1. 将会直接改写原来的数组,不需要重新赋值;\n2. 该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n```js\nlet myArray = [1, 2, 3];\nlet newLength = myArray.push(4, 5,\"string\");\nconsole.log(myArray); // [1, 2, 3, 4, 5, \"string\"]\nconsole.log(newLength); // 6\n```\n\n使用`.pop()`从数组中删除最后一个元素:\n```js\nmyArray.pop(); //\"string\"\nconsole.log(myArray); // [1, 2, 3, 4, 5]\n```\n1. 方法调用返回值就是删除的元素本身;\n2. 直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n> shift & unshift:\n> 在功能上分别与`push`和`pop`相同, 但是作用于数组的开始位置.\n\n## 条件语句\nJS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n### 天气预报\n```html\n<label for=\"weather\">选择今天的天气：</label\n><select id=\"weather\">\n  <option value=\"\">--作出选择--</option>\n  <option value=\"sunny\">晴天</option>\n  <option value=\"rainy\">雨天</option>\n  <option value=\"snowing\">雪天</option>\n  <option value=\"overcast\">阴天</option>\n</select>\n\n<p></p>\n```\n> `lable`当中的`for`标签与`select`标签的`id`属性对应, 用于关联两个标签.\n\n```js\nconst select = document.querySelector(\"select\");\nconst para = document.querySelector(\"p\");\n\nselect.addEventListener(\"change\", setWeather);\n\nfunction setWeather() {\n  const choice = select.value;\n\n  switch (choice) {\n    case \"sunny\":\n      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";\n      break;\n    case \"rainy\":\n      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";\n      break;\n    case \"snowing\":\n      para.textContent =\n        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";\n      break;\n    case \"overcast\":\n      para.textContent =\n        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";\n      break;\n    default:\n      para.textContent = \"\";\n  }\n}\n```\n> 1. 通过`querySelector`方法获取`select`和`p`标签;\n> 2. 然后为`select`标签添加事件监听器, 当内容改变时触发 **change** 事件, 同时调用`setWeather`函数;\n> 3. 进而通过 **switch** 语句处理不同天气的情况, 并设置相应的文字内容;\n> 在线网页示例:[simple-switch](https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html)\n\n\n## 事件介绍\n什么是$\\underline{事件}$? \n- 用户选择、点击或者光标悬停在某一元素;\n- 用户在键盘中按下某个按键;\n- 网页结束加载;\n- ...\n\n$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n\n### 处理点击事件\n以点击事件为例, 介绍html与js如何进行事件处理的交互:\n```html\n<button> 改变颜色 </button>\n```\n```js\nconst btn = document.querySelector(\"button\");\n\nfunction random(number){\n  return Math.floor(Math.random()*(number+1));\n  \n}\n\nbtn.addEventListener(\"click\", ()=>{\n  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;\n  document.body.style.backgroundColor = rndCol;\n})\n```\n1. `Math.random()`方法生成一个介于[0,1)之间的随机数;\n2. `*(number+1)`之后利用向下取整的方法`Math.floor()`将其转换为整数, 范围为[0,number];\n> 假如输入的number为`4`, 则`random(4)`的结果可能为`0`, `1`, `2`, `3`, `4`中的一个;\n> 假设输入的number为`3.6`, 则输出的结果还是0~4中的整数.\n3. ``rndCol = `rgb(${random(255)},${random(255)},${random(255)})`` 采用的是在$\\underline{模板字符串}$内部使用`${}`调用函数变量的方法.\n\n### addEventListener()\n`adEventListener`方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n\n通过`EventTarget.adddEventListener()`的方法, 将指定的监听器注册到对象上, 具体的语法如下:\n```js\naddEventListener(type, listener);\naddEventListener(type, listener, options);\naddEventListener(type, listener, useCapture);\n```\n- `type`: 事件类型, 如`click`, `mouseover`, `mouseout`, `keydown`, `keyup`等;\n- `listener`: 事件处理函数, 该函数将在事件发生时被调用;\n  - 包括 **回调函数** 以及 实现了 **EventListener 接口的对象**;\n- `options`: 可选参数, 用于配置事件监听器的行为;\n> 可以为单个事件添加多个事件监听器.\n\n\n#### listener\n$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n- 是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n- **特点**: 以对象作为listener, 对象中具有名为`handleEvent()`的方法;\n- **作用**: \n  - 将事件处理封装到一个对象当中, 可以更好地组织代码;\n  - 便于在对象中保存更多的状态信息;\n```js\nconst listenerObject = {\n    count: 0,\n    handleEvent(event) {\n        this.count++;\n        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);\n    }\n};\n\nconst button = document.querySelector('button');\nbutton.addEventListener('click', listenerObject);\n```\n\n#### options\n一个指定有关 listener 属性的可选参数对象.\n##### Capture\n- 含义:\n  - 一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n  - 默认为false, 表示只有在冒泡阶段才触发.\n\n- 区别:\n  - `capture`和`useCapture`实际上指的都是 **监听器是否在捕获阶段触发** 的布尔值.\n> 捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n  - 后来DOM的规范更新时引入了`options`参数, 此后`capture`取代了`useCapture`的作用.\n  - 如果`addEventListener`的第三个参数不指定对象, 只有布尔值, 那么默认是在设置`useCapture`\n\n> 可以先查看[事件传播的阶段](#事件传播的阶段)来辅助理解不同的阶段.\n\n##### Once\n- 含义:\n  - 一个布尔值，表示 listener 在添加之后最多只调用一次;\n  - 默认为false, 表示可以多次调用.\n- e.g.\n```js\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n},{once: true});\n```\n> `once`属性被设置为`true`, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\n##### Passive\n- 含义:\n  - 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n- 作用:\n  - 明确不会在`listener`中不会调用`preventDefault()`方法, 即不会阻止浏览器的[默认行为](#默认行为);\n  - 此时, 浏览器可以直接渲染默认行为的结果, 无需等待`listener`的执行与默认行为的检查, 从而提高了性能.\n- Notice:\n  - 如果设置`passive`为`true`, 则`listener`当中不可出现`preventDefault()`方法, 否则会报错.\n\ne.g.\n```js\ndocument.addEventListener('wheel',()=>{\n\tevent.preventDefault();\n  console.log(\"scrolling\");\n},{passive: false});\n```\n- `wheel`事件的默认行为是滚动页面;\n- `event.preventDefault();`表示会阻止鼠标滚动带来的页面滚动;\n\n\n```js\ndocument.addEventListener('wheel',()=>{\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> 明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\n```js\ndocument.addEventListener('wheel',()=>{\n  event.preventDefault();\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> `passive`的设置与`listener`内部矛盾, 将会报错.\n\n##### Signal\n用于有条件地移除事件监听器, 具体使用参见[可被移除的监听器](#可被移除的监听器).\n\n### 事件传播的阶段\n1. 捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;\n> e.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n2. 目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;\n3. 冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.\n\n#### Case\n```html\n<div id=\"parent\">\n  parent\n  <div id=\"child\">child</div>\n</div>\n```\n```js\nconst parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 冒泡阶段');\n});\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n}, { capture: true });\n\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n});\n```\n上述的`child`被包裹在`parent`内部.\n- 当点击`parent`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> 由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n- 当点击`child`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"子元素 - 目标阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> `child`是整个事件流的目标元素, 所以触发时机介于二者之间.\n\n#### Notice\n1. 如果将`div`换成`button`, 则点击`child`时可能只会显示 **目标** 阶段的输出.\n> 这是因为, 不同浏览器对于`button`元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n2.  `event.stopPropagation();`加入该~~咒语~~代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n```js\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n    event.stopPropagation();\n}, { capture: true });\n```\n> 此时, 点击`parent`时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n### 可被移除的监听器\n```html\n<table id=\"outside\">\n  <tr>\n    <td id=\"t1\">one</td>\n  </tr>\n  <tr>\n    <td id=\"t2\">two</td>\n  </tr>\n</table>\n```\n```js\n// 为 table 添加可被移除的事件监听器\nconst controller = new AbortController();\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, { signal: controller.signal });\n\n// 改变 t2 内容的函数\nfunction modifyText() {\n  const t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue === \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n    controller.abort(); // 当值变为 \"three\" 后，移除监听器\n  }\n}\n```\n> - `AbortController`是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\n> - `signal`属性是一个`AbortSignal`对象, 用于控制监听器的移除;\n> - `controller.abort()`方法用于移除监听器;\n> - 当`t2`的内容变为\"three\"时, 移除监听器, 使得`modifyText`函数不再执行. 此后, 点击`t2`不会触发`modifyText`函数.\n\n具体的**构造步骤:**\n1. 创建一个`AbortController`实例: `const controller = new AbortController();`\n2. 在事件监听器内的参数中添加`signal: controller.signal`选项;\n3. 在需要移除监听器的地方调用`controller.abort()`方法;\n\n---\n\n我们也可以直接使用`removeEventListener()`方法来移除事件监听器:\n```js\nremoveEventListener(type, listener);\nremoveEventListener(type, listener, options);\nremoveEventListener(type, listener, useCapture);\n```\n\n\n- Notices:\n  - 如果同一个对象上存在2个事件监听器, 且仅在`useCapture`参数存在差异, 那么需要先后2次调用`removeEventListener()`方法才能完全移除其事件监听器;\n  - 如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\n  - `type`,`listener`参数必须完全匹配才能移除事件监听器;\n  - 对于`options`参数:\n    - 字段相同: 一定可以移除;\n    - 字段不同: 需要与默认值false匹配才可以移除.\n```js\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });\n\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n```\n\n---\n**添加与移除**的结合使用:\n```js\nconst body = document.querySelector(\"body\");\nconst clickTarget = document.getElementById(\"click-target\");\nconst mouseOverTarget = document.getElementById(\"mouse-over-target\");\n\nlet toggle = false;\nfunction makeBackgroundYellow() {\n  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";\n\n  toggle = !toggle;\n}\n\nclickTarget.addEventListener(\"click\", makeBackgroundYellow, false);\n\nmouseOverTarget.addEventListener(\"mouseover\", () => {\n  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);\n});\n```\n\n\n### 使用匿名函数\n在上述`html`例子下:\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  const t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用匿名函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  function () {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过匿名函数封装代码, 将参数传入函数`modifyText`, 使得函数可以被调用.\n\n### 使用箭头函数\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  var t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用箭头函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  () => {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过`=>{}`形式的箭头函数简化代码书写.\n\n---\n#### 比较匿名与箭头\n匿名函数与箭头函数在此处的应用基本相同, 但是在`this`的指向上有所不同:\n- 匿名函数与其他普通的JS函数:`this`指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为`undefined`);\n```js\nfunction sayHello() {\n  console.log(this); // 在非严格模式下，this 指向 window\n}\nsayHello();\n```\n\n- 箭头函数的`this`继承自外部作用域, 即调用该方法的对象.\n```js\nconst obj = {\n  name: \"ZJU\",\n  greet: function () {\n    console.log(this.name); // this 指向 obj\n  },\n};\nobj.greet(); // 输出：ZJU\n```\n\n- e.g.\n```js\nconst obj = {\n  name: \"ZJU\",\n  getNameWithAnonymous: function () {\n    return function () {\n      console.log(this.name);\n    };\n  },\n  getNameWithArrow: function () {\n    return () => {\n      console.log(this.name);\n    };\n  },\n};\n\nconst anonymousFn = obj.getNameWithAnonymous();\nanonymousFn(); // 输出：undefined\n\nconst arrowFn = obj.getNameWithArrow();\narrowFn(); // 输出：ZJU\n```\n> 进一步完善.\n\n### 事件对象\n$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如`event`,`e`,`evt`. 它被自动传递给事件处理函数，以提供额外的功能和信息。\n\n`e.target`始终是对 **事件刚刚发生的元素** 的引用\n\n## 表达式和运算符\n### new()\n$\\underline{new}$ 用来创建对象实例的一个关键字. \n- 作用: **调用** 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n#### 语法\n```js\nnew constructor\nnew constructor()\nnew constructor(arg1)\nnew constructor(arg1, arg2)\nnew constructor(arg1, arg2, /* …, */ argN)\n```\n1. 如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即`new foo` 等价于 `new foo()`;\n2. 构造函数内部的`this`将被绑定到新建的对象实例上;\n\n- e.g. \n```js\nfunction Car(color, brand) {\n  this.color = color;   // 将 color 赋值给新对象\n  this.brand = brand;   // 将 brand 赋值给新对象\n}\n\nconst myCar = new Car(\"red\", \"Toyota\");\n\nconsole.log(myCar.color); // 输出 \"red\"\nconsole.log(myCar.brand); // 输出 \"Toyota\"\n```\n\n使用`new()`的**步骤**:\n 1. 定义构造函数;\n 2. 使用`new()`并传入构造函数的参数;\n 3. 将返回的对象实例赋值给一个变量;\n\n#### 新增属性\n- 为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n```js\ncar1.color = \"black\" //为car1新增color属性\n```\n<br>\n\n- 添加共享属性到构造函数中的`prototype`:\n```js\nfunction Car() {}\ncar1 = new Car();\ncar2 = new Car();\n\nconsole.log(car1.color); // undefined\n\nCar.prototype.color = \"原色\";\nconsole.log(car1.color); // '原色'\n\ncar1.color = \"黑色\";\nconsole.log(car1.color); // '黑色'\n\nconsole.log(Object.getPrototypeOf(car1).color); // '原色'\nconsole.log(Object.getPrototypeOf(car2).color); // '原色'\nconsole.log(car1.color); // '黑色'\nconsole.log(car2.color); // '原色'\n```\n> - 此处的构造函数名为`Car`, 因此通过`Car.prototype`可以访问到构造函数的原型对象;\n> - `getPrototypeOf` 表示获取对象的**原型对象**, 因此此处均为最初定义的 **原色**.\n\n#### new.target\n函数通过`new.target`属性可以判断是否通过`new`关键字调用, 即构造.\n- 如果函数是正常调用, 则返回`undefined`;\n- 如果函数是通过`new`调用, 返回被调用的构造函数.\n\n- e.g.\n```js\nfunction Car(color) {\n  if (!new.target) {\n    // 以函数的形式被调用。\n    return `${color}车`;\n  }\n  // 通过 new 被调用。\n  this.color = color;\n}\n\nconst a = Car(\"红\"); // a 是“红车”\nconst b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n```\n\n#### 对象类型与实例\n$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:\n```js\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n```\n\n$\\underline{对象实例}$ 通过使用`new()`方法, 由对象类型构造一个对象实例:\n```js\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n```\n\n#### 类与new\n在JS当中, 类 **必须** 通过`new`调用.\n> 可以优先阅读[类相关的知识](#类)\n\n- e.g. \n```js\nclass Animal {\n  //构造函数\n  constructor(name) {\n    this.name = name;\n  }\n  //实例方法\n  greet() {\n    console.log(`你好，我的名字是${this.name}`);\n  }\n}\n```\n对于上述的类, 必须使用如下的调用方式:\n```js\nconst animal = new Animal(\"Dog\"); // 正常\n```\n而下面这样类似于普通函数的调用方式会抛出错误:\n```js\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n```\n<br>\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\n```js\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n```\n\n---\n\n下面给出与普通函数的区别:\n```js\nfunction Car(model) {\n  this.model = model;\n}\n\nconst car = new Car(\"Toyota\"); // 正常\nCar(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.\nconst anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n```\n总结:\n- 以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n- 如果以new方法构造得到对象实例, 依旧正常.\n\n---\n\n# 补充\n## 默认行为\n$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n- 比如存在以下的默认行为:\n  - 滚动事件：触摸屏上滑动手指，页面会滚动;\n  - 拖拽文件到浏览器：浏览器会尝试加载文件;\n  - 点击链接 `(<a href=\"...\">)`：跳转到指定的 URL;\n\n$\\underline{阻止默认行为}$ 使用 `event.preventDefault()` 方法可以阻止事件的默认行为.\n\n- e.g: 阻止链接跳转\n```js\ndocument.querySelector('a').addEventListener('click', function(event) {\n    event.preventDefault(); // 阻止点击链接时的默认行为\n    console.log('链接被点击，但没有跳转');\n});\n```\n\n- 作用:\n  - 通过阻止默认行为, 可以实现自定义逻辑.\n\n## this\n\n- `this`可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\n- `this` 指向的是**当前函数的调用者**，而不是函数内部定义的变量.\n\n<br>\n\n- e.g.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处的`f`\n\n### 函数上下文中的this\n- `this`参数的值取决于函数**如何**被调用, 而不是函数如何被定义.\n```js\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，\n// 并且 'this' 将被绑定到它。\nconst obj = { a: \"Custom\" };\n\n// 使用 var 声明的变量成为 'globalThis' 的属性。\nvar a = \"Global\";\n\nfunction whatsThis() {\n  return this.a; // 'this' 取决于函数如何被调用\n}\n\nwhatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'\nobj.whatsThis = whatsThis;\nobj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n```\n1. 同样是调用函数`whatsThis()`, 但是`this`参数被绑定到不同的对象上, 导致返回值不同;\n2. 在非严格模式下, `this`参数默认指向`globalThis`, 即全局对象;\n3. 对于典型函数, `this`指向函数访问的对象;\n\n- e.g. \n```js\nconst obj = {\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处`f`作为`obj`对象的方法被调用, 因此普通函数的`this`指向`obj`.\n\n- e.g. 直接调用的普通函数`this`指向全局:\n```js\nconst obj = {\n    a: \"a in the obj\",\n    f: function() {\n        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定\n        console.log(funcA()); // 访问 this.a\n    }\n};\n\nvar a = \"a in the global\";\nobj.f(); // \"a in the global\"\n```\n> - 此处的`funcA`并没有类似于作为对象的属性调用(`obj.funcA()`), 因此其`this`指向全局作用域(`window`), 输出`undefined`, 而是直接调用的形式, 因此其`this`指向全局作用域.\n\n\n\n\n\n### 对this传值\n使用`call()`以及`apply()`方法可以将`this`绑定到其他对象上.\n#### call()\n- 形式: `func.call(thisArg, arg1, arg2, ...)`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 剩余的参数被绑定到命名参数。\nadd.call(o, 5, 7); // 16\n```\n\n#### apply()\n- 形式: `func.apply(thisArg, [argsArray])`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 第二个参数是一个数组，其成员被绑定到命名参数。\nadd.apply(o, [10, 20]); // 34\n```\n\n#### bind()\n- 形式: `f.bind(someObject)`;\n- **作用**: \n  - 创建一个新的函数(需要重新赋值), 具有与`f`相同的函数体和作用域;\n  - 新函数的`this`被 **永久地** 绑定到`someObject`, 不随调用方式的变化而变化.\n- **限制**: \n  - `bind`无法多次生效. 即对函数f`bind`得到的g, 无法继续用`bind`得到期望的h;\n- e.g. 多次`bind`:\n```js\nfunction f() {\n  return this.a;\n}\n\nconst g = f.bind({ b: \"azerty\" });\nconsole.log(g()); // undefined\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // undefined\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n```\n> - 由于`bind`只能对一个原始函数作用, 因此由f得到的g无法继续由`bind`绑定`this`得到期望的h, 此处h的`this`依旧是`{b: \"azerty\"}`, 因此在输出对象`a`时显示`undefined`;\n> - `o.f()`的调用是普通函数的调用, 因此其`this`继承自对象`o`, 输出`37`;\n\n- e.g. 对象\n```js\nfunction f() {\n  return this.a + \" \" + this.c;\n}\n\nconst g = f.bind({ b: \"azerty\" , c:\"ccc\"});\nconsole.log(g()); // \"undefined ccc\"\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // \"undefined ccc\"\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n```\n> - `bind`绑定的`this`是永久覆盖, 而非简单叠加;\n> - 由于`bind`绑定的`this`不随者调用方式的变化而变化, 因此即使处于对象`o`当中, `g`,`h`依旧不会输出`o`中的`a`.\n\n### 箭头函数中的this\n\n\n使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n\n\n普通函数:\n```js\nconst a = \"a in the global\";\nconst foo = function () {return this.a};\n\nconst obj = {\n a: \"a in the obj\",\n f: foo\n};\n\nconsole.log(obj.f()); // \"a in the obj\"\n```\n\n`call()`、 `apply()`、 `bind()` 无法改变箭头函数的`this`(但是call与apply的其他参数可以正常传递:\n```js\nconst foo = ()=> this.a;\n\nconst obj = {\n a: \"a in the obj\",\n f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效\n};\n\nconsole.log(obj.f()); // undefined\n\n```\n> 换成普通函数则输出`a in the obj`.\n\n\n- 全局作用域\n```js\nvar a = \"a in the global\";\nconst foo1 = () => this.a;\n\nconst obj = {\n\ta: \"a in the obj\",\n\tf: ()=> a\n};\n\nconsole.log(obj.f());\n```\n\n## 作用域\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n- 块级作用域: 由`let`或`const`声明的变量的作用域.(对于`var`无效);\n\n```js\n{\n  var x = 1;\n}\nconsole.log(x); // 1\n\n{\n  const x = 1;\n}\nconsole.log(x); // undefined\n```\n\nNotices:\n- 对象本身并不会创建作用域, 只是一个键值对的集合;\n- 箭头函数也不会创建自己的作用域, 而是 **继承** 外层作用域中的`this`;\n\n### 变量与作用域\n- `var`在全局作用域中声明时会成为 **全局对象** (`window`或`global`)的属性;\n- `let`和`const`即使在全局作用域中声明, 也不会成为全局对象的属性;\n```js\nvar a = \"1\";\nlet b = \"2\";\n\nwindow.a; // \"1\"\nwindow.b; // undefined\n```\n> 因此, 建议在全局作用域中不要使用`var`声明变量, 而使用`let`或`const`声明变量. 从而避免导致意外的覆盖和冲突.\n\n\n### 函数与作用域\n#### 普通函数\n普通函数和匿名函数的作用域继承自其定义时的作用域.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: function() {\n            return this.a; // 普通函数，this 动态绑定到 insideObj\n        }\n    },\n    f: function() {\n        return this.a; // 普通函数，this 动态绑定到 obj\n    }\n};\n\nconsole.log(obj.f());        // \"a in the obj\"\nconsole.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n```\n\n#### 箭头函数\ne.g. **箭头函数继承外层作用域**:\n```js\nvar a = \"a in the global\";\n\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: () => this.a\n    },\n    f: () => this.a\n};\n\nconsole.log(obj.f());        // \"a in the global\"\nconsole.log(obj.insideObj.g()); //\"a in the global\"\n```\n由于对象不会创建作用域, 因此此处的箭头函数的`this`继承了外层作用域(window)的`this`, 且`var`创建的变量存在于全局作用域中.\n\n## 语法糖\n$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.\n- 本质上没有增加语言的功能, 而是对已有功能的 **包装** 或者优化;\n- **可读性提升**: ~~让代码更填~~ 使得代码更加容易理解和书写;\n- **底层实现**: 实质上依旧用基础的语法实现.\n\n### 类\n类 `class` 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承`prototype`的封装.\n\n使用`class`的写法:\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n等价的原型写法:\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n### 箭头函数\n箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\n- e.g.\n```js\n// 使用箭头函数\nconst add = (a, b) => a + b;\n\n// 等价的普通函数\nconst add = function add(a, b) {\n  return a + b;\n}\n```\n\n### 结构赋值\n$\\underline{结构赋值}$ 手动提取**对象**属性的语法糖.\n\n- 使用结构赋值:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst {name, gender} = person;\n```\n\n- 等价的原型写法:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst name = person.name;\nconst gender = person.gender;\n```\n\n#### 赋值规则\n结构赋值时, 基于 **属性名匹配** 而非顺序. \n因此, 对象结构的`{}`内部属性必须和 **对象的属性名** 相对应.\n\n**错误**的示例:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { a, b } = person;\n\nconsole.log(a); // 输出：undefined\nconsole.log(b); // 输出：undefined\n```\n\n**重命名属性**的写法:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { name: a, age: b } = person;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n\n**手动赋值**: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\n```js\nconst person = { name: \"Alice\" };\nconst { name, age = 30 } = person;\n\nconsole.log(name); // 输出：Alice\nconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n```\n#### 数组的结构赋值\n上述讨论的结构赋值都是对 **对象** 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— **基于顺序**赋值:\n```js\nconst arr = [\"Alice\", 25];\nconst [a, b] = arr;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n","source":"_posts/编程语言/JavaScript.md","raw":"---\ntitle: JavaScript\ndate: 2025-01-09 14:06:30\ntags: \n- 前端\n- JS\ncategories: 学习笔记\nexcerpt: 一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)\nmath: true\nindex_img: /img/料理的加护.jpg\n---\n> JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「**料理的加护**」下, 尽可能将JS处理得更加**可口**一些)\n<img src=\"/img/料理的加护.jpg\" width = \"35%\">\n\n# 创建JS代码块\n## 变量\n### `var` or `let`?\n`var`先于`let`的产生, 后者是现代版本的JS中新的关键字.\n\n使用`var`, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是`let`并不适用.\n```js\nmyName = \"Chris\";\n\nfunction logName() {\n  console.log(myName);\n}\n\nlogName(); //输出\"Chris\"\n\nvar myName = \"Aniya\";\nlogName(); //输出\"Aniya\"\n```\n\n除此之外, 可以使用`var`前后声明相同的变量, 这并不会报错:\n```js\nvar myName = \"Chris\";\nvar myName = \"Bob\";\n```\n\n而`let`只能声明一次:\n```js\nlet myName = \"Chris\";\nmyName = \"Bob\";\n```\n\n因此, 在代码编写中应尽量**多使用**`let`而非`var`, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n\n\n### 变量命名的规则\n与C语言类似, 建议以 **字母、数字、下划线** 组成的标识符来命名变量.\n- 不可用`_`开头, 因为可能被JS设计为特殊的含义;\n- 不可用数字开头, 否则引发错误;\n- 大小写敏感;\n- 建议采用 **小写驼峰命名法** ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n- 避免使用保留字, 比如`var`,`let`,`for`等.\n\n### 变量类型\n\n```js\nlet myAge = 20 ;// 数字\nlet dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串\nlet test = 6 < 3; //boolean\n\n//数组类型\nlet myNameArray = [\"Chris\", \"Bob\", \"Jim\"];\nlet myNumberArray = [10, 15, 40];\n\n//对象类型\nlet dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n```\n> 对象类型的访问与结构体相似, `dog.name;`\n\n在上面的几种变量类型中, 我们都采用`let`关键字声明变量, 这体现了JS是一种 **动态类型语言** ,即无需指定变量包含的数据类型.\n\n同时, 这也意味着我们可以像`python`一样对同一个变量先后赋值不同类型的值:\n```js\nlet myNumber = \"500\";\ntypeof myNumber;\n// 输出 'string'\n\nmyNumber = 500; \ntypeof myNumber;\n//输出'number'\n```\n\n\n## 函数\n- $\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n```js\nexampleFunction();\n\nfunction exampleFunction() {\n  console.log(\"函数内\");\n  console.log(x);\n}\n```\n> 由于 **提升** 的存在, 上述的函数调用不会出错.\n\n\n### 默认参数\n在编写函数时, 可以通过在参数名称后添加`=`, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\n```js\nfunction greeding(name = \"my friend\") {\n    console.log(`Hello, ${name}!`);\n}\nhello(); //Hello, my friend!\nhello(\"world\"); //Hello, world!\n```\n\n<br>\n\n事件处理函数的默认接受值是`event`:\n```html\n<button>\nonclick\n</button>\n\n<p>\nnothing here\n</p>\n\n<script>\nbtn = document.querySelector(\"button\")\npara = document.querySelector(\"p\")\n\nbtn.onclick = click;\n\nfunction click(string){\n  console.log(\"clicked!\")\n  para.textContent = string;\n}\n</script>\n```\n1. 上述的`btn`在点击之后调用函数`click`, 该函数需要一个参数`string`, 由于`btn.onclick = click;`的绑定方式, 我们无法指定传参的值, 因此点击之后的`para`的内容显示为: `[object PointerEvent]`;\n2. `textContent`是属性而非方法, 因此采用赋值实现;\n\n\n```js\nbtn.onclick = function click(string) {\n  console.log(\"clicked!\")\n  para.textContent = \"You have clicked the button!\";\n}\n```\n> 将上述的绑定方式如此改写, 可以在`btn`外对`string`进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n\n\n### 箭头函数\n在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:\n```js\nfunction myFunction() {\n  alert(\"你好\");\n}\n\n// 匿名函数\n(function () {\n  alert(\"你好\");\n});\n```\n> 正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\n```js\nfunction logKey(event) {\n  console.log(`You pressed \"${event.key}\".`);\n}\n\ntextBox.addEventListener(\"keydown\", logKey);\n```\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\n```js\ntextBox.addEventListener(\"keydown\", function (event) {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而**箭头函数**则是在此情况下更简洁的函数定义方式:\n```js\ntextBox.addEventListener(\"keydown\", (event) => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n\n//如果函数只接受一个参数, 也可以省略参数周围的括号\ntextBox.addEventListener(\"keydown\", event => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n\n如果只包含一行的`return`,则可以忽略`{}`和`return`关键字:\n```js\nconst originals = [1, 2, 3];\n\nconst doubled = originals.map(item => item * 2);\n\nconsole.log(doubled); // [2, 4, 6]\n```\n> `item => item * 2`等价于:\n```js\nfunction doubleItem(item) {\n  return item * 2;\n}\n```\n\n#### 一个实例\n```html\n<input id=\"textBox\" type=\"text\" />\n<div id=\"output\"></div>\n```\n```js\nconst textBox = document.querySelector(\"#textBox\");\nconst output = document.querySelector(\"#output\");\n\ntextBox.addEventListener(\"keydown\", (event) => {\n  output.textContent = `You pressed \"${event.key}\".`;\n});\n```\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n\n### 函数作用域和冲突\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部`let`定义的变量, 以及`const`定义的常量可以在函数内部访问.\n\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n```html\n<!-- Excerpt from my HTML -->\n<script src=\"first.js\"></script>\n<script src=\"second.js\"></script>\n<script>\n  greeting();\n</script>\n```\n> 如果两个JS文件都定义了`greeting`函数, 则只有第一个文件中的函数才会被调用.\n\n## 数据类型\n### 数字和操作符\n大部分与C语言相同, 概括需要注意的差异:\n- JS当中只有一种数字类型 -- `number`, 对于整型或者浮点数的初始化得到的量, 由`typeof`均得到`number`;\n- 算术运算符: 求幂为`**`;\n- 常量无法使用自增或自减,~~好像也是C语言的 忘了~~\n- `===`表示严格等于, `!==`表示不等于;\n> 同时存在`==`和`!=`来判断是否相等, 但是它们只是测试 **值** 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用`===`和`!==`来避免类型不一致的错误.\n\n### 字符串\n创建字符串\n```js\nlet myString = \"A string\";\nconst constString = myString;\nconsole.log(constString);\n//A string\n``` \n可以使用单引号,双引号和**反引号**来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\n```js\nconst single = '单引号';\nconst double = \"双引号\";\nconst backtick = `反引号`;\n```\n\n反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n- 可以嵌入 **JavaScript**;\n- 可以声明**多行**的模板字面量.\n\n#### 字符串的拼接\n字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:\n```js\nconst name = \"克里斯\";\nconst greeting = `你好，${name}`;\nconsole.log(greeting); // \"你好，克里斯\"\n```\n> 在模板字面量中用`${}`包装JS的变量或者表达式.\n\n\n```js\nconst one = \"你好，\";\nconst two = \"请问最近如何？\";\nconst joined = `${one}${two}`;\nconsole.log(joined); // \"你好，请问最近如何？\"\n```\n> 连接2个变量.\n\n```js\nconst song = \"青花瓷\";\nconst score = 9;\nconst highestScore = 10;\nconst output = `我喜欢歌曲《${song}》。我给它打了 ${\n  (score / highestScore) * 100\n} 分。`;\nconsole.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n```\n> 在模板字面量的`${}`内部包含表达式.\n\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n```js\nconst greeting = \"你好\";\nconst name = \"克里斯\";\nconsole.log(greeting + \"，\" + name); // \"你好，克里斯\"\n```\n\n#### 多行字符串\n模板字符串会**保留**源代码中的换行符，因此可以编写跨越多行的字符串:\n```js\nconst newline = `终于有一天，\n你知道了必须做的事情，而且开始……`;\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含`\\n`,而非直接跨行:\n```js\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n#### 显示引号\n1. $\\underline{转义}$  通过在符号前加上反斜杠`\\`, 可以转义字符串中的特殊字符,包括字符串中的引号:\n```js\nconst bigmouth = 'I\\'ve got no right to take my place…';\n```\n2. 换用其他字符: 在字面量内用不同于包裹字符串的引号:\n```js\nconst goodQuotes1 = 'She said \"I think so!\"';\nconst goodQuotes2 = `She said \"I'm not going in there!\"`;\n```\n\n\n#### 常用方法\n对于字符串对象实例,其常用的方法:\n- `.length`: 获取字符串的长度;\n- `[]`: 返回字符串中对应索引的字符, 索引同样从`0`开始;\n- `.indexOf(\"\")`: 查找子字符串\n  - **input**: 希望查找的子字符串;\n  - **output**: 子字符串开始的下标(如果不存在则返回`-1`);\n- `.slice(indedxStart, indexEnd)`: 截取字符串\n  - **input**: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\n  - **output**: 截取的子字符串;\n\n更多的`slice`知识:\n1. $\\underline{标准化负值}$ 如果索引是个负数, 取`index+str.length`进行标准化;\n2. 如果`indexStart`大于`str.length`, 返回空字符串;\n3. 如果标准化负值之后, `indexStart`大于`indexEnd`, 也返回空字符串;\n \n- `.toLowerCase()` & `.toUpperCase()`: 转换字符串中的所有字符为小写或大写;\n- `.replace(original, new)`: 替换字符串中`original`子字符串为`new`;\n> 此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n#### Cases\n利用 **indexOf** 和 **slice** 方法, 获取新字符串:\n- **input**: `\"str3\"`三位长字符串+`\"...\"`(无关字符串)+`\";\"`+`strLast`(剩余字符串);\n- **output**: `\"str3\"+\";\"+strLast`\n\n```js\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',\n                'GNF576746573fhdg4737dh4;Greenfield',\n                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',\n                'SYB4f65hf75f736463;Stalybridge',\n                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];\n\nfor(var i = 0; i < stations.length; i++){\n    var input = stations[i];\n    var str3 = input.slice(0,3);\n    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置\n    var output = str3 + \";\" + strLast;\n}\n```\n\n---\n\n通过 **indexOf** 根据子字符串筛选字符串数组:\n- **input**: 可能包含 *Christmas* 的字符串数组;\n- **output**: 包含 *Christmas* 的字符串数组;\n\n```js\nvar list = document.querySelector('.output ul');\nlist.innerHTML = '';\nvar greetings = ['Happy Birthday!',\n                 'Merry Christmas my love',\n                 'A happy Christmas to all the family',\n                 'You\\'re all I want for Christmas',\n                 'Get well soon'];\n\nfor(var i = 0; i < greetings.length; i++) {\n  var input = greetings[i];\n  if(greetings[i].indexOf('Christmas') !== -1) {\n    var result = input;\n    var listItem = document.createElement('li');\n    listItem.textContent = result;\n    list.appendChild(listItem);\n  }\n}\n```\n\n### 数字与字符串\n#### 相互转换\n非常神奇, 在JS当中, 数字和字符串可以直接通过函数`Number()`和`String()`进行转换, 与C语言不同.\n```js\nconst myString = \"123\";\nconst myNum = Number(myString);\nconsole.log(typeof myNum);\n// number\nconsole.log(myNum);\n// 123\n```\n\n```js\nconst myNum2 = 123;\nconst myString2 = String(myNum2);\nconsole.log(typeof myString2);\n// string\nconsole.log(myString2);\n// \"123\"\n```\n> 对于浮点数同样成立.\n\n#### 前后拼接\n使用`+`将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\n```js\nconst name = \"Front \";\nconst number = 242;\nconst combine = name + number;\n\nconsole.log(combine); //Front 242\n\nconsole.log(typeof(combine));  //string\n```\n\n### 数组\n1. 存储任意类型元素--字符串，数字，对象，变量，**另一个数组**;\n2. 可以 **混合** 元素类型:\n```js\nlet random = [\"tree\", 795, [0, 1, 2]];\n```\n3. 像访问字符串一样, 利用索引访问数组元素;\n4. $\\underline{多维数组}$ 包含数组的数组结构称为~\n\n#### split()\n- 作用: 将一个字符串根据给定的字符分隔为字符串数组;\n```js\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";\nlet myArray = myData.split(\",\");\nconsole.log(myArray);\n // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n```\n\n#### join()\n`split`的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\n```js\nlet myNewString = myArray.join(\",\");\nmyNewString;\n```\n\n#### toString()\n与`join`方法相似, 但是无法自定义分隔符, 默认为`,`:\n```js\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];\ndogNames.toString(); //Rocket,Flash,Bella,Slugger\n```\n\n#### push & pop\n`push()`方法可以将1或多个元素添加到数组的 **末尾**:\n1. 将会直接改写原来的数组,不需要重新赋值;\n2. 该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n```js\nlet myArray = [1, 2, 3];\nlet newLength = myArray.push(4, 5,\"string\");\nconsole.log(myArray); // [1, 2, 3, 4, 5, \"string\"]\nconsole.log(newLength); // 6\n```\n\n使用`.pop()`从数组中删除最后一个元素:\n```js\nmyArray.pop(); //\"string\"\nconsole.log(myArray); // [1, 2, 3, 4, 5]\n```\n1. 方法调用返回值就是删除的元素本身;\n2. 直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n> shift & unshift:\n> 在功能上分别与`push`和`pop`相同, 但是作用于数组的开始位置.\n\n## 条件语句\nJS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n### 天气预报\n```html\n<label for=\"weather\">选择今天的天气：</label\n><select id=\"weather\">\n  <option value=\"\">--作出选择--</option>\n  <option value=\"sunny\">晴天</option>\n  <option value=\"rainy\">雨天</option>\n  <option value=\"snowing\">雪天</option>\n  <option value=\"overcast\">阴天</option>\n</select>\n\n<p></p>\n```\n> `lable`当中的`for`标签与`select`标签的`id`属性对应, 用于关联两个标签.\n\n```js\nconst select = document.querySelector(\"select\");\nconst para = document.querySelector(\"p\");\n\nselect.addEventListener(\"change\", setWeather);\n\nfunction setWeather() {\n  const choice = select.value;\n\n  switch (choice) {\n    case \"sunny\":\n      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";\n      break;\n    case \"rainy\":\n      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";\n      break;\n    case \"snowing\":\n      para.textContent =\n        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";\n      break;\n    case \"overcast\":\n      para.textContent =\n        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";\n      break;\n    default:\n      para.textContent = \"\";\n  }\n}\n```\n> 1. 通过`querySelector`方法获取`select`和`p`标签;\n> 2. 然后为`select`标签添加事件监听器, 当内容改变时触发 **change** 事件, 同时调用`setWeather`函数;\n> 3. 进而通过 **switch** 语句处理不同天气的情况, 并设置相应的文字内容;\n> 在线网页示例:[simple-switch](https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html)\n\n\n## 事件介绍\n什么是$\\underline{事件}$? \n- 用户选择、点击或者光标悬停在某一元素;\n- 用户在键盘中按下某个按键;\n- 网页结束加载;\n- ...\n\n$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n\n### 处理点击事件\n以点击事件为例, 介绍html与js如何进行事件处理的交互:\n```html\n<button> 改变颜色 </button>\n```\n```js\nconst btn = document.querySelector(\"button\");\n\nfunction random(number){\n  return Math.floor(Math.random()*(number+1));\n  \n}\n\nbtn.addEventListener(\"click\", ()=>{\n  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;\n  document.body.style.backgroundColor = rndCol;\n})\n```\n1. `Math.random()`方法生成一个介于[0,1)之间的随机数;\n2. `*(number+1)`之后利用向下取整的方法`Math.floor()`将其转换为整数, 范围为[0,number];\n> 假如输入的number为`4`, 则`random(4)`的结果可能为`0`, `1`, `2`, `3`, `4`中的一个;\n> 假设输入的number为`3.6`, 则输出的结果还是0~4中的整数.\n3. ``rndCol = `rgb(${random(255)},${random(255)},${random(255)})`` 采用的是在$\\underline{模板字符串}$内部使用`${}`调用函数变量的方法.\n\n### addEventListener()\n`adEventListener`方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n\n通过`EventTarget.adddEventListener()`的方法, 将指定的监听器注册到对象上, 具体的语法如下:\n```js\naddEventListener(type, listener);\naddEventListener(type, listener, options);\naddEventListener(type, listener, useCapture);\n```\n- `type`: 事件类型, 如`click`, `mouseover`, `mouseout`, `keydown`, `keyup`等;\n- `listener`: 事件处理函数, 该函数将在事件发生时被调用;\n  - 包括 **回调函数** 以及 实现了 **EventListener 接口的对象**;\n- `options`: 可选参数, 用于配置事件监听器的行为;\n> 可以为单个事件添加多个事件监听器.\n\n\n#### listener\n$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n- 是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n- **特点**: 以对象作为listener, 对象中具有名为`handleEvent()`的方法;\n- **作用**: \n  - 将事件处理封装到一个对象当中, 可以更好地组织代码;\n  - 便于在对象中保存更多的状态信息;\n```js\nconst listenerObject = {\n    count: 0,\n    handleEvent(event) {\n        this.count++;\n        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);\n    }\n};\n\nconst button = document.querySelector('button');\nbutton.addEventListener('click', listenerObject);\n```\n\n#### options\n一个指定有关 listener 属性的可选参数对象.\n##### Capture\n- 含义:\n  - 一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n  - 默认为false, 表示只有在冒泡阶段才触发.\n\n- 区别:\n  - `capture`和`useCapture`实际上指的都是 **监听器是否在捕获阶段触发** 的布尔值.\n> 捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n  - 后来DOM的规范更新时引入了`options`参数, 此后`capture`取代了`useCapture`的作用.\n  - 如果`addEventListener`的第三个参数不指定对象, 只有布尔值, 那么默认是在设置`useCapture`\n\n> 可以先查看[事件传播的阶段](#事件传播的阶段)来辅助理解不同的阶段.\n\n##### Once\n- 含义:\n  - 一个布尔值，表示 listener 在添加之后最多只调用一次;\n  - 默认为false, 表示可以多次调用.\n- e.g.\n```js\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n},{once: true});\n```\n> `once`属性被设置为`true`, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\n##### Passive\n- 含义:\n  - 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n- 作用:\n  - 明确不会在`listener`中不会调用`preventDefault()`方法, 即不会阻止浏览器的[默认行为](#默认行为);\n  - 此时, 浏览器可以直接渲染默认行为的结果, 无需等待`listener`的执行与默认行为的检查, 从而提高了性能.\n- Notice:\n  - 如果设置`passive`为`true`, 则`listener`当中不可出现`preventDefault()`方法, 否则会报错.\n\ne.g.\n```js\ndocument.addEventListener('wheel',()=>{\n\tevent.preventDefault();\n  console.log(\"scrolling\");\n},{passive: false});\n```\n- `wheel`事件的默认行为是滚动页面;\n- `event.preventDefault();`表示会阻止鼠标滚动带来的页面滚动;\n\n\n```js\ndocument.addEventListener('wheel',()=>{\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> 明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\n```js\ndocument.addEventListener('wheel',()=>{\n  event.preventDefault();\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> `passive`的设置与`listener`内部矛盾, 将会报错.\n\n##### Signal\n用于有条件地移除事件监听器, 具体使用参见[可被移除的监听器](#可被移除的监听器).\n\n### 事件传播的阶段\n1. 捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;\n> e.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n2. 目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;\n3. 冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.\n\n#### Case\n```html\n<div id=\"parent\">\n  parent\n  <div id=\"child\">child</div>\n</div>\n```\n```js\nconst parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 冒泡阶段');\n});\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n}, { capture: true });\n\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n});\n```\n上述的`child`被包裹在`parent`内部.\n- 当点击`parent`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> 由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n- 当点击`child`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"子元素 - 目标阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> `child`是整个事件流的目标元素, 所以触发时机介于二者之间.\n\n#### Notice\n1. 如果将`div`换成`button`, 则点击`child`时可能只会显示 **目标** 阶段的输出.\n> 这是因为, 不同浏览器对于`button`元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n2.  `event.stopPropagation();`加入该~~咒语~~代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n```js\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n    event.stopPropagation();\n}, { capture: true });\n```\n> 此时, 点击`parent`时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n### 可被移除的监听器\n```html\n<table id=\"outside\">\n  <tr>\n    <td id=\"t1\">one</td>\n  </tr>\n  <tr>\n    <td id=\"t2\">two</td>\n  </tr>\n</table>\n```\n```js\n// 为 table 添加可被移除的事件监听器\nconst controller = new AbortController();\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, { signal: controller.signal });\n\n// 改变 t2 内容的函数\nfunction modifyText() {\n  const t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue === \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n    controller.abort(); // 当值变为 \"three\" 后，移除监听器\n  }\n}\n```\n> - `AbortController`是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\n> - `signal`属性是一个`AbortSignal`对象, 用于控制监听器的移除;\n> - `controller.abort()`方法用于移除监听器;\n> - 当`t2`的内容变为\"three\"时, 移除监听器, 使得`modifyText`函数不再执行. 此后, 点击`t2`不会触发`modifyText`函数.\n\n具体的**构造步骤:**\n1. 创建一个`AbortController`实例: `const controller = new AbortController();`\n2. 在事件监听器内的参数中添加`signal: controller.signal`选项;\n3. 在需要移除监听器的地方调用`controller.abort()`方法;\n\n---\n\n我们也可以直接使用`removeEventListener()`方法来移除事件监听器:\n```js\nremoveEventListener(type, listener);\nremoveEventListener(type, listener, options);\nremoveEventListener(type, listener, useCapture);\n```\n\n\n- Notices:\n  - 如果同一个对象上存在2个事件监听器, 且仅在`useCapture`参数存在差异, 那么需要先后2次调用`removeEventListener()`方法才能完全移除其事件监听器;\n  - 如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\n  - `type`,`listener`参数必须完全匹配才能移除事件监听器;\n  - 对于`options`参数:\n    - 字段相同: 一定可以移除;\n    - 字段不同: 需要与默认值false匹配才可以移除.\n```js\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });\n\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n```\n\n---\n**添加与移除**的结合使用:\n```js\nconst body = document.querySelector(\"body\");\nconst clickTarget = document.getElementById(\"click-target\");\nconst mouseOverTarget = document.getElementById(\"mouse-over-target\");\n\nlet toggle = false;\nfunction makeBackgroundYellow() {\n  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";\n\n  toggle = !toggle;\n}\n\nclickTarget.addEventListener(\"click\", makeBackgroundYellow, false);\n\nmouseOverTarget.addEventListener(\"mouseover\", () => {\n  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);\n});\n```\n\n\n### 使用匿名函数\n在上述`html`例子下:\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  const t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用匿名函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  function () {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过匿名函数封装代码, 将参数传入函数`modifyText`, 使得函数可以被调用.\n\n### 使用箭头函数\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  var t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用箭头函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  () => {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过`=>{}`形式的箭头函数简化代码书写.\n\n---\n#### 比较匿名与箭头\n匿名函数与箭头函数在此处的应用基本相同, 但是在`this`的指向上有所不同:\n- 匿名函数与其他普通的JS函数:`this`指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为`undefined`);\n```js\nfunction sayHello() {\n  console.log(this); // 在非严格模式下，this 指向 window\n}\nsayHello();\n```\n\n- 箭头函数的`this`继承自外部作用域, 即调用该方法的对象.\n```js\nconst obj = {\n  name: \"ZJU\",\n  greet: function () {\n    console.log(this.name); // this 指向 obj\n  },\n};\nobj.greet(); // 输出：ZJU\n```\n\n- e.g.\n```js\nconst obj = {\n  name: \"ZJU\",\n  getNameWithAnonymous: function () {\n    return function () {\n      console.log(this.name);\n    };\n  },\n  getNameWithArrow: function () {\n    return () => {\n      console.log(this.name);\n    };\n  },\n};\n\nconst anonymousFn = obj.getNameWithAnonymous();\nanonymousFn(); // 输出：undefined\n\nconst arrowFn = obj.getNameWithArrow();\narrowFn(); // 输出：ZJU\n```\n> 进一步完善.\n\n### 事件对象\n$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如`event`,`e`,`evt`. 它被自动传递给事件处理函数，以提供额外的功能和信息。\n\n`e.target`始终是对 **事件刚刚发生的元素** 的引用\n\n## 表达式和运算符\n### new()\n$\\underline{new}$ 用来创建对象实例的一个关键字. \n- 作用: **调用** 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n#### 语法\n```js\nnew constructor\nnew constructor()\nnew constructor(arg1)\nnew constructor(arg1, arg2)\nnew constructor(arg1, arg2, /* …, */ argN)\n```\n1. 如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即`new foo` 等价于 `new foo()`;\n2. 构造函数内部的`this`将被绑定到新建的对象实例上;\n\n- e.g. \n```js\nfunction Car(color, brand) {\n  this.color = color;   // 将 color 赋值给新对象\n  this.brand = brand;   // 将 brand 赋值给新对象\n}\n\nconst myCar = new Car(\"red\", \"Toyota\");\n\nconsole.log(myCar.color); // 输出 \"red\"\nconsole.log(myCar.brand); // 输出 \"Toyota\"\n```\n\n使用`new()`的**步骤**:\n 1. 定义构造函数;\n 2. 使用`new()`并传入构造函数的参数;\n 3. 将返回的对象实例赋值给一个变量;\n\n#### 新增属性\n- 为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n```js\ncar1.color = \"black\" //为car1新增color属性\n```\n<br>\n\n- 添加共享属性到构造函数中的`prototype`:\n```js\nfunction Car() {}\ncar1 = new Car();\ncar2 = new Car();\n\nconsole.log(car1.color); // undefined\n\nCar.prototype.color = \"原色\";\nconsole.log(car1.color); // '原色'\n\ncar1.color = \"黑色\";\nconsole.log(car1.color); // '黑色'\n\nconsole.log(Object.getPrototypeOf(car1).color); // '原色'\nconsole.log(Object.getPrototypeOf(car2).color); // '原色'\nconsole.log(car1.color); // '黑色'\nconsole.log(car2.color); // '原色'\n```\n> - 此处的构造函数名为`Car`, 因此通过`Car.prototype`可以访问到构造函数的原型对象;\n> - `getPrototypeOf` 表示获取对象的**原型对象**, 因此此处均为最初定义的 **原色**.\n\n#### new.target\n函数通过`new.target`属性可以判断是否通过`new`关键字调用, 即构造.\n- 如果函数是正常调用, 则返回`undefined`;\n- 如果函数是通过`new`调用, 返回被调用的构造函数.\n\n- e.g.\n```js\nfunction Car(color) {\n  if (!new.target) {\n    // 以函数的形式被调用。\n    return `${color}车`;\n  }\n  // 通过 new 被调用。\n  this.color = color;\n}\n\nconst a = Car(\"红\"); // a 是“红车”\nconst b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n```\n\n#### 对象类型与实例\n$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:\n```js\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n```\n\n$\\underline{对象实例}$ 通过使用`new()`方法, 由对象类型构造一个对象实例:\n```js\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n```\n\n#### 类与new\n在JS当中, 类 **必须** 通过`new`调用.\n> 可以优先阅读[类相关的知识](#类)\n\n- e.g. \n```js\nclass Animal {\n  //构造函数\n  constructor(name) {\n    this.name = name;\n  }\n  //实例方法\n  greet() {\n    console.log(`你好，我的名字是${this.name}`);\n  }\n}\n```\n对于上述的类, 必须使用如下的调用方式:\n```js\nconst animal = new Animal(\"Dog\"); // 正常\n```\n而下面这样类似于普通函数的调用方式会抛出错误:\n```js\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n```\n<br>\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\n```js\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n```\n\n---\n\n下面给出与普通函数的区别:\n```js\nfunction Car(model) {\n  this.model = model;\n}\n\nconst car = new Car(\"Toyota\"); // 正常\nCar(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.\nconst anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n```\n总结:\n- 以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n- 如果以new方法构造得到对象实例, 依旧正常.\n\n---\n\n# 补充\n## 默认行为\n$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n- 比如存在以下的默认行为:\n  - 滚动事件：触摸屏上滑动手指，页面会滚动;\n  - 拖拽文件到浏览器：浏览器会尝试加载文件;\n  - 点击链接 `(<a href=\"...\">)`：跳转到指定的 URL;\n\n$\\underline{阻止默认行为}$ 使用 `event.preventDefault()` 方法可以阻止事件的默认行为.\n\n- e.g: 阻止链接跳转\n```js\ndocument.querySelector('a').addEventListener('click', function(event) {\n    event.preventDefault(); // 阻止点击链接时的默认行为\n    console.log('链接被点击，但没有跳转');\n});\n```\n\n- 作用:\n  - 通过阻止默认行为, 可以实现自定义逻辑.\n\n## this\n\n- `this`可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\n- `this` 指向的是**当前函数的调用者**，而不是函数内部定义的变量.\n\n<br>\n\n- e.g.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处的`f`\n\n### 函数上下文中的this\n- `this`参数的值取决于函数**如何**被调用, 而不是函数如何被定义.\n```js\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，\n// 并且 'this' 将被绑定到它。\nconst obj = { a: \"Custom\" };\n\n// 使用 var 声明的变量成为 'globalThis' 的属性。\nvar a = \"Global\";\n\nfunction whatsThis() {\n  return this.a; // 'this' 取决于函数如何被调用\n}\n\nwhatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'\nobj.whatsThis = whatsThis;\nobj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n```\n1. 同样是调用函数`whatsThis()`, 但是`this`参数被绑定到不同的对象上, 导致返回值不同;\n2. 在非严格模式下, `this`参数默认指向`globalThis`, 即全局对象;\n3. 对于典型函数, `this`指向函数访问的对象;\n\n- e.g. \n```js\nconst obj = {\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处`f`作为`obj`对象的方法被调用, 因此普通函数的`this`指向`obj`.\n\n- e.g. 直接调用的普通函数`this`指向全局:\n```js\nconst obj = {\n    a: \"a in the obj\",\n    f: function() {\n        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定\n        console.log(funcA()); // 访问 this.a\n    }\n};\n\nvar a = \"a in the global\";\nobj.f(); // \"a in the global\"\n```\n> - 此处的`funcA`并没有类似于作为对象的属性调用(`obj.funcA()`), 因此其`this`指向全局作用域(`window`), 输出`undefined`, 而是直接调用的形式, 因此其`this`指向全局作用域.\n\n\n\n\n\n### 对this传值\n使用`call()`以及`apply()`方法可以将`this`绑定到其他对象上.\n#### call()\n- 形式: `func.call(thisArg, arg1, arg2, ...)`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 剩余的参数被绑定到命名参数。\nadd.call(o, 5, 7); // 16\n```\n\n#### apply()\n- 形式: `func.apply(thisArg, [argsArray])`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 第二个参数是一个数组，其成员被绑定到命名参数。\nadd.apply(o, [10, 20]); // 34\n```\n\n#### bind()\n- 形式: `f.bind(someObject)`;\n- **作用**: \n  - 创建一个新的函数(需要重新赋值), 具有与`f`相同的函数体和作用域;\n  - 新函数的`this`被 **永久地** 绑定到`someObject`, 不随调用方式的变化而变化.\n- **限制**: \n  - `bind`无法多次生效. 即对函数f`bind`得到的g, 无法继续用`bind`得到期望的h;\n- e.g. 多次`bind`:\n```js\nfunction f() {\n  return this.a;\n}\n\nconst g = f.bind({ b: \"azerty\" });\nconsole.log(g()); // undefined\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // undefined\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n```\n> - 由于`bind`只能对一个原始函数作用, 因此由f得到的g无法继续由`bind`绑定`this`得到期望的h, 此处h的`this`依旧是`{b: \"azerty\"}`, 因此在输出对象`a`时显示`undefined`;\n> - `o.f()`的调用是普通函数的调用, 因此其`this`继承自对象`o`, 输出`37`;\n\n- e.g. 对象\n```js\nfunction f() {\n  return this.a + \" \" + this.c;\n}\n\nconst g = f.bind({ b: \"azerty\" , c:\"ccc\"});\nconsole.log(g()); // \"undefined ccc\"\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // \"undefined ccc\"\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n```\n> - `bind`绑定的`this`是永久覆盖, 而非简单叠加;\n> - 由于`bind`绑定的`this`不随者调用方式的变化而变化, 因此即使处于对象`o`当中, `g`,`h`依旧不会输出`o`中的`a`.\n\n### 箭头函数中的this\n\n\n使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n\n\n普通函数:\n```js\nconst a = \"a in the global\";\nconst foo = function () {return this.a};\n\nconst obj = {\n a: \"a in the obj\",\n f: foo\n};\n\nconsole.log(obj.f()); // \"a in the obj\"\n```\n\n`call()`、 `apply()`、 `bind()` 无法改变箭头函数的`this`(但是call与apply的其他参数可以正常传递:\n```js\nconst foo = ()=> this.a;\n\nconst obj = {\n a: \"a in the obj\",\n f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效\n};\n\nconsole.log(obj.f()); // undefined\n\n```\n> 换成普通函数则输出`a in the obj`.\n\n\n- 全局作用域\n```js\nvar a = \"a in the global\";\nconst foo1 = () => this.a;\n\nconst obj = {\n\ta: \"a in the obj\",\n\tf: ()=> a\n};\n\nconsole.log(obj.f());\n```\n\n## 作用域\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n- 块级作用域: 由`let`或`const`声明的变量的作用域.(对于`var`无效);\n\n```js\n{\n  var x = 1;\n}\nconsole.log(x); // 1\n\n{\n  const x = 1;\n}\nconsole.log(x); // undefined\n```\n\nNotices:\n- 对象本身并不会创建作用域, 只是一个键值对的集合;\n- 箭头函数也不会创建自己的作用域, 而是 **继承** 外层作用域中的`this`;\n\n### 变量与作用域\n- `var`在全局作用域中声明时会成为 **全局对象** (`window`或`global`)的属性;\n- `let`和`const`即使在全局作用域中声明, 也不会成为全局对象的属性;\n```js\nvar a = \"1\";\nlet b = \"2\";\n\nwindow.a; // \"1\"\nwindow.b; // undefined\n```\n> 因此, 建议在全局作用域中不要使用`var`声明变量, 而使用`let`或`const`声明变量. 从而避免导致意外的覆盖和冲突.\n\n\n### 函数与作用域\n#### 普通函数\n普通函数和匿名函数的作用域继承自其定义时的作用域.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: function() {\n            return this.a; // 普通函数，this 动态绑定到 insideObj\n        }\n    },\n    f: function() {\n        return this.a; // 普通函数，this 动态绑定到 obj\n    }\n};\n\nconsole.log(obj.f());        // \"a in the obj\"\nconsole.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n```\n\n#### 箭头函数\ne.g. **箭头函数继承外层作用域**:\n```js\nvar a = \"a in the global\";\n\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: () => this.a\n    },\n    f: () => this.a\n};\n\nconsole.log(obj.f());        // \"a in the global\"\nconsole.log(obj.insideObj.g()); //\"a in the global\"\n```\n由于对象不会创建作用域, 因此此处的箭头函数的`this`继承了外层作用域(window)的`this`, 且`var`创建的变量存在于全局作用域中.\n\n## 语法糖\n$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.\n- 本质上没有增加语言的功能, 而是对已有功能的 **包装** 或者优化;\n- **可读性提升**: ~~让代码更填~~ 使得代码更加容易理解和书写;\n- **底层实现**: 实质上依旧用基础的语法实现.\n\n### 类\n类 `class` 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承`prototype`的封装.\n\n使用`class`的写法:\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n等价的原型写法:\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n### 箭头函数\n箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\n- e.g.\n```js\n// 使用箭头函数\nconst add = (a, b) => a + b;\n\n// 等价的普通函数\nconst add = function add(a, b) {\n  return a + b;\n}\n```\n\n### 结构赋值\n$\\underline{结构赋值}$ 手动提取**对象**属性的语法糖.\n\n- 使用结构赋值:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst {name, gender} = person;\n```\n\n- 等价的原型写法:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst name = person.name;\nconst gender = person.gender;\n```\n\n#### 赋值规则\n结构赋值时, 基于 **属性名匹配** 而非顺序. \n因此, 对象结构的`{}`内部属性必须和 **对象的属性名** 相对应.\n\n**错误**的示例:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { a, b } = person;\n\nconsole.log(a); // 输出：undefined\nconsole.log(b); // 输出：undefined\n```\n\n**重命名属性**的写法:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { name: a, age: b } = person;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n\n**手动赋值**: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\n```js\nconst person = { name: \"Alice\" };\nconst { name, age = 30 } = person;\n\nconsole.log(name); // 输出：Alice\nconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n```\n#### 数组的结构赋值\n上述讨论的结构赋值都是对 **对象** 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— **基于顺序**赋值:\n```js\nconst arr = [\"Alice\", 25];\nconst [a, b] = arr;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n","slug":"编程语言/JavaScript","published":1,"updated":"2025-02-07T07:21:02.402Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4w00023dwqg1xkjfpj4","content":"<blockquote>\n<p>JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「<strong>料理的加护</strong>」下, 尽可能将JS处理得更加<strong>可口</strong>一些)<br><img src=\"/img/料理的加护.jpg\" width = \"35%\"></p>\n</blockquote>\n<h1 id=\"创建JS代码块\"><a href=\"#创建JS代码块\" class=\"headerlink\" title=\"创建JS代码块\"></a>创建JS代码块</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-or-let\"><a href=\"#var-or-let\" class=\"headerlink\" title=\"var or let?\"></a><code>var</code> or <code>let</code>?</h3><p><code>var</code>先于<code>let</code>的产生, 后者是现代版本的JS中新的关键字.</p>\n<p>使用<code>var</code>, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是<code>let</code>并不适用.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logName</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myName);<br>&#125;<br><br><span class=\"hljs-title function_\">logName</span>(); <span class=\"hljs-comment\">//输出&quot;Chris&quot;</span><br><br><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Aniya&quot;</span>;<br><span class=\"hljs-title function_\">logName</span>(); <span class=\"hljs-comment\">//输出&quot;Aniya&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p>除此之外, 可以使用<code>var</code>前后声明相同的变量, 这并不会报错:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p>\n<p>而<code>let</code>只能声明一次:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br>myName = <span class=\"hljs-string\">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p>\n<p>因此, 在代码编写中应尽量<strong>多使用</strong><code>let</code>而非<code>var</code>, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.</p>\n<h3 id=\"变量命名的规则\"><a href=\"#变量命名的规则\" class=\"headerlink\" title=\"变量命名的规则\"></a>变量命名的规则</h3><p>与C语言类似, 建议以 <strong>字母、数字、下划线</strong> 组成的标识符来命名变量.</p>\n<ul>\n<li>不可用<code>_</code>开头, 因为可能被JS设计为特殊的含义;</li>\n<li>不可用数字开头, 否则引发错误;</li>\n<li>大小写敏感;</li>\n<li>建议采用 <strong>小写驼峰命名法</strong> ,即小写整个命名的第一个字母然后大写剩下单词的首字符;</li>\n<li>避免使用保留字, 比如<code>var</code>,<code>let</code>,<code>for</code>等.</li>\n</ul>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myAge = <span class=\"hljs-number\">20</span> ;<span class=\"hljs-comment\">// 数字</span><br><span class=\"hljs-keyword\">let</span> dolphinGoodbye = <span class=\"hljs-string\">&quot;So long and thanks for all the fish&quot;</span>; <span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> test = <span class=\"hljs-number\">6</span> &lt; <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">//boolean</span><br><br><span class=\"hljs-comment\">//数组类型</span><br><span class=\"hljs-keyword\">let</span> myNameArray = [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-string\">&quot;Jim&quot;</span>];<br><span class=\"hljs-keyword\">let</span> myNumberArray = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">40</span>];<br><br><span class=\"hljs-comment\">//对象类型</span><br><span class=\"hljs-keyword\">let</span> dog = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Spot&quot;</span>, <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Dalmatian&quot;</span> &#125;;<br><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>对象类型的访问与结构体相似, <code>dog.name;</code></p>\n</blockquote>\n<p>在上面的几种变量类型中, 我们都采用<code>let</code>关键字声明变量, 这体现了JS是一种 <strong>动态类型语言</strong> ,即无需指定变量包含的数据类型.</p>\n<p>同时, 这也意味着我们可以像<code>python</code>一样对同一个变量先后赋值不同类型的值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myNumber = <span class=\"hljs-string\">&quot;500&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> myNumber;<br><span class=\"hljs-comment\">// 输出 &#x27;string&#x27;</span><br><br>myNumber = <span class=\"hljs-number\">500</span>; <br><span class=\"hljs-keyword\">typeof</span> myNumber;<br><span class=\"hljs-comment\">//输出&#x27;number&#x27;</span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li>$\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">exampleFunction</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">exampleFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;函数内&quot;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>由于 <strong>提升</strong> 的存在, 上述的函数调用不会出错.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在编写函数时, 可以通过在参数名称后添加<code>=</code>, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">greeding</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&quot;my friend&quot;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">//Hello, my friend!</span><br><span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-string\">&quot;world&quot;</span>); <span class=\"hljs-comment\">//Hello, world!</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>事件处理函数的默认接受值是<code>event</code>:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span><br>onclick<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><br>nothing here<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;button&quot;</span>)</span><br><span class=\"language-javascript\">para = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)</span><br><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">btn.<span class=\"hljs-property\">onclick</span> = click;</span><br><span class=\"language-javascript\"></span><br><span class=\"language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">click</span>(<span class=\"hljs-params\">string</span>)&#123;</span><br><span class=\"language-javascript\">  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;clicked!&quot;</span>)</span><br><span class=\"language-javascript\">  para.<span class=\"hljs-property\">textContent</span> = string;</span><br><span class=\"language-javascript\">&#125;</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<ol>\n<li>上述的<code>btn</code>在点击之后调用函数<code>click</code>, 该函数需要一个参数<code>string</code>, 由于<code>btn.onclick = click;</code>的绑定方式, 我们无法指定传参的值, 因此点击之后的<code>para</code>的内容显示为: <code>[object PointerEvent]</code>;</li>\n<li><code>textContent</code>是属性而非方法, 因此采用赋值实现;</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">btn.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">click</span>(<span class=\"hljs-params\">string</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;clicked!&quot;</span>)<br>  para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;You have clicked the button!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>将上述的绑定方式如此改写, 可以在<code>btn</code>外对<code>string</code>进行赋值, 然后点击按钮可以传入指定参数供后续处理.</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 匿名函数</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.</p>\n</blockquote>\n<p>如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logKey</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;<br><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, logKey);<br></code></pre></td></tr></table></figure><br>这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.</p>\n</blockquote>\n<p>而<strong>箭头函数</strong>则是在此情况下更简洁的函数定义方式:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br><br><span class=\"hljs-comment\">//如果函数只接受一个参数, 也可以省略参数周围的括号</span><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<p>如果只包含一行的<code>return</code>,则可以忽略<code>&#123;&#125;</code>和<code>return</code>关键字:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> originals = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-keyword\">const</span> doubled = originals.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(doubled); <span class=\"hljs-comment\">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>item =&gt; item * 2</code>等价于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doubleItem</span>(<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> item * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"一个实例\"><a href=\"#一个实例\" class=\"headerlink\" title=\"一个实例\"></a>一个实例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;textBox&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;output&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> textBox = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#textBox&quot;</span>);<br><span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#output&quot;</span>);<br><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> &#123;<br>  output.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>通过监听输入框的keydown事件, 输出按下的键盘按键.</p>\n<h3 id=\"函数作用域和冲突\"><a href=\"#函数作用域和冲突\" class=\"headerlink\" title=\"函数作用域和冲突\"></a>函数作用域和冲突</h3><p>$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n</ul>\n<p>和C语言相似, 在函数外部<code>let</code>定义的变量, 以及<code>const</code>定义的常量可以在函数内部访问.</p>\n<p>如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Excerpt from my HTML --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;first.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;second.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br>  greeting();<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果两个JS文件都定义了<code>greeting</code>函数, 则只有第一个文件中的函数才会被调用.</p>\n</blockquote>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数字和操作符\"><a href=\"#数字和操作符\" class=\"headerlink\" title=\"数字和操作符\"></a>数字和操作符</h3><p>大部分与C语言相同, 概括需要注意的差异:</p>\n<ul>\n<li>JS当中只有一种数字类型 — <code>number</code>, 对于整型或者浮点数的初始化得到的量, 由<code>typeof</code>均得到<code>number</code>;</li>\n<li>算术运算符: 求幂为<code>**</code>;</li>\n<li>常量无法使用自增或自减,<del>好像也是C语言的 忘了</del></li>\n<li><code>===</code>表示严格等于, <code>!==</code>表示不等于;<blockquote>\n<p>同时存在<code>==</code>和<code>!=</code>来判断是否相等, 但是它们只是测试 <strong>值</strong> 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用<code>===</code>和<code>!==</code>来避免类型不一致的错误.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>创建字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myString = <span class=\"hljs-string\">&quot;A string&quot;</span>;<br><span class=\"hljs-keyword\">const</span> constString = myString;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(constString);<br><span class=\"hljs-comment\">//A string</span><br></code></pre></td></tr></table></figure><br>可以使用单引号,双引号和<strong>反引号</strong>来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> single = <span class=\"hljs-string\">&#x27;单引号&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> double = <span class=\"hljs-string\">&quot;双引号&quot;</span>;<br><span class=\"hljs-keyword\">const</span> backtick = <span class=\"hljs-string\">`反引号`</span>;<br></code></pre></td></tr></table></figure></p>\n<p>反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:</p>\n<ul>\n<li>可以嵌入 <strong>JavaScript</strong>;</li>\n<li>可以声明<strong>多行</strong>的模板字面量.</li>\n</ul>\n<h4 id=\"字符串的拼接\"><a href=\"#字符串的拼接\" class=\"headerlink\" title=\"字符串的拼接\"></a>字符串的拼接</h4><p>字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;克里斯&quot;</span>;<br><span class=\"hljs-keyword\">const</span> greeting = <span class=\"hljs-string\">`你好，<span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting); <span class=\"hljs-comment\">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在模板字面量中用<code>$&#123;&#125;</code>包装JS的变量或者表达式.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> one = <span class=\"hljs-string\">&quot;你好，&quot;</span>;<br><span class=\"hljs-keyword\">const</span> two = <span class=\"hljs-string\">&quot;请问最近如何？&quot;</span>;<br><span class=\"hljs-keyword\">const</span> joined = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;one&#125;</span><span class=\"hljs-subst\">$&#123;two&#125;</span>`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(joined); <span class=\"hljs-comment\">// &quot;你好，请问最近如何？&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>连接2个变量.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> song = <span class=\"hljs-string\">&quot;青花瓷&quot;</span>;<br><span class=\"hljs-keyword\">const</span> score = <span class=\"hljs-number\">9</span>;<br><span class=\"hljs-keyword\">const</span> highestScore = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-string\">`我喜欢歌曲《<span class=\"hljs-subst\">$&#123;song&#125;</span>》。我给它打了 <span class=\"hljs-subst\">$&#123;</span></span><br><span class=\"hljs-subst\"><span class=\"hljs-string\">  (score / highestScore) * <span class=\"hljs-number\">100</span></span></span><br><span class=\"hljs-subst\"><span class=\"hljs-string\">&#125;</span> 分。`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(output); <span class=\"hljs-comment\">// &quot;我喜欢歌曲《青花瓷》。我给它打了 90 分。&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>在模板字面量的<code>$&#123;&#125;</code>内部包含表达式.</p>\n</blockquote>\n<p><br><br>除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用<code>+</code>直接连接:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> greeting = <span class=\"hljs-string\">&quot;你好&quot;</span>;<br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;克里斯&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting + <span class=\"hljs-string\">&quot;，&quot;</span> + name); <span class=\"hljs-comment\">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h4><p>模板字符串会<strong>保留</strong>源代码中的换行符，因此可以编写跨越多行的字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> newline = <span class=\"hljs-string\">`终于有一天，</span><br><span class=\"hljs-string\">你知道了必须做的事情，而且开始……`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newline);<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">终于有一天，</span><br><span class=\"hljs-comment\">你知道了必须做的事情，而且开始……</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure></p>\n<p>如果希望用普通的字符串得到等效的输出, 必须在字符串中包含<code>\\n</code>,而非直接跨行:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> newline = <span class=\"hljs-string\">&quot;终于有一天，\\n你知道了必须做的事情，而且开始……&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newline);<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">终于有一天，</span><br><span class=\"hljs-comment\">你知道了必须做的事情，而且开始……</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"显示引号\"><a href=\"#显示引号\" class=\"headerlink\" title=\"显示引号\"></a>显示引号</h4><ol>\n<li>$\\underline{转义}$  通过在符号前加上反斜杠<code>\\</code>, 可以转义字符串中的特殊字符,包括字符串中的引号:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bigmouth = <span class=\"hljs-string\">&#x27;I\\&#x27;ve got no right to take my place…&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>换用其他字符: 在字面量内用不同于包裹字符串的引号:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> goodQuotes1 = <span class=\"hljs-string\">&#x27;She said &quot;I think so!&quot;&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> goodQuotes2 = <span class=\"hljs-string\">`She said &quot;I&#x27;m not going in there!&quot;`</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p>对于字符串对象实例,其常用的方法:</p>\n<ul>\n<li><code>.length</code>: 获取字符串的长度;</li>\n<li><code>[]</code>: 返回字符串中对应索引的字符, 索引同样从<code>0</code>开始;</li>\n<li><code>.indexOf(&quot;&quot;)</code>: 查找子字符串<ul>\n<li><strong>input</strong>: 希望查找的子字符串;</li>\n<li><strong>output</strong>: 子字符串开始的下标(如果不存在则返回<code>-1</code>);</li>\n</ul>\n</li>\n<li><code>.slice(indedxStart, indexEnd)</code>: 截取字符串<ul>\n<li><strong>input</strong>: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;</li>\n<li><strong>output</strong>: 截取的子字符串;</li>\n</ul>\n</li>\n</ul>\n<p>更多的<code>slice</code>知识:</p>\n<ol>\n<li>$\\underline{标准化负值}$ 如果索引是个负数, 取<code>index+str.length</code>进行标准化;</li>\n<li>如果<code>indexStart</code>大于<code>str.length</code>, 返回空字符串;</li>\n<li>如果标准化负值之后, <code>indexStart</code>大于<code>indexEnd</code>, 也返回空字符串;</li>\n</ol>\n<ul>\n<li><code>.toLowerCase()</code> &amp; <code>.toUpperCase()</code>: 转换字符串中的所有字符为小写或大写;</li>\n<li><code>.replace(original, new)</code>: 替换字符串中<code>original</code>子字符串为<code>new</code>;<blockquote>\n<p>此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cases\"><a href=\"#Cases\" class=\"headerlink\" title=\"Cases\"></a>Cases</h4><p>利用 <strong>indexOf</strong> 和 <strong>slice</strong> 方法, 获取新字符串:</p>\n<ul>\n<li><strong>input</strong>: <code>&quot;str3&quot;</code>三位长字符串+<code>&quot;...&quot;</code>(无关字符串)+<code>&quot;;&quot;</code>+<code>strLast</code>(剩余字符串);</li>\n<li><strong>output</strong>: <code>&quot;str3&quot;+&quot;;&quot;+strLast</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> stations = [<span class=\"hljs-string\">&#x27;MAN675847583748sjt567654;Manchester Piccadilly&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;GNF576746573fhdg4737dh4;Greenfield&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;LIV5hg65hd737456236dch46dg4;Liverpool Lime Street&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;SYB4f65hf75f736463;Stalybridge&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; stations.<span class=\"hljs-property\">length</span>; i++)&#123;<br>    <span class=\"hljs-keyword\">var</span> input = stations[i];<br>    <span class=\"hljs-keyword\">var</span> str3 = input.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>);<br>    <span class=\"hljs-keyword\">var</span> strLast = input.<span class=\"hljs-title function_\">slice</span>(input.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">&quot;;&quot;</span>)+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//indexOf获取;位置</span><br>    <span class=\"hljs-keyword\">var</span> output = str3 + <span class=\"hljs-string\">&quot;;&quot;</span> + strLast;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p>通过 <strong>indexOf</strong> 根据子字符串筛选字符串数组:</p>\n<ul>\n<li><strong>input</strong>: 可能包含 <em>Christmas</em> 的字符串数组;</li>\n<li><strong>output</strong>: 包含 <em>Christmas</em> 的字符串数组;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> list = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.output ul&#x27;</span>);<br>list.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> greetings = [<span class=\"hljs-string\">&#x27;Happy Birthday!&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;Merry Christmas my love&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;A happy Christmas to all the family&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;You\\&#x27;re all I want for Christmas&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;Get well soon&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; greetings.<span class=\"hljs-property\">length</span>; i++) &#123;<br>  <span class=\"hljs-keyword\">var</span> input = greetings[i];<br>  <span class=\"hljs-keyword\">if</span>(greetings[i].<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">&#x27;Christmas&#x27;</span>) !== -<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = input;<br>    <span class=\"hljs-keyword\">var</span> listItem = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);<br>    listItem.<span class=\"hljs-property\">textContent</span> = result;<br>    list.<span class=\"hljs-title function_\">appendChild</span>(listItem);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><h4 id=\"相互转换\"><a href=\"#相互转换\" class=\"headerlink\" title=\"相互转换\"></a>相互转换</h4><p>非常神奇, 在JS当中, 数字和字符串可以直接通过函数<code>Number()</code>和<code>String()</code>进行转换, 与C语言不同.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myString = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-keyword\">const</span> myNum = <span class=\"hljs-title class_\">Number</span>(myString);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> myNum);<br><span class=\"hljs-comment\">// number</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myNum);<br><span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myNum2 = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> myString2 = <span class=\"hljs-title class_\">String</span>(myNum2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> myString2);<br><span class=\"hljs-comment\">// string</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myString2);<br><span class=\"hljs-comment\">// &quot;123&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>对于浮点数同样成立.</p>\n</blockquote>\n<h4 id=\"前后拼接\"><a href=\"#前后拼接\" class=\"headerlink\" title=\"前后拼接\"></a>前后拼接</h4><p>使用<code>+</code>将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;Front &quot;</span>;<br><span class=\"hljs-keyword\">const</span> number = <span class=\"hljs-number\">242</span>;<br><span class=\"hljs-keyword\">const</span> combine = name + number;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(combine); <span class=\"hljs-comment\">//Front 242</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">typeof</span>(combine));  <span class=\"hljs-comment\">//string</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>存储任意类型元素—字符串，数字，对象，变量，<strong>另一个数组</strong>;</li>\n<li>可以 <strong>混合</strong> 元素类型:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> random = [<span class=\"hljs-string\">&quot;tree&quot;</span>, <span class=\"hljs-number\">795</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]];<br></code></pre></td></tr></table></figure></li>\n<li>像访问字符串一样, 利用索引访问数组元素;</li>\n<li>$\\underline{多维数组}$ 包含数组的数组结构称为~</li>\n</ol>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>作用: 将一个字符串根据给定的字符分隔为字符串数组;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myData = <span class=\"hljs-string\">&quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;</span>;<br><span class=\"hljs-keyword\">let</span> myArray = myData.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;,&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray);<br> <span class=\"hljs-comment\">// [&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;]</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h4><p><code>split</code>的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myNewString = myArray.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;,&quot;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>与<code>join</code>方法相似, 但是无法自定义分隔符, 默认为<code>,</code>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> dogNames = [<span class=\"hljs-string\">&quot;Rocket&quot;</span>, <span class=\"hljs-string\">&quot;Flash&quot;</span>, <span class=\"hljs-string\">&quot;Bella&quot;</span>, <span class=\"hljs-string\">&quot;Slugger&quot;</span>];<br>dogNames.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">//Rocket,Flash,Bella,Slugger</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"push-amp-pop\"><a href=\"#push-amp-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h4><p><code>push()</code>方法可以将1或多个元素添加到数组的 <strong>末尾</strong>:</p>\n<ol>\n<li>将会直接改写原来的数组,不需要重新赋值;</li>\n<li>该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myArray = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> newLength = myArray.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>,<span class=\"hljs-string\">&quot;string&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, &quot;string&quot;]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newLength); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>使用<code>.pop()</code>从数组中删除最后一个元素:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">myArray.<span class=\"hljs-title function_\">pop</span>(); <span class=\"hljs-comment\">//&quot;string&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p>\n<ol>\n<li>方法调用返回值就是删除的元素本身;</li>\n<li>直接对原始数组操作并赋值, 不需要另外的赋值操作;</li>\n</ol>\n<blockquote>\n<p>shift &amp; unshift:<br>在功能上分别与<code>push</code>和<code>pop</code>相同, 但是作用于数组的开始位置.</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:</p>\n<h3 id=\"天气预报\"><a href=\"#天气预报\" class=\"headerlink\" title=\"天气预报\"></a>天气预报</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;weather&quot;</span>&gt;</span>选择今天的天气：&lt;/label<br>&gt;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;weather&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>--作出选择--<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;sunny&quot;</span>&gt;</span>晴天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;rainy&quot;</span>&gt;</span>雨天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;snowing&quot;</span>&gt;</span>雪天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;overcast&quot;</span>&gt;</span>阴天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>lable</code>当中的<code>for</code>标签与<code>select</code>标签的<code>id</code>属性对应, 用于关联两个标签.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> select = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;select&quot;</span>);<br><span class=\"hljs-keyword\">const</span> para = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br>select.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;change&quot;</span>, setWeather);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setWeather</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> choice = select.<span class=\"hljs-property\">value</span>;<br><br>  <span class=\"hljs-keyword\">switch</span> (choice) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;sunny&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;rainy&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;snowing&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> =<br>        <span class=\"hljs-string\">&quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;overcast&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> =<br>        <span class=\"hljs-string\">&quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-attr\">default</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>通过<code>querySelector</code>方法获取<code>select</code>和<code>p</code>标签;</li>\n<li>然后为<code>select</code>标签添加事件监听器, 当内容改变时触发 <strong>change</strong> 事件, 同时调用<code>setWeather</code>函数;</li>\n<li>进而通过 <strong>switch</strong> 语句处理不同天气的情况, 并设置相应的文字内容;<br>在线网页示例:<a href=\"https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html\">simple-switch</a></li>\n</ol>\n</blockquote>\n<h2 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h2><p>什么是$\\underline{事件}$? </p>\n<ul>\n<li>用户选择、点击或者光标悬停在某一元素;</li>\n<li>用户在键盘中按下某个按键;</li>\n<li>网页结束加载;</li>\n<li>…</li>\n</ul>\n<p>$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.</p>\n<h3 id=\"处理点击事件\"><a href=\"#处理点击事件\" class=\"headerlink\" title=\"处理点击事件\"></a>处理点击事件</h3><p>以点击事件为例, 介绍html与js如何进行事件处理的交互:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span> 改变颜色 <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;button&quot;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">random</span>(<span class=\"hljs-params\">number</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>()*(number+<span class=\"hljs-number\">1</span>));<br>  <br>&#125;<br><br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">()=&gt;</span>&#123;<br>  <span class=\"hljs-keyword\">const</span> rndCol = <span class=\"hljs-string\">`rgb(<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>,<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>,<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>)`</span>;<br>  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = rndCol;<br>&#125;)<br></code></pre></td></tr></table></figure></p>\n<ol>\n<li><code>Math.random()</code>方法生成一个介于[0,1)之间的随机数;</li>\n<li><code>*(number+1)</code>之后利用向下取整的方法<code>Math.floor()</code>将其转换为整数, 范围为[0,number];<blockquote>\n<p>假如输入的number为<code>4</code>, 则<code>random(4)</code>的结果可能为<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>中的一个;<br>假设输入的number为<code>3.6</code>, 则输出的结果还是0~4中的整数.</p>\n</blockquote>\n</li>\n<li><code>rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;,$&#123;random(255)&#125;)</code> 采用的是在$\\underline{模板字符串}$内部使用<code>$&#123;&#125;</code>调用函数变量的方法.</li>\n</ol>\n<h3 id=\"addEventListener\"><a href=\"#addEventListener\" class=\"headerlink\" title=\"addEventListener()\"></a>addEventListener()</h3><p><code>adEventListener</code>方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.</p>\n<p>通过<code>EventTarget.adddEventListener()</code>的方法, 将指定的监听器注册到对象上, 具体的语法如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">addEventListener</span>(type, listener);<br><span class=\"hljs-title function_\">addEventListener</span>(type, listener, options);<br><span class=\"hljs-title function_\">addEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>type</code>: 事件类型, 如<code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>等;</li>\n<li><code>listener</code>: 事件处理函数, 该函数将在事件发生时被调用;<ul>\n<li>包括 <strong>回调函数</strong> 以及 实现了 <strong>EventListener 接口的对象</strong>;</li>\n</ul>\n</li>\n<li><code>options</code>: 可选参数, 用于配置事件监听器的行为;<blockquote>\n<p>可以为单个事件添加多个事件监听器.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"listener\"><a href=\"#listener\" class=\"headerlink\" title=\"listener\"></a>listener</h4><p>$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.</p>\n<ul>\n<li>是一个函数, 但是只有等到特定的事件发生时才会执行.</li>\n</ul>\n<p>实现了 EventListener 接口的对象:</p>\n<ul>\n<li><strong>特点</strong>: 以对象作为listener, 对象中具有名为<code>handleEvent()</code>的方法;</li>\n<li><strong>作用</strong>: <ul>\n<li>将事件处理封装到一个对象当中, 可以更好地组织代码;</li>\n<li>便于在对象中保存更多的状态信息;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> listenerObject = &#123;<br>    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-title function_\">handleEvent</span>(<span class=\"hljs-params\">event</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>++;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`事件类型是：<span class=\"hljs-subst\">$&#123;event.type&#125;</span>，已触发 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.count&#125;</span> 次`</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>button.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, listenerObject);<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>一个指定有关 listener 属性的可选参数对象.</p>\n<h5 id=\"Capture\"><a href=\"#Capture\" class=\"headerlink\" title=\"Capture\"></a>Capture</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;</li>\n<li>默认为false, 表示只有在冒泡阶段才触发.</li>\n</ul>\n</li>\n<li><p>区别:</p>\n<ul>\n<li><code>capture</code>和<code>useCapture</code>实际上指的都是 <strong>监听器是否在捕获阶段触发</strong> 的布尔值.<blockquote>\n<p>捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.</p>\n</blockquote>\n</li>\n<li>后来DOM的规范更新时引入了<code>options</code>参数, 此后<code>capture</code>取代了<code>useCapture</code>的作用.</li>\n<li>如果<code>addEventListener</code>的第三个参数不指定对象, 只有布尔值, 那么默认是在设置<code>useCapture</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可以先查看<a href=\"#事件传播的阶段\">事件传播的阶段</a>来辅助理解不同的阶段.</p>\n</blockquote>\n<h5 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h5><ul>\n<li>含义:<ul>\n<li>一个布尔值，表示 listener 在添加之后最多只调用一次;</li>\n<li>默认为false, 表示可以多次调用.</li>\n</ul>\n</li>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">child.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">once</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>once</code>属性被设置为<code>true</code>, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Passive\"><a href=\"#Passive\" class=\"headerlink\" title=\"Passive\"></a>Passive</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();</li>\n</ul>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>明确不会在<code>listener</code>中不会调用<code>preventDefault()</code>方法, 即不会阻止浏览器的<a href=\"#默认行为\">默认行为</a>;</li>\n<li>此时, 浏览器可以直接渲染默认行为的结果, 无需等待<code>listener</code>的执行与默认行为的检查, 从而提高了性能.</li>\n</ul>\n</li>\n<li>Notice:<ul>\n<li>如果设置<code>passive</code>为<code>true</code>, 则<code>listener</code>当中不可出现<code>preventDefault()</code>方法, 否则会报错.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>\tevent.<span class=\"hljs-title function_\">preventDefault</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">false</span>&#125;);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>wheel</code>事件的默认行为是滚动页面;</li>\n<li><code>event.preventDefault();</code>表示会阻止鼠标滚动带来的页面滚动;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>  event.<span class=\"hljs-title function_\">preventDefault</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>passive</code>的设置与<code>listener</code>内部矛盾, 将会报错.</p>\n</blockquote>\n<h5 id=\"Signal\"><a href=\"#Signal\" class=\"headerlink\" title=\"Signal\"></a>Signal</h5><p>用于有条件地移除事件监听器, 具体使用参见<a href=\"#可被移除的监听器\">可被移除的监听器</a>.</p>\n<h3 id=\"事件传播的阶段\"><a href=\"#事件传播的阶段\" class=\"headerlink\" title=\"事件传播的阶段\"></a>事件传播的阶段</h3><ol>\n<li>捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;<blockquote>\n<p>e.g. 点击事件从document开始传播, 经过html,body直到目标元素.</p>\n</blockquote>\n</li>\n<li>目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;</li>\n<li>冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.</li>\n</ol>\n<h4 id=\"Case\"><a href=\"#Case\" class=\"headerlink\" title=\"Case\"></a>Case</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  parent<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span>child<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> parent = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#parent&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#child&#x27;</span>);<br><br>parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 冒泡阶段&#x27;</span>);<br>&#125;);<br><br>parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>&#125;, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;);<br><br>child.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>上述的<code>child</code>被包裹在<code>parent</code>内部.</p>\n<ul>\n<li><p>当点击<code>parent</code>时将会显示:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-string\">&quot;父元素 - 捕获阶段&quot;</span><br><span class=\"hljs-string\">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;</p>\n</blockquote>\n</li>\n<li><p>当点击<code>child</code>时将会显示:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-string\">&quot;父元素 - 捕获阶段&quot;</span><br><span class=\"hljs-string\">&quot;子元素 - 目标阶段&quot;</span><br><span class=\"hljs-string\">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>child</code>是整个事件流的目标元素, 所以触发时机介于二者之间.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a>Notice</h4><ol>\n<li><p>如果将<code>div</code>换成<code>button</code>, 则点击<code>child</code>时可能只会显示 <strong>目标</strong> 阶段的输出.</p>\n<blockquote>\n<p>这是因为, 不同浏览器对于<code>button</code>元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段</p>\n</blockquote>\n</li>\n<li><p><code>event.stopPropagation();</code>加入该<del>咒语</del>代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>    event.<span class=\"hljs-title function_\">stopPropagation</span>();<br>&#125;, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此时, 点击<code>parent</code>时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"可被移除的监听器\"><a href=\"#可被移除的监听器\" class=\"headerlink\" title=\"可被移除的监听器\"></a>可被移除的监听器</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outside&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;t1&quot;</span>&gt;</span>one<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;t2&quot;</span>&gt;</span>two<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 为 table 添加可被移除的事件监听器</span><br><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();<br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, modifyText, &#123; <span class=\"hljs-attr\">signal</span>: controller.<span class=\"hljs-property\">signal</span> &#125;);<br><br><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  <span class=\"hljs-keyword\">if</span> (t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> === <span class=\"hljs-string\">&quot;three&quot;</span>) &#123;<br>    t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = <span class=\"hljs-string\">&quot;two&quot;</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = <span class=\"hljs-string\">&quot;three&quot;</span>;<br>    controller.<span class=\"hljs-title function_\">abort</span>(); <span class=\"hljs-comment\">// 当值变为 &quot;three&quot; 后，移除监听器</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>AbortController</code>是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;</li>\n<li><code>signal</code>属性是一个<code>AbortSignal</code>对象, 用于控制监听器的移除;</li>\n<li><code>controller.abort()</code>方法用于移除监听器;</li>\n<li>当<code>t2</code>的内容变为”three”时, 移除监听器, 使得<code>modifyText</code>函数不再执行. 此后, 点击<code>t2</code>不会触发<code>modifyText</code>函数.</li>\n</ul>\n</blockquote>\n<p>具体的<strong>构造步骤:</strong></p>\n<ol>\n<li>创建一个<code>AbortController</code>实例: <code>const controller = new AbortController();</code></li>\n<li>在事件监听器内的参数中添加<code>signal: controller.signal</code>选项;</li>\n<li>在需要移除监听器的地方调用<code>controller.abort()</code>方法;</li>\n</ol>\n<hr>\n<p>我们也可以直接使用<code>removeEventListener()</code>方法来移除事件监听器:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">removeEventListener</span>(type, listener);<br><span class=\"hljs-title function_\">removeEventListener</span>(type, listener, options);<br><span class=\"hljs-title function_\">removeEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>Notices:<ul>\n<li>如果同一个对象上存在2个事件监听器, 且仅在<code>useCapture</code>参数存在差异, 那么需要先后2次调用<code>removeEventListener()</code>方法才能完全移除其事件监听器;</li>\n<li>如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;</li>\n<li><code>type</code>,<code>listener</code>参数必须完全匹配才能移除事件监听器;</li>\n<li>对于<code>options</code>参数:<ul>\n<li>字段相同: 一定可以移除;</li>\n<li>字段不同: 需要与默认值false匹配才可以移除.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">element.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span> &#125;);<br><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">false</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;); <span class=\"hljs-comment\">// 失败</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">false</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 失败</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>添加与移除</strong>的结合使用:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> body = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;body&quot;</span>);<br><span class=\"hljs-keyword\">const</span> clickTarget = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;click-target&quot;</span>);<br><span class=\"hljs-keyword\">const</span> mouseOverTarget = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;mouse-over-target&quot;</span>);<br><br><span class=\"hljs-keyword\">let</span> toggle = <span class=\"hljs-literal\">false</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeBackgroundYellow</span>(<span class=\"hljs-params\"></span>) &#123;<br>  body.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = toggle ? <span class=\"hljs-string\">&quot;white&quot;</span> : <span class=\"hljs-string\">&quot;yellow&quot;</span>;<br><br>  toggle = !toggle;<br>&#125;<br><br>clickTarget.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, makeBackgroundYellow, <span class=\"hljs-literal\">false</span>);<br><br>mouseOverTarget.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;mouseover&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  clickTarget.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, makeBackgroundYellow, <span class=\"hljs-literal\">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"使用匿名函数\"><a href=\"#使用匿名函数\" class=\"headerlink\" title=\"使用匿名函数\"></a>使用匿名函数</h3><p>在上述<code>html</code>例子下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\">new_text</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = new_text;<br>&#125;<br><br><span class=\"hljs-comment\">// 用匿名函数为 table 添加事件监听器</span><br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class=\"hljs-literal\">false</span>,<br>);<br></code></pre></td></tr></table></figure><br>通过匿名函数封装代码, 将参数传入函数<code>modifyText</code>, 使得函数可以被调用.</p>\n<h3 id=\"使用箭头函数\"><a href=\"#使用箭头函数\" class=\"headerlink\" title=\"使用箭头函数\"></a>使用箭头函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\">new_text</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = new_text;<br>&#125;<br><br><span class=\"hljs-comment\">// 用箭头函数为 table 添加事件监听器</span><br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class=\"hljs-literal\">false</span>,<br>);<br></code></pre></td></tr></table></figure>\n<p>通过<code>=&gt;&#123;&#125;</code>形式的箭头函数简化代码书写.</p>\n<hr>\n<h4 id=\"比较匿名与箭头\"><a href=\"#比较匿名与箭头\" class=\"headerlink\" title=\"比较匿名与箭头\"></a>比较匿名与箭头</h4><p>匿名函数与箭头函数在此处的应用基本相同, 但是在<code>this</code>的指向上有所不同:</p>\n<ul>\n<li><p>匿名函数与其他普通的JS函数:<code>this</code>指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为<code>undefined</code>);</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>); <span class=\"hljs-comment\">// 在非严格模式下，this 指向 window</span><br>&#125;<br><span class=\"hljs-title function_\">sayHello</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>箭头函数的<code>this</code>继承自外部作用域, 即调用该方法的对象.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;ZJU&quot;</span>,<br>  <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// this 指向 obj</span><br>  &#125;,<br>&#125;;<br>obj.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：ZJU</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;ZJU&quot;</span>,<br>  <span class=\"hljs-attr\">getNameWithAnonymous</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">getNameWithArrow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;;<br>  &#125;,<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> anonymousFn = obj.<span class=\"hljs-title function_\">getNameWithAnonymous</span>();<br><span class=\"hljs-title function_\">anonymousFn</span>(); <span class=\"hljs-comment\">// 输出：undefined</span><br><br><span class=\"hljs-keyword\">const</span> arrowFn = obj.<span class=\"hljs-title function_\">getNameWithArrow</span>();<br><span class=\"hljs-title function_\">arrowFn</span>(); <span class=\"hljs-comment\">// 输出：ZJU</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>进一步完善.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p>$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如<code>event</code>,<code>e</code>,<code>evt</code>. 它被自动传递给事件处理函数，以提供额外的功能和信息。</p>\n<p><code>e.target</code>始终是对 <strong>事件刚刚发生的元素</strong> 的引用</p>\n<h2 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new()\"></a>new()</h3><p>$\\underline{new}$ 用来创建对象实例的一个关键字. </p>\n<ul>\n<li>作用: <strong>调用</strong> 一个 构造函数, 并返回一个由该构造函数创建的对象实例.<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> constructor<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1, arg2</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1, arg2, <span class=\"hljs-comment\">/* …, */</span> argN</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即<code>new foo</code> 等价于 <code>new foo()</code>;</li>\n<li>构造函数内部的<code>this</code>将被绑定到新建的对象实例上;</li>\n</ol>\n<ul>\n<li>e.g. <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">color, brand</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span> = color;   <span class=\"hljs-comment\">// 将 color 赋值给新对象</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">brand</span> = brand;   <span class=\"hljs-comment\">// 将 brand 赋值给新对象</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> myCar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;red&quot;</span>, <span class=\"hljs-string\">&quot;Toyota&quot;</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myCar.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// 输出 &quot;red&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myCar.<span class=\"hljs-property\">brand</span>); <span class=\"hljs-comment\">// 输出 &quot;Toyota&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用<code>new()</code>的<strong>步骤</strong>:</p>\n<ol>\n<li>定义构造函数;</li>\n<li>使用<code>new()</code>并传入构造函数的参数;</li>\n<li>将返回的对象实例赋值给一个变量;</li>\n</ol>\n<h4 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h4><ul>\n<li><p>为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">car1.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;black&quot;</span> <span class=\"hljs-comment\">//为car1新增color属性</span><br></code></pre></td></tr></table></figure>\n<p><br></p>\n</li>\n<li><p>添加共享属性到构造函数中的<code>prototype</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>car1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();<br>car2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-title class_\">Car</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;原色&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><br>car1.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;黑色&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;黑色&#x27;</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(car1).<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(car2).<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;黑色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car2.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的构造函数名为<code>Car</code>, 因此通过<code>Car.prototype</code>可以访问到构造函数的原型对象;</li>\n<li><code>getPrototypeOf</code> 表示获取对象的<strong>原型对象</strong>, 因此此处均为最初定义的 <strong>原色</strong>.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><p>函数通过<code>new.target</code>属性可以判断是否通过<code>new</code>关键字调用, 即构造.</p>\n<ul>\n<li>如果函数是正常调用, 则返回<code>undefined</code>;</li>\n<li><p>如果函数是通过<code>new</code>调用, 返回被调用的构造函数.</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span>) &#123;<br>    <span class=\"hljs-comment\">// 以函数的形式被调用。</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;color&#125;</span>车`</span>;<br>  &#125;<br>  <span class=\"hljs-comment\">// 通过 new 被调用。</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span> = color;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;红&quot;</span>); <span class=\"hljs-comment\">// a 是“红车”</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;红&quot;</span>); <span class=\"hljs-comment\">// b 是 `Car &#123; color: &quot;红&quot; &#125;`</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"对象类型与实例\"><a href=\"#对象类型与实例\" class=\"headerlink\" title=\"对象类型与实例\"></a>对象类型与实例</h4><p>$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">make, model, year</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">make</span> = make;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">model</span> = model;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>$\\underline{对象实例}$ 通过使用<code>new()</code>方法, 由对象类型构造一个对象实例:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myCar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;鹰牌&quot;</span>, <span class=\"hljs-string\">&quot;Talon TSi&quot;</span>, <span class=\"hljs-number\">1993</span>);<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"类与new\"><a href=\"#类与new\" class=\"headerlink\" title=\"类与new\"></a>类与new</h4><p>在JS当中, 类 <strong>必须</strong> 通过<code>new</code>调用.</p>\n<blockquote>\n<p>可以优先阅读<a href=\"#类\">类相关的知识</a></p>\n</blockquote>\n<ul>\n<li>e.g. <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-comment\">//构造函数</span><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br>  <span class=\"hljs-comment\">//实例方法</span><br>  <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`你好，我的名字是<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n对于上述的类, 必须使用如下的调用方式:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> animal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&quot;Dog&quot;</span>); <span class=\"hljs-comment\">// 正常</span><br></code></pre></td></tr></table></figure>\n而下面这样类似于普通函数的调用方式会抛出错误:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&quot;Cat&quot;</span>); <span class=\"hljs-comment\">// TypeError:  Class constructor Animal cannot be invoked without &#x27;new&#x27;</span><br></code></pre></td></tr></table></figure>\n<br></li>\n</ul>\n<p>在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">animal.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出 &quot;你好，我的名字是Dog&quot;</span><br></code></pre></td></tr></table></figure></p>\n<hr>\n<p>下面给出与普通函数的区别:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">model</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">model</span> = model;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;Toyota&quot;</span>); <span class=\"hljs-comment\">// 正常</span><br><span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;Honda&quot;</span>); <span class=\"hljs-comment\">// 不抛出错误，但 this 会指向全局对象.</span><br><span class=\"hljs-keyword\">const</span> anotherCar = <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;cat&quot;</span>); <span class=\"hljs-comment\">//此时全局对象下的model值为 &quot;cat&quot;, 覆盖了上一行的定义.</span><br></code></pre></td></tr></table></figure><br>总结:</p>\n<ul>\n<li>以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;</li>\n<li>如果以new方法构造得到对象实例, 依旧正常.</li>\n</ul>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"默认行为\"><a href=\"#默认行为\" class=\"headerlink\" title=\"默认行为\"></a>默认行为</h2><p>$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.</p>\n<ul>\n<li>比如存在以下的默认行为:<ul>\n<li>滚动事件：触摸屏上滑动手指，页面会滚动;</li>\n<li>拖拽文件到浏览器：浏览器会尝试加载文件;</li>\n<li>点击链接 <code>(&lt;a href=&quot;...&quot;&gt;)</code>：跳转到指定的 URL;</li>\n</ul>\n</li>\n</ul>\n<p>$\\underline{阻止默认行为}$ 使用 <code>event.preventDefault()</code> 方法可以阻止事件的默认行为.</p>\n<ul>\n<li><p>e.g: 阻止链接跳转</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>    event.<span class=\"hljs-title function_\">preventDefault</span>(); <span class=\"hljs-comment\">// 阻止点击链接时的默认行为</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;链接被点击，但没有跳转&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>通过阻止默认行为, 可以实现自定义逻辑.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ul>\n<li><code>this</code>可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;</li>\n<li><code>this</code> 指向的是<strong>当前函数的调用者</strong>，而不是函数内部定义的变量.</li>\n</ul>\n<p><br></p>\n<ul>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;b in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b in the function&quot;</span>; <span class=\"hljs-comment\">// 函数作用域</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span>); <span class=\"hljs-comment\">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class=\"hljs-title function_\">f</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处的<code>f</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"函数上下文中的this\"><a href=\"#函数上下文中的this\" class=\"headerlink\" title=\"函数上下文中的this\"></a>函数上下文中的this</h3><ul>\n<li><code>this</code>参数的值取决于函数<strong>如何</strong>被调用, 而不是函数如何被定义.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 对象可以作为第一个参数传递给 &#x27;call&#x27; 或 &#x27;apply&#x27;，</span><br><span class=\"hljs-comment\">// 并且 &#x27;this&#x27; 将被绑定到它。</span><br><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;Custom&quot;</span> &#125;;<br><br><span class=\"hljs-comment\">// 使用 var 声明的变量成为 &#x27;globalThis&#x27; 的属性。</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;Global&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">whatsThis</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// &#x27;this&#x27; 取决于函数如何被调用</span><br>&#125;<br><br><span class=\"hljs-title function_\">whatsThis</span>(); <span class=\"hljs-comment\">// &#x27;Global&#x27;; 在非严格模式下，&#x27;this&#x27; 参数默认为 &#x27;globalThis&#x27;</span><br>obj.<span class=\"hljs-property\">whatsThis</span> = whatsThis;<br>obj.<span class=\"hljs-title function_\">whatsThis</span>(); <span class=\"hljs-comment\">// &#x27;Custom&#x27;; &#x27;this&#x27; 参数被绑定到 obj</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>同样是调用函数<code>whatsThis()</code>, 但是<code>this</code>参数被绑定到不同的对象上, 导致返回值不同;</li>\n<li>在非严格模式下, <code>this</code>参数默认指向<code>globalThis</code>, 即全局对象;</li>\n<li>对于典型函数, <code>this</code>指向函数访问的对象;</li>\n</ol>\n<ul>\n<li><p>e.g. </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;b in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b in the function&quot;</span>; <span class=\"hljs-comment\">// 函数作用域</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span>); <span class=\"hljs-comment\">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class=\"hljs-title function_\">f</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处<code>f</code>作为<code>obj</code>对象的方法被调用, 因此普通函数的<code>this</code>指向<code>obj</code>.</p>\n</blockquote>\n</li>\n<li><p>e.g. 直接调用的普通函数<code>this</code>指向全局:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> funcA = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> &#125;; <span class=\"hljs-comment\">// 普通函数，this 由调用方式决定</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">funcA</span>()); <span class=\"hljs-comment\">// 访问 this.a</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br>obj.<span class=\"hljs-title function_\">f</span>(); <span class=\"hljs-comment\">// &quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的<code>funcA</code>并没有类似于作为对象的属性调用(<code>obj.funcA()</code>), 因此其<code>this</code>指向全局作用域(<code>window</code>), 输出<code>undefined</code>, 而是直接调用的形式, 因此其<code>this</code>指向全局作用域.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"对this传值\"><a href=\"#对this传值\" class=\"headerlink\" title=\"对this传值\"></a>对this传值</h3><p>使用<code>call()</code>以及<code>apply()</code>方法可以将<code>this</code>绑定到其他对象上.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h4><ul>\n<li>形式: <code>func.call(thisArg, arg1, arg2, ...)</code></li>\n<li>e.g:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">c, d</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> + c + d;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-comment\">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class=\"hljs-comment\">// 剩余的参数被绑定到命名参数。</span><br>add.<span class=\"hljs-title function_\">call</span>(o, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 16</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><ul>\n<li>形式: <code>func.apply(thisArg, [argsArray])</code></li>\n<li>e.g:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">c, d</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> + c + d;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-comment\">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class=\"hljs-comment\">// 第二个参数是一个数组，其成员被绑定到命名参数。</span><br>add.<span class=\"hljs-title function_\">apply</span>(o, [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>]); <span class=\"hljs-comment\">// 34</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h4><ul>\n<li>形式: <code>f.bind(someObject)</code>;</li>\n<li><strong>作用</strong>: <ul>\n<li>创建一个新的函数(需要重新赋值), 具有与<code>f</code>相同的函数体和作用域;</li>\n<li>新函数的<code>this</code>被 <strong>永久地</strong> 绑定到<code>someObject</code>, 不随调用方式的变化而变化.</li>\n</ul>\n</li>\n<li><strong>限制</strong>: <ul>\n<li><code>bind</code>无法多次生效. 即对函数f<code>bind</code>得到的g, 无法继续用<code>bind</code>得到期望的h;</li>\n</ul>\n</li>\n<li><p>e.g. 多次<code>bind</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> g = f.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;azerty&quot;</span> &#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> h = g.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;yoo&quot;</span> &#125;); <span class=\"hljs-comment\">// bind 只能生效一次！</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">37</span>, f, g, h &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(o.<span class=\"hljs-property\">a</span>, o.<span class=\"hljs-title function_\">f</span>(), o.<span class=\"hljs-title function_\">g</span>(), o.<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// 37 37 undefined undefined</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>由于<code>bind</code>只能对一个原始函数作用, 因此由f得到的g无法继续由<code>bind</code>绑定<code>this</code>得到期望的h, 此处h的<code>this</code>依旧是<code>&#123;b: &quot;azerty&quot;&#125;</code>, 因此在输出对象<code>a</code>时显示<code>undefined</code>;</li>\n<li><code>o.f()</code>的调用是普通函数的调用, 因此其<code>this</code>继承自对象<code>o</code>, 输出<code>37</code>;</li>\n</ul>\n</blockquote>\n</li>\n<li><p>e.g. 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> g = f.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;azerty&quot;</span> , <span class=\"hljs-attr\">c</span>:<span class=\"hljs-string\">&quot;ccc&quot;</span>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// &quot;undefined ccc&quot;</span><br><br><span class=\"hljs-keyword\">const</span> h = g.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;yoo&quot;</span> &#125;); <span class=\"hljs-comment\">// bind 只能生效一次！</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// &quot;undefined ccc&quot;</span><br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">37</span>, f, g, h &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(o.<span class=\"hljs-property\">a</span>, o.<span class=\"hljs-title function_\">f</span>(), o.<span class=\"hljs-title function_\">g</span>(), o.<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// 37 37 azerty azerty</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>bind</code>绑定的<code>this</code>是永久覆盖, 而非简单叠加;</li>\n<li>由于<code>bind</code>绑定的<code>this</code>不随者调用方式的变化而变化, 因此即使处于对象<code>o</code>当中, <code>g</code>,<code>h</code>依旧不会输出<code>o</code>中的<code>a</code>.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。</p>\n<p>普通函数:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br> <span class=\"hljs-attr\">f</span>: foo<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>()); <span class=\"hljs-comment\">// &quot;a in the obj&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p><code>call()</code>、 <code>apply()</code>、 <code>bind()</code> 无法改变箭头函数的<code>this</code>(但是call与apply的其他参数可以正常传递:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">foo</span> = (<span class=\"hljs-params\"></span>)=&gt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br> <span class=\"hljs-attr\">f</span>: foo.<span class=\"hljs-title function_\">bind</span>(&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-string\">&quot;a in the bind&quot;</span>&#125;) <span class=\"hljs-comment\">// 显式绑定 this 到 obj, 但是无法生效</span><br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>()); <span class=\"hljs-comment\">// undefined</span><br><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>换成普通函数则输出<code>a in the obj</code>.</p>\n</blockquote>\n<ul>\n<li>全局作用域<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">foo1</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>\t<span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>\t<span class=\"hljs-attr\">f</span>: <span class=\"hljs-function\">()=&gt;</span> a<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n<li>块级作用域: 由<code>let</code>或<code>const</code>声明的变量的作用域.(对于<code>var</code>无效);</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// 1</span><br><br>&#123;<br>  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>Notices:</p>\n<ul>\n<li>对象本身并不会创建作用域, 只是一个键值对的集合;</li>\n<li>箭头函数也不会创建自己的作用域, 而是 <strong>继承</strong> 外层作用域中的<code>this</code>;</li>\n</ul>\n<h3 id=\"变量与作用域\"><a href=\"#变量与作用域\" class=\"headerlink\" title=\"变量与作用域\"></a>变量与作用域</h3><ul>\n<li><code>var</code>在全局作用域中声明时会成为 <strong>全局对象</strong> (<code>window</code>或<code>global</code>)的属性;</li>\n<li><code>let</code>和<code>const</code>即使在全局作用域中声明, 也不会成为全局对象的属性;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;1&quot;</span>;<br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-string\">&quot;2&quot;</span>;<br><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// &quot;1&quot;</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">b</span>; <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>因此, 建议在全局作用域中不要使用<code>var</code>声明变量, 而使用<code>let</code>或<code>const</code>声明变量. 从而避免导致意外的覆盖和冲突.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"函数与作用域\"><a href=\"#函数与作用域\" class=\"headerlink\" title=\"函数与作用域\"></a>函数与作用域</h3><h4 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h4><p>普通函数和匿名函数的作用域继承自其定义时的作用域.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">insideObj</span>: &#123;<br>        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// 普通函数，this 动态绑定到 insideObj</span><br>        &#125;<br>    &#125;,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// 普通函数，this 动态绑定到 obj</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());        <span class=\"hljs-comment\">// &quot;a in the obj&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">insideObj</span>.<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// undefined，因为 insideObj 中没有 a</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>e.g. <strong>箭头函数继承外层作用域</strong>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">insideObj</span>: &#123;<br>        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span><br>    &#125;,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span><br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());        <span class=\"hljs-comment\">// &quot;a in the global&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">insideObj</span>.<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">//&quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure><br>由于对象不会创建作用域, 因此此处的箭头函数的<code>this</code>继承了外层作用域(window)的<code>this</code>, 且<code>var</code>创建的变量存在于全局作用域中.</p>\n<h2 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h2><p>$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.</p>\n<ul>\n<li>本质上没有增加语言的功能, 而是对已有功能的 <strong>包装</strong> 或者优化;</li>\n<li><strong>可读性提升</strong>: <del>让代码更填</del> 使得代码更加容易理解和书写;</li>\n<li><strong>底层实现</strong>: 实质上依旧用基础的语法实现.</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类 <code>class</code> 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承<code>prototype</code>的封装.</p>\n<p>使用<code>class</code>的写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>);<br>person.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p>\n<p>等价的原型写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">greet</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>);<br>person.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数-2\"><a href=\"#箭头函数-2\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.</p>\n<ul>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 使用箭头函数</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; a + b;<br><br><span class=\"hljs-comment\">// 等价的普通函数</span><br><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h3><p>$\\underline{结构赋值}$ 手动提取<strong>对象</strong>属性的语法糖.</p>\n<ul>\n<li><p>使用结构赋值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;Zhuo&quot;</span>, <span class=\"hljs-attr\">gender</span>:<span class=\"hljs-string\">&quot;male&quot;</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> &#123;name, gender&#125; = person;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>等价的原型写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;Zhuo&quot;</span>, <span class=\"hljs-attr\">gender</span>:<span class=\"hljs-string\">&quot;male&quot;</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> name = person.<span class=\"hljs-property\">name</span>;<br><span class=\"hljs-keyword\">const</span> gender = person.<span class=\"hljs-property\">gender</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"赋值规则\"><a href=\"#赋值规则\" class=\"headerlink\" title=\"赋值规则\"></a>赋值规则</h4><p>结构赋值时, 基于 <strong>属性名匹配</strong> 而非顺序.<br>因此, 对象结构的<code>&#123;&#125;</code>内部属性必须和 <strong>对象的属性名</strong> 相对应.</p>\n<p><strong>错误</strong>的示例:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; a, b &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：undefined</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：undefined</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>重命名属性</strong>的写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">name</span>: a, <span class=\"hljs-attr\">age</span>: b &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：25</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>手动赋值</strong>: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; name, age = <span class=\"hljs-number\">30</span> &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age);  <span class=\"hljs-comment\">// 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"数组的结构赋值\"><a href=\"#数组的结构赋值\" class=\"headerlink\" title=\"数组的结构赋值\"></a>数组的结构赋值</h4><p>上述讨论的结构赋值都是对 <strong>对象</strong> 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— <strong>基于顺序</strong>赋值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-number\">25</span>];<br><span class=\"hljs-keyword\">const</span> [a, b] = arr;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：25</span><br></code></pre></td></tr></table></figure></p>\n","more":"<blockquote>\n<p>JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「<strong>料理的加护</strong>」下, 尽可能将JS处理得更加<strong>可口</strong>一些)<br><img src=\"/img/料理的加护.jpg\" width = \"35%\"></p>\n</blockquote>\n<h1 id=\"创建JS代码块\"><a href=\"#创建JS代码块\" class=\"headerlink\" title=\"创建JS代码块\"></a>创建JS代码块</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-or-let\"><a href=\"#var-or-let\" class=\"headerlink\" title=\"var or let?\"></a><code>var</code> or <code>let</code>?</h3><p><code>var</code>先于<code>let</code>的产生, 后者是现代版本的JS中新的关键字.</p>\n<p>使用<code>var</code>, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是<code>let</code>并不适用.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logName</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myName);<br>&#125;<br><br><span class=\"hljs-title function_\">logName</span>(); <span class=\"hljs-comment\">//输出&quot;Chris&quot;</span><br><br><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Aniya&quot;</span>;<br><span class=\"hljs-title function_\">logName</span>(); <span class=\"hljs-comment\">//输出&quot;Aniya&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p>除此之外, 可以使用<code>var</code>前后声明相同的变量, 这并不会报错:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br><span class=\"hljs-keyword\">var</span> myName = <span class=\"hljs-string\">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p>\n<p>而<code>let</code>只能声明一次:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&quot;Chris&quot;</span>;<br>myName = <span class=\"hljs-string\">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p>\n<p>因此, 在代码编写中应尽量<strong>多使用</strong><code>let</code>而非<code>var</code>, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.</p>\n<h3 id=\"变量命名的规则\"><a href=\"#变量命名的规则\" class=\"headerlink\" title=\"变量命名的规则\"></a>变量命名的规则</h3><p>与C语言类似, 建议以 <strong>字母、数字、下划线</strong> 组成的标识符来命名变量.</p>\n<ul>\n<li>不可用<code>_</code>开头, 因为可能被JS设计为特殊的含义;</li>\n<li>不可用数字开头, 否则引发错误;</li>\n<li>大小写敏感;</li>\n<li>建议采用 <strong>小写驼峰命名法</strong> ,即小写整个命名的第一个字母然后大写剩下单词的首字符;</li>\n<li>避免使用保留字, 比如<code>var</code>,<code>let</code>,<code>for</code>等.</li>\n</ul>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myAge = <span class=\"hljs-number\">20</span> ;<span class=\"hljs-comment\">// 数字</span><br><span class=\"hljs-keyword\">let</span> dolphinGoodbye = <span class=\"hljs-string\">&quot;So long and thanks for all the fish&quot;</span>; <span class=\"hljs-comment\">// 字符串</span><br><span class=\"hljs-keyword\">let</span> test = <span class=\"hljs-number\">6</span> &lt; <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">//boolean</span><br><br><span class=\"hljs-comment\">//数组类型</span><br><span class=\"hljs-keyword\">let</span> myNameArray = [<span class=\"hljs-string\">&quot;Chris&quot;</span>, <span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-string\">&quot;Jim&quot;</span>];<br><span class=\"hljs-keyword\">let</span> myNumberArray = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">40</span>];<br><br><span class=\"hljs-comment\">//对象类型</span><br><span class=\"hljs-keyword\">let</span> dog = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Spot&quot;</span>, <span class=\"hljs-attr\">breed</span>: <span class=\"hljs-string\">&quot;Dalmatian&quot;</span> &#125;;<br><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>对象类型的访问与结构体相似, <code>dog.name;</code></p>\n</blockquote>\n<p>在上面的几种变量类型中, 我们都采用<code>let</code>关键字声明变量, 这体现了JS是一种 <strong>动态类型语言</strong> ,即无需指定变量包含的数据类型.</p>\n<p>同时, 这也意味着我们可以像<code>python</code>一样对同一个变量先后赋值不同类型的值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myNumber = <span class=\"hljs-string\">&quot;500&quot;</span>;<br><span class=\"hljs-keyword\">typeof</span> myNumber;<br><span class=\"hljs-comment\">// 输出 &#x27;string&#x27;</span><br><br>myNumber = <span class=\"hljs-number\">500</span>; <br><span class=\"hljs-keyword\">typeof</span> myNumber;<br><span class=\"hljs-comment\">//输出&#x27;number&#x27;</span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li>$\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">exampleFunction</span>();<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">exampleFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;函数内&quot;</span>);<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>由于 <strong>提升</strong> 的存在, 上述的函数调用不会出错.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在编写函数时, 可以通过在参数名称后添加<code>=</code>, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">greeding</span>(<span class=\"hljs-params\">name = <span class=\"hljs-string\">&quot;my friend&quot;</span></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><span class=\"hljs-title function_\">hello</span>(); <span class=\"hljs-comment\">//Hello, my friend!</span><br><span class=\"hljs-title function_\">hello</span>(<span class=\"hljs-string\">&quot;world&quot;</span>); <span class=\"hljs-comment\">//Hello, world!</span><br></code></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>事件处理函数的默认接受值是<code>event</code>:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span><br>onclick<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><br>nothing here<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;button&quot;</span>)</span><br><span class=\"language-javascript\">para = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;p&quot;</span>)</span><br><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">btn.<span class=\"hljs-property\">onclick</span> = click;</span><br><span class=\"language-javascript\"></span><br><span class=\"language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">click</span>(<span class=\"hljs-params\">string</span>)&#123;</span><br><span class=\"language-javascript\">  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;clicked!&quot;</span>)</span><br><span class=\"language-javascript\">  para.<span class=\"hljs-property\">textContent</span> = string;</span><br><span class=\"language-javascript\">&#125;</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<ol>\n<li>上述的<code>btn</code>在点击之后调用函数<code>click</code>, 该函数需要一个参数<code>string</code>, 由于<code>btn.onclick = click;</code>的绑定方式, 我们无法指定传参的值, 因此点击之后的<code>para</code>的内容显示为: <code>[object PointerEvent]</code>;</li>\n<li><code>textContent</code>是属性而非方法, 因此采用赋值实现;</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">btn.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">click</span>(<span class=\"hljs-params\">string</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;clicked!&quot;</span>)<br>  para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;You have clicked the button!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>将上述的绑定方式如此改写, 可以在<code>btn</code>外对<code>string</code>进行赋值, 然后点击按钮可以传入指定参数供后续处理.</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFunction</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 匿名函数</span><br>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;你好&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.</p>\n</blockquote>\n<p>如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logKey</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;<br><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, logKey);<br></code></pre></td></tr></table></figure><br>这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.</p>\n</blockquote>\n<p>而<strong>箭头函数</strong>则是在此情况下更简洁的函数定义方式:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br><br><span class=\"hljs-comment\">//如果函数只接受一个参数, 也可以省略参数周围的括号</span><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<p>如果只包含一行的<code>return</code>,则可以忽略<code>&#123;&#125;</code>和<code>return</code>关键字:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> originals = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-keyword\">const</span> doubled = originals.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item * <span class=\"hljs-number\">2</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(doubled); <span class=\"hljs-comment\">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>item =&gt; item * 2</code>等价于:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">doubleItem</span>(<span class=\"hljs-params\">item</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> item * <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"一个实例\"><a href=\"#一个实例\" class=\"headerlink\" title=\"一个实例\"></a>一个实例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;textBox&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;output&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> textBox = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#textBox&quot;</span>);<br><span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;#output&quot;</span>);<br><br>textBox.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;keydown&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =&gt;</span> &#123;<br>  output.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">`You pressed &quot;<span class=\"hljs-subst\">$&#123;event.key&#125;</span>&quot;.`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>通过监听输入框的keydown事件, 输出按下的键盘按键.</p>\n<h3 id=\"函数作用域和冲突\"><a href=\"#函数作用域和冲突\" class=\"headerlink\" title=\"函数作用域和冲突\"></a>函数作用域和冲突</h3><p>$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n</ul>\n<p>和C语言相似, 在函数外部<code>let</code>定义的变量, 以及<code>const</code>定义的常量可以在函数内部访问.</p>\n<p>如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Excerpt from my HTML --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;first.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;second.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><br>  greeting();<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果两个JS文件都定义了<code>greeting</code>函数, 则只有第一个文件中的函数才会被调用.</p>\n</blockquote>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数字和操作符\"><a href=\"#数字和操作符\" class=\"headerlink\" title=\"数字和操作符\"></a>数字和操作符</h3><p>大部分与C语言相同, 概括需要注意的差异:</p>\n<ul>\n<li>JS当中只有一种数字类型 — <code>number</code>, 对于整型或者浮点数的初始化得到的量, 由<code>typeof</code>均得到<code>number</code>;</li>\n<li>算术运算符: 求幂为<code>**</code>;</li>\n<li>常量无法使用自增或自减,<del>好像也是C语言的 忘了</del></li>\n<li><code>===</code>表示严格等于, <code>!==</code>表示不等于;<blockquote>\n<p>同时存在<code>==</code>和<code>!=</code>来判断是否相等, 但是它们只是测试 <strong>值</strong> 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用<code>===</code>和<code>!==</code>来避免类型不一致的错误.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>创建字符串<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myString = <span class=\"hljs-string\">&quot;A string&quot;</span>;<br><span class=\"hljs-keyword\">const</span> constString = myString;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(constString);<br><span class=\"hljs-comment\">//A string</span><br></code></pre></td></tr></table></figure><br>可以使用单引号,双引号和<strong>反引号</strong>来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> single = <span class=\"hljs-string\">&#x27;单引号&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> double = <span class=\"hljs-string\">&quot;双引号&quot;</span>;<br><span class=\"hljs-keyword\">const</span> backtick = <span class=\"hljs-string\">`反引号`</span>;<br></code></pre></td></tr></table></figure></p>\n<p>反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:</p>\n<ul>\n<li>可以嵌入 <strong>JavaScript</strong>;</li>\n<li>可以声明<strong>多行</strong>的模板字面量.</li>\n</ul>\n<h4 id=\"字符串的拼接\"><a href=\"#字符串的拼接\" class=\"headerlink\" title=\"字符串的拼接\"></a>字符串的拼接</h4><p>字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;克里斯&quot;</span>;<br><span class=\"hljs-keyword\">const</span> greeting = <span class=\"hljs-string\">`你好，<span class=\"hljs-subst\">$&#123;name&#125;</span>`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting); <span class=\"hljs-comment\">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在模板字面量中用<code>$&#123;&#125;</code>包装JS的变量或者表达式.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> one = <span class=\"hljs-string\">&quot;你好，&quot;</span>;<br><span class=\"hljs-keyword\">const</span> two = <span class=\"hljs-string\">&quot;请问最近如何？&quot;</span>;<br><span class=\"hljs-keyword\">const</span> joined = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;one&#125;</span><span class=\"hljs-subst\">$&#123;two&#125;</span>`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(joined); <span class=\"hljs-comment\">// &quot;你好，请问最近如何？&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>连接2个变量.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> song = <span class=\"hljs-string\">&quot;青花瓷&quot;</span>;<br><span class=\"hljs-keyword\">const</span> score = <span class=\"hljs-number\">9</span>;<br><span class=\"hljs-keyword\">const</span> highestScore = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-string\">`我喜欢歌曲《<span class=\"hljs-subst\">$&#123;song&#125;</span>》。我给它打了 <span class=\"hljs-subst\">$&#123;</span></span><br><span class=\"hljs-subst\"><span class=\"hljs-string\">  (score / highestScore) * <span class=\"hljs-number\">100</span></span></span><br><span class=\"hljs-subst\"><span class=\"hljs-string\">&#125;</span> 分。`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(output); <span class=\"hljs-comment\">// &quot;我喜欢歌曲《青花瓷》。我给它打了 90 分。&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>在模板字面量的<code>$&#123;&#125;</code>内部包含表达式.</p>\n</blockquote>\n<p><br><br>除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用<code>+</code>直接连接:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> greeting = <span class=\"hljs-string\">&quot;你好&quot;</span>;<br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;克里斯&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(greeting + <span class=\"hljs-string\">&quot;，&quot;</span> + name); <span class=\"hljs-comment\">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h4><p>模板字符串会<strong>保留</strong>源代码中的换行符，因此可以编写跨越多行的字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> newline = <span class=\"hljs-string\">`终于有一天，</span><br><span class=\"hljs-string\">你知道了必须做的事情，而且开始……`</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newline);<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">终于有一天，</span><br><span class=\"hljs-comment\">你知道了必须做的事情，而且开始……</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure></p>\n<p>如果希望用普通的字符串得到等效的输出, 必须在字符串中包含<code>\\n</code>,而非直接跨行:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> newline = <span class=\"hljs-string\">&quot;终于有一天，\\n你知道了必须做的事情，而且开始……&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newline);<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">终于有一天，</span><br><span class=\"hljs-comment\">你知道了必须做的事情，而且开始……</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"显示引号\"><a href=\"#显示引号\" class=\"headerlink\" title=\"显示引号\"></a>显示引号</h4><ol>\n<li>$\\underline{转义}$  通过在符号前加上反斜杠<code>\\</code>, 可以转义字符串中的特殊字符,包括字符串中的引号:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> bigmouth = <span class=\"hljs-string\">&#x27;I\\&#x27;ve got no right to take my place…&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>换用其他字符: 在字面量内用不同于包裹字符串的引号:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> goodQuotes1 = <span class=\"hljs-string\">&#x27;She said &quot;I think so!&quot;&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> goodQuotes2 = <span class=\"hljs-string\">`She said &quot;I&#x27;m not going in there!&quot;`</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p>对于字符串对象实例,其常用的方法:</p>\n<ul>\n<li><code>.length</code>: 获取字符串的长度;</li>\n<li><code>[]</code>: 返回字符串中对应索引的字符, 索引同样从<code>0</code>开始;</li>\n<li><code>.indexOf(&quot;&quot;)</code>: 查找子字符串<ul>\n<li><strong>input</strong>: 希望查找的子字符串;</li>\n<li><strong>output</strong>: 子字符串开始的下标(如果不存在则返回<code>-1</code>);</li>\n</ul>\n</li>\n<li><code>.slice(indedxStart, indexEnd)</code>: 截取字符串<ul>\n<li><strong>input</strong>: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;</li>\n<li><strong>output</strong>: 截取的子字符串;</li>\n</ul>\n</li>\n</ul>\n<p>更多的<code>slice</code>知识:</p>\n<ol>\n<li>$\\underline{标准化负值}$ 如果索引是个负数, 取<code>index+str.length</code>进行标准化;</li>\n<li>如果<code>indexStart</code>大于<code>str.length</code>, 返回空字符串;</li>\n<li>如果标准化负值之后, <code>indexStart</code>大于<code>indexEnd</code>, 也返回空字符串;</li>\n</ol>\n<ul>\n<li><code>.toLowerCase()</code> &amp; <code>.toUpperCase()</code>: 转换字符串中的所有字符为小写或大写;</li>\n<li><code>.replace(original, new)</code>: 替换字符串中<code>original</code>子字符串为<code>new</code>;<blockquote>\n<p>此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cases\"><a href=\"#Cases\" class=\"headerlink\" title=\"Cases\"></a>Cases</h4><p>利用 <strong>indexOf</strong> 和 <strong>slice</strong> 方法, 获取新字符串:</p>\n<ul>\n<li><strong>input</strong>: <code>&quot;str3&quot;</code>三位长字符串+<code>&quot;...&quot;</code>(无关字符串)+<code>&quot;;&quot;</code>+<code>strLast</code>(剩余字符串);</li>\n<li><strong>output</strong>: <code>&quot;str3&quot;+&quot;;&quot;+strLast</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> stations = [<span class=\"hljs-string\">&#x27;MAN675847583748sjt567654;Manchester Piccadilly&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;GNF576746573fhdg4737dh4;Greenfield&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;LIV5hg65hd737456236dch46dg4;Liverpool Lime Street&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;SYB4f65hf75f736463;Stalybridge&#x27;</span>,<br>                <span class=\"hljs-string\">&#x27;HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; stations.<span class=\"hljs-property\">length</span>; i++)&#123;<br>    <span class=\"hljs-keyword\">var</span> input = stations[i];<br>    <span class=\"hljs-keyword\">var</span> str3 = input.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>);<br>    <span class=\"hljs-keyword\">var</span> strLast = input.<span class=\"hljs-title function_\">slice</span>(input.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">&quot;;&quot;</span>)+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//indexOf获取;位置</span><br>    <span class=\"hljs-keyword\">var</span> output = str3 + <span class=\"hljs-string\">&quot;;&quot;</span> + strLast;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p>通过 <strong>indexOf</strong> 根据子字符串筛选字符串数组:</p>\n<ul>\n<li><strong>input</strong>: 可能包含 <em>Christmas</em> 的字符串数组;</li>\n<li><strong>output</strong>: 包含 <em>Christmas</em> 的字符串数组;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> list = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.output ul&#x27;</span>);<br>list.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> greetings = [<span class=\"hljs-string\">&#x27;Happy Birthday!&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;Merry Christmas my love&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;A happy Christmas to all the family&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;You\\&#x27;re all I want for Christmas&#x27;</span>,<br>                 <span class=\"hljs-string\">&#x27;Get well soon&#x27;</span>];<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; greetings.<span class=\"hljs-property\">length</span>; i++) &#123;<br>  <span class=\"hljs-keyword\">var</span> input = greetings[i];<br>  <span class=\"hljs-keyword\">if</span>(greetings[i].<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">&#x27;Christmas&#x27;</span>) !== -<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = input;<br>    <span class=\"hljs-keyword\">var</span> listItem = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);<br>    listItem.<span class=\"hljs-property\">textContent</span> = result;<br>    list.<span class=\"hljs-title function_\">appendChild</span>(listItem);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><h4 id=\"相互转换\"><a href=\"#相互转换\" class=\"headerlink\" title=\"相互转换\"></a>相互转换</h4><p>非常神奇, 在JS当中, 数字和字符串可以直接通过函数<code>Number()</code>和<code>String()</code>进行转换, 与C语言不同.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myString = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-keyword\">const</span> myNum = <span class=\"hljs-title class_\">Number</span>(myString);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> myNum);<br><span class=\"hljs-comment\">// number</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myNum);<br><span class=\"hljs-comment\">// 123</span><br></code></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myNum2 = <span class=\"hljs-number\">123</span>;<br><span class=\"hljs-keyword\">const</span> myString2 = <span class=\"hljs-title class_\">String</span>(myNum2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> myString2);<br><span class=\"hljs-comment\">// string</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myString2);<br><span class=\"hljs-comment\">// &quot;123&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>对于浮点数同样成立.</p>\n</blockquote>\n<h4 id=\"前后拼接\"><a href=\"#前后拼接\" class=\"headerlink\" title=\"前后拼接\"></a>前后拼接</h4><p>使用<code>+</code>将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;Front &quot;</span>;<br><span class=\"hljs-keyword\">const</span> number = <span class=\"hljs-number\">242</span>;<br><span class=\"hljs-keyword\">const</span> combine = name + number;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(combine); <span class=\"hljs-comment\">//Front 242</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">typeof</span>(combine));  <span class=\"hljs-comment\">//string</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>存储任意类型元素—字符串，数字，对象，变量，<strong>另一个数组</strong>;</li>\n<li>可以 <strong>混合</strong> 元素类型:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> random = [<span class=\"hljs-string\">&quot;tree&quot;</span>, <span class=\"hljs-number\">795</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]];<br></code></pre></td></tr></table></figure></li>\n<li>像访问字符串一样, 利用索引访问数组元素;</li>\n<li>$\\underline{多维数组}$ 包含数组的数组结构称为~</li>\n</ol>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>作用: 将一个字符串根据给定的字符分隔为字符串数组;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myData = <span class=\"hljs-string\">&quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;</span>;<br><span class=\"hljs-keyword\">let</span> myArray = myData.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;,&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray);<br> <span class=\"hljs-comment\">// [&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;]</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h4><p><code>split</code>的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myNewString = myArray.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;,&quot;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>与<code>join</code>方法相似, 但是无法自定义分隔符, 默认为<code>,</code>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> dogNames = [<span class=\"hljs-string\">&quot;Rocket&quot;</span>, <span class=\"hljs-string\">&quot;Flash&quot;</span>, <span class=\"hljs-string\">&quot;Bella&quot;</span>, <span class=\"hljs-string\">&quot;Slugger&quot;</span>];<br>dogNames.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">//Rocket,Flash,Bella,Slugger</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"push-amp-pop\"><a href=\"#push-amp-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h4><p><code>push()</code>方法可以将1或多个元素添加到数组的 <strong>末尾</strong>:</p>\n<ol>\n<li>将会直接改写原来的数组,不需要重新赋值;</li>\n<li>该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> myArray = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">let</span> newLength = myArray.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>,<span class=\"hljs-string\">&quot;string&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, &quot;string&quot;]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(newLength); <span class=\"hljs-comment\">// 6</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>使用<code>.pop()</code>从数组中删除最后一个元素:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">myArray.<span class=\"hljs-title function_\">pop</span>(); <span class=\"hljs-comment\">//&quot;string&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myArray); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p>\n<ol>\n<li>方法调用返回值就是删除的元素本身;</li>\n<li>直接对原始数组操作并赋值, 不需要另外的赋值操作;</li>\n</ol>\n<blockquote>\n<p>shift &amp; unshift:<br>在功能上分别与<code>push</code>和<code>pop</code>相同, 但是作用于数组的开始位置.</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:</p>\n<h3 id=\"天气预报\"><a href=\"#天气预报\" class=\"headerlink\" title=\"天气预报\"></a>天气预报</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;weather&quot;</span>&gt;</span>选择今天的天气：&lt;/label<br>&gt;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;weather&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>--作出选择--<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;sunny&quot;</span>&gt;</span>晴天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;rainy&quot;</span>&gt;</span>雨天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;snowing&quot;</span>&gt;</span>雪天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;overcast&quot;</span>&gt;</span>阴天<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>lable</code>当中的<code>for</code>标签与<code>select</code>标签的<code>id</code>属性对应, 用于关联两个标签.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> select = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;select&quot;</span>);<br><span class=\"hljs-keyword\">const</span> para = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;p&quot;</span>);<br><br>select.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;change&quot;</span>, setWeather);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setWeather</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> choice = select.<span class=\"hljs-property\">value</span>;<br><br>  <span class=\"hljs-keyword\">switch</span> (choice) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;sunny&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;rainy&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;snowing&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> =<br>        <span class=\"hljs-string\">&quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;overcast&quot;</span>:<br>      para.<span class=\"hljs-property\">textContent</span> =<br>        <span class=\"hljs-string\">&quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;</span>;<br>      <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-attr\">default</span>:<br>      para.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-string\">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>通过<code>querySelector</code>方法获取<code>select</code>和<code>p</code>标签;</li>\n<li>然后为<code>select</code>标签添加事件监听器, 当内容改变时触发 <strong>change</strong> 事件, 同时调用<code>setWeather</code>函数;</li>\n<li>进而通过 <strong>switch</strong> 语句处理不同天气的情况, 并设置相应的文字内容;<br>在线网页示例:<a href=\"https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html\">simple-switch</a></li>\n</ol>\n</blockquote>\n<h2 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h2><p>什么是$\\underline{事件}$? </p>\n<ul>\n<li>用户选择、点击或者光标悬停在某一元素;</li>\n<li>用户在键盘中按下某个按键;</li>\n<li>网页结束加载;</li>\n<li>…</li>\n</ul>\n<p>$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.</p>\n<h3 id=\"处理点击事件\"><a href=\"#处理点击事件\" class=\"headerlink\" title=\"处理点击事件\"></a>处理点击事件</h3><p>以点击事件为例, 介绍html与js如何进行事件处理的交互:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span> 改变颜色 <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br></code></pre></td></tr></table></figure><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;button&quot;</span>);<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">random</span>(<span class=\"hljs-params\">number</span>)&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>()*(number+<span class=\"hljs-number\">1</span>));<br>  <br>&#125;<br><br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, <span class=\"hljs-function\">()=&gt;</span>&#123;<br>  <span class=\"hljs-keyword\">const</span> rndCol = <span class=\"hljs-string\">`rgb(<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>,<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>,<span class=\"hljs-subst\">$&#123;random(<span class=\"hljs-number\">255</span>)&#125;</span>)`</span>;<br>  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = rndCol;<br>&#125;)<br></code></pre></td></tr></table></figure></p>\n<ol>\n<li><code>Math.random()</code>方法生成一个介于[0,1)之间的随机数;</li>\n<li><code>*(number+1)</code>之后利用向下取整的方法<code>Math.floor()</code>将其转换为整数, 范围为[0,number];<blockquote>\n<p>假如输入的number为<code>4</code>, 则<code>random(4)</code>的结果可能为<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>中的一个;<br>假设输入的number为<code>3.6</code>, 则输出的结果还是0~4中的整数.</p>\n</blockquote>\n</li>\n<li><code>rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;,$&#123;random(255)&#125;)</code> 采用的是在$\\underline{模板字符串}$内部使用<code>$&#123;&#125;</code>调用函数变量的方法.</li>\n</ol>\n<h3 id=\"addEventListener\"><a href=\"#addEventListener\" class=\"headerlink\" title=\"addEventListener()\"></a>addEventListener()</h3><p><code>adEventListener</code>方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.</p>\n<p>通过<code>EventTarget.adddEventListener()</code>的方法, 将指定的监听器注册到对象上, 具体的语法如下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">addEventListener</span>(type, listener);<br><span class=\"hljs-title function_\">addEventListener</span>(type, listener, options);<br><span class=\"hljs-title function_\">addEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>type</code>: 事件类型, 如<code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>等;</li>\n<li><code>listener</code>: 事件处理函数, 该函数将在事件发生时被调用;<ul>\n<li>包括 <strong>回调函数</strong> 以及 实现了 <strong>EventListener 接口的对象</strong>;</li>\n</ul>\n</li>\n<li><code>options</code>: 可选参数, 用于配置事件监听器的行为;<blockquote>\n<p>可以为单个事件添加多个事件监听器.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"listener\"><a href=\"#listener\" class=\"headerlink\" title=\"listener\"></a>listener</h4><p>$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.</p>\n<ul>\n<li>是一个函数, 但是只有等到特定的事件发生时才会执行.</li>\n</ul>\n<p>实现了 EventListener 接口的对象:</p>\n<ul>\n<li><strong>特点</strong>: 以对象作为listener, 对象中具有名为<code>handleEvent()</code>的方法;</li>\n<li><strong>作用</strong>: <ul>\n<li>将事件处理封装到一个对象当中, 可以更好地组织代码;</li>\n<li>便于在对象中保存更多的状态信息;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> listenerObject = &#123;<br>    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-title function_\">handleEvent</span>(<span class=\"hljs-params\">event</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>++;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`事件类型是：<span class=\"hljs-subst\">$&#123;event.type&#125;</span>，已触发 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.count&#125;</span> 次`</span>);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>button.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, listenerObject);<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>一个指定有关 listener 属性的可选参数对象.</p>\n<h5 id=\"Capture\"><a href=\"#Capture\" class=\"headerlink\" title=\"Capture\"></a>Capture</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;</li>\n<li>默认为false, 表示只有在冒泡阶段才触发.</li>\n</ul>\n</li>\n<li><p>区别:</p>\n<ul>\n<li><code>capture</code>和<code>useCapture</code>实际上指的都是 <strong>监听器是否在捕获阶段触发</strong> 的布尔值.<blockquote>\n<p>捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.</p>\n</blockquote>\n</li>\n<li>后来DOM的规范更新时引入了<code>options</code>参数, 此后<code>capture</code>取代了<code>useCapture</code>的作用.</li>\n<li>如果<code>addEventListener</code>的第三个参数不指定对象, 只有布尔值, 那么默认是在设置<code>useCapture</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可以先查看<a href=\"#事件传播的阶段\">事件传播的阶段</a>来辅助理解不同的阶段.</p>\n</blockquote>\n<h5 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h5><ul>\n<li>含义:<ul>\n<li>一个布尔值，表示 listener 在添加之后最多只调用一次;</li>\n<li>默认为false, 表示可以多次调用.</li>\n</ul>\n</li>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">child.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">once</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>once</code>属性被设置为<code>true</code>, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Passive\"><a href=\"#Passive\" class=\"headerlink\" title=\"Passive\"></a>Passive</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();</li>\n</ul>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>明确不会在<code>listener</code>中不会调用<code>preventDefault()</code>方法, 即不会阻止浏览器的<a href=\"#默认行为\">默认行为</a>;</li>\n<li>此时, 浏览器可以直接渲染默认行为的结果, 无需等待<code>listener</code>的执行与默认行为的检查, 从而提高了性能.</li>\n</ul>\n</li>\n<li>Notice:<ul>\n<li>如果设置<code>passive</code>为<code>true</code>, 则<code>listener</code>当中不可出现<code>preventDefault()</code>方法, 否则会报错.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>\tevent.<span class=\"hljs-title function_\">preventDefault</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">false</span>&#125;);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>wheel</code>事件的默认行为是滚动页面;</li>\n<li><code>event.preventDefault();</code>表示会阻止鼠标滚动带来的页面滚动;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;wheel&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>  event.<span class=\"hljs-title function_\">preventDefault</span>();<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>passive</code>的设置与<code>listener</code>内部矛盾, 将会报错.</p>\n</blockquote>\n<h5 id=\"Signal\"><a href=\"#Signal\" class=\"headerlink\" title=\"Signal\"></a>Signal</h5><p>用于有条件地移除事件监听器, 具体使用参见<a href=\"#可被移除的监听器\">可被移除的监听器</a>.</p>\n<h3 id=\"事件传播的阶段\"><a href=\"#事件传播的阶段\" class=\"headerlink\" title=\"事件传播的阶段\"></a>事件传播的阶段</h3><ol>\n<li>捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;<blockquote>\n<p>e.g. 点击事件从document开始传播, 经过html,body直到目标元素.</p>\n</blockquote>\n</li>\n<li>目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;</li>\n<li>冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.</li>\n</ol>\n<h4 id=\"Case\"><a href=\"#Case\" class=\"headerlink\" title=\"Case\"></a>Case</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;parent&quot;</span>&gt;</span><br>  parent<br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;child&quot;</span>&gt;</span>child<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> parent = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#parent&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#child&#x27;</span>);<br><br>parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 冒泡阶段&#x27;</span>);<br>&#125;);<br><br>parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>&#125;, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;);<br><br>child.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>上述的<code>child</code>被包裹在<code>parent</code>内部.</p>\n<ul>\n<li><p>当点击<code>parent</code>时将会显示:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-string\">&quot;父元素 - 捕获阶段&quot;</span><br><span class=\"hljs-string\">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;</p>\n</blockquote>\n</li>\n<li><p>当点击<code>child</code>时将会显示:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-string\">&quot;父元素 - 捕获阶段&quot;</span><br><span class=\"hljs-string\">&quot;子元素 - 目标阶段&quot;</span><br><span class=\"hljs-string\">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>child</code>是整个事件流的目标元素, 所以触发时机介于二者之间.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a>Notice</h4><ol>\n<li><p>如果将<code>div</code>换成<code>button</code>, 则点击<code>child</code>时可能只会显示 <strong>目标</strong> 阶段的输出.</p>\n<blockquote>\n<p>这是因为, 不同浏览器对于<code>button</code>元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段</p>\n</blockquote>\n</li>\n<li><p><code>event.stopPropagation();</code>加入该<del>咒语</del>代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">parent.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>    event.<span class=\"hljs-title function_\">stopPropagation</span>();<br>&#125;, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此时, 点击<code>parent</code>时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"可被移除的监听器\"><a href=\"#可被移除的监听器\" class=\"headerlink\" title=\"可被移除的监听器\"></a>可被移除的监听器</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;outside&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;t1&quot;</span>&gt;</span>one<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;t2&quot;</span>&gt;</span>two<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 为 table 添加可被移除的事件监听器</span><br><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();<br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, modifyText, &#123; <span class=\"hljs-attr\">signal</span>: controller.<span class=\"hljs-property\">signal</span> &#125;);<br><br><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  <span class=\"hljs-keyword\">if</span> (t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> === <span class=\"hljs-string\">&quot;three&quot;</span>) &#123;<br>    t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = <span class=\"hljs-string\">&quot;two&quot;</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = <span class=\"hljs-string\">&quot;three&quot;</span>;<br>    controller.<span class=\"hljs-title function_\">abort</span>(); <span class=\"hljs-comment\">// 当值变为 &quot;three&quot; 后，移除监听器</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>AbortController</code>是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;</li>\n<li><code>signal</code>属性是一个<code>AbortSignal</code>对象, 用于控制监听器的移除;</li>\n<li><code>controller.abort()</code>方法用于移除监听器;</li>\n<li>当<code>t2</code>的内容变为”three”时, 移除监听器, 使得<code>modifyText</code>函数不再执行. 此后, 点击<code>t2</code>不会触发<code>modifyText</code>函数.</li>\n</ul>\n</blockquote>\n<p>具体的<strong>构造步骤:</strong></p>\n<ol>\n<li>创建一个<code>AbortController</code>实例: <code>const controller = new AbortController();</code></li>\n<li>在事件监听器内的参数中添加<code>signal: controller.signal</code>选项;</li>\n<li>在需要移除监听器的地方调用<code>controller.abort()</code>方法;</li>\n</ol>\n<hr>\n<p>我们也可以直接使用<code>removeEventListener()</code>方法来移除事件监听器:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title function_\">removeEventListener</span>(type, listener);<br><span class=\"hljs-title function_\">removeEventListener</span>(type, listener, options);<br><span class=\"hljs-title function_\">removeEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>Notices:<ul>\n<li>如果同一个对象上存在2个事件监听器, 且仅在<code>useCapture</code>参数存在差异, 那么需要先后2次调用<code>removeEventListener()</code>方法才能完全移除其事件监听器;</li>\n<li>如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;</li>\n<li><code>type</code>,<code>listener</code>参数必须完全匹配才能移除事件监听器;</li>\n<li>对于<code>options</code>参数:<ul>\n<li>字段相同: 一定可以移除;</li>\n<li>字段不同: 需要与默认值false匹配才可以移除.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">element.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span> &#125;);<br><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">true</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">false</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">capture</span>: <span class=\"hljs-literal\">true</span> &#125;); <span class=\"hljs-comment\">// 失败</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class=\"hljs-attr\">passive</span>: <span class=\"hljs-literal\">false</span> &#125;); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, <span class=\"hljs-literal\">false</span>); <span class=\"hljs-comment\">// 成功</span><br>element.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;mousedown&quot;</span>, handleMouseDown, <span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 失败</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>添加与移除</strong>的结合使用:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> body = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&quot;body&quot;</span>);<br><span class=\"hljs-keyword\">const</span> clickTarget = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;click-target&quot;</span>);<br><span class=\"hljs-keyword\">const</span> mouseOverTarget = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;mouse-over-target&quot;</span>);<br><br><span class=\"hljs-keyword\">let</span> toggle = <span class=\"hljs-literal\">false</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">makeBackgroundYellow</span>(<span class=\"hljs-params\"></span>) &#123;<br>  body.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = toggle ? <span class=\"hljs-string\">&quot;white&quot;</span> : <span class=\"hljs-string\">&quot;yellow&quot;</span>;<br><br>  toggle = !toggle;<br>&#125;<br><br>clickTarget.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, makeBackgroundYellow, <span class=\"hljs-literal\">false</span>);<br><br>mouseOverTarget.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&quot;mouseover&quot;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  clickTarget.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">&quot;click&quot;</span>, makeBackgroundYellow, <span class=\"hljs-literal\">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"使用匿名函数\"><a href=\"#使用匿名函数\" class=\"headerlink\" title=\"使用匿名函数\"></a>使用匿名函数</h3><p>在上述<code>html</code>例子下:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\">new_text</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = new_text;<br>&#125;<br><br><span class=\"hljs-comment\">// 用匿名函数为 table 添加事件监听器</span><br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class=\"hljs-literal\">false</span>,<br>);<br></code></pre></td></tr></table></figure><br>通过匿名函数封装代码, 将参数传入函数<code>modifyText</code>, 使得函数可以被调用.</p>\n<h3 id=\"使用箭头函数\"><a href=\"#使用箭头函数\" class=\"headerlink\" title=\"使用箭头函数\"></a>使用箭头函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 改变 t2 内容的函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-params\">new_text</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> t2 = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;t2&quot;</span>);<br>  t2.<span class=\"hljs-property\">firstChild</span>.<span class=\"hljs-property\">nodeValue</span> = new_text;<br>&#125;<br><br><span class=\"hljs-comment\">// 用箭头函数为 table 添加事件监听器</span><br><span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;outside&quot;</span>);<br>el.<span class=\"hljs-title function_\">addEventListener</span>(<br>  <span class=\"hljs-string\">&quot;click&quot;</span>,<br>  <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">modifyText</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class=\"hljs-literal\">false</span>,<br>);<br></code></pre></td></tr></table></figure>\n<p>通过<code>=&gt;&#123;&#125;</code>形式的箭头函数简化代码书写.</p>\n<hr>\n<h4 id=\"比较匿名与箭头\"><a href=\"#比较匿名与箭头\" class=\"headerlink\" title=\"比较匿名与箭头\"></a>比较匿名与箭头</h4><p>匿名函数与箭头函数在此处的应用基本相同, 但是在<code>this</code>的指向上有所不同:</p>\n<ul>\n<li><p>匿名函数与其他普通的JS函数:<code>this</code>指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为<code>undefined</code>);</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>); <span class=\"hljs-comment\">// 在非严格模式下，this 指向 window</span><br>&#125;<br><span class=\"hljs-title function_\">sayHello</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>箭头函数的<code>this</code>继承自外部作用域, 即调用该方法的对象.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;ZJU&quot;</span>,<br>  <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// this 指向 obj</span><br>  &#125;,<br>&#125;;<br>obj.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：ZJU</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;ZJU&quot;</span>,<br>  <span class=\"hljs-attr\">getNameWithAnonymous</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;;<br>  &#125;,<br>  <span class=\"hljs-attr\">getNameWithArrow</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>);<br>    &#125;;<br>  &#125;,<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> anonymousFn = obj.<span class=\"hljs-title function_\">getNameWithAnonymous</span>();<br><span class=\"hljs-title function_\">anonymousFn</span>(); <span class=\"hljs-comment\">// 输出：undefined</span><br><br><span class=\"hljs-keyword\">const</span> arrowFn = obj.<span class=\"hljs-title function_\">getNameWithArrow</span>();<br><span class=\"hljs-title function_\">arrowFn</span>(); <span class=\"hljs-comment\">// 输出：ZJU</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>进一步完善.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p>$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如<code>event</code>,<code>e</code>,<code>evt</code>. 它被自动传递给事件处理函数，以提供额外的功能和信息。</p>\n<p><code>e.target</code>始终是对 <strong>事件刚刚发生的元素</strong> 的引用</p>\n<h2 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new()\"></a>new()</h3><p>$\\underline{new}$ 用来创建对象实例的一个关键字. </p>\n<ul>\n<li>作用: <strong>调用</strong> 一个 构造函数, 并返回一个由该构造函数创建的对象实例.<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> constructor<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1, arg2</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">arg1, arg2, <span class=\"hljs-comment\">/* …, */</span> argN</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即<code>new foo</code> 等价于 <code>new foo()</code>;</li>\n<li>构造函数内部的<code>this</code>将被绑定到新建的对象实例上;</li>\n</ol>\n<ul>\n<li>e.g. <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">color, brand</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span> = color;   <span class=\"hljs-comment\">// 将 color 赋值给新对象</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">brand</span> = brand;   <span class=\"hljs-comment\">// 将 brand 赋值给新对象</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> myCar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;red&quot;</span>, <span class=\"hljs-string\">&quot;Toyota&quot;</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myCar.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// 输出 &quot;red&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(myCar.<span class=\"hljs-property\">brand</span>); <span class=\"hljs-comment\">// 输出 &quot;Toyota&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用<code>new()</code>的<strong>步骤</strong>:</p>\n<ol>\n<li>定义构造函数;</li>\n<li>使用<code>new()</code>并传入构造函数的参数;</li>\n<li>将返回的对象实例赋值给一个变量;</li>\n</ol>\n<h4 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h4><ul>\n<li><p>为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">car1.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;black&quot;</span> <span class=\"hljs-comment\">//为car1新增color属性</span><br></code></pre></td></tr></table></figure>\n<p><br></p>\n</li>\n<li><p>添加共享属性到构造函数中的<code>prototype</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>car1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();<br>car2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-title class_\">Car</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;原色&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><br>car1.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;黑色&quot;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;黑色&#x27;</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(car1).<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(car2).<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car1.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;黑色&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(car2.<span class=\"hljs-property\">color</span>); <span class=\"hljs-comment\">// &#x27;原色&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的构造函数名为<code>Car</code>, 因此通过<code>Car.prototype</code>可以访问到构造函数的原型对象;</li>\n<li><code>getPrototypeOf</code> 表示获取对象的<strong>原型对象</strong>, 因此此处均为最初定义的 <strong>原色</strong>.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><p>函数通过<code>new.target</code>属性可以判断是否通过<code>new</code>关键字调用, 即构造.</p>\n<ul>\n<li>如果函数是正常调用, 则返回<code>undefined</code>;</li>\n<li><p>如果函数是通过<code>new</code>调用, 返回被调用的构造函数.</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">new</span>.<span class=\"hljs-property\">target</span>) &#123;<br>    <span class=\"hljs-comment\">// 以函数的形式被调用。</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;color&#125;</span>车`</span>;<br>  &#125;<br>  <span class=\"hljs-comment\">// 通过 new 被调用。</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span> = color;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;红&quot;</span>); <span class=\"hljs-comment\">// a 是“红车”</span><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;红&quot;</span>); <span class=\"hljs-comment\">// b 是 `Car &#123; color: &quot;红&quot; &#125;`</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"对象类型与实例\"><a href=\"#对象类型与实例\" class=\"headerlink\" title=\"对象类型与实例\"></a>对象类型与实例</h4><p>$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">make, model, year</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">make</span> = make;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">model</span> = model;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<p>$\\underline{对象实例}$ 通过使用<code>new()</code>方法, 由对象类型构造一个对象实例:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> myCar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;鹰牌&quot;</span>, <span class=\"hljs-string\">&quot;Talon TSi&quot;</span>, <span class=\"hljs-number\">1993</span>);<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"类与new\"><a href=\"#类与new\" class=\"headerlink\" title=\"类与new\"></a>类与new</h4><p>在JS当中, 类 <strong>必须</strong> 通过<code>new</code>调用.</p>\n<blockquote>\n<p>可以优先阅读<a href=\"#类\">类相关的知识</a></p>\n</blockquote>\n<ul>\n<li>e.g. <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span> &#123;<br>  <span class=\"hljs-comment\">//构造函数</span><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br>  <span class=\"hljs-comment\">//实例方法</span><br>  <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`你好，我的名字是<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n对于上述的类, 必须使用如下的调用方式:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> animal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&quot;Dog&quot;</span>); <span class=\"hljs-comment\">// 正常</span><br></code></pre></td></tr></table></figure>\n而下面这样类似于普通函数的调用方式会抛出错误:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Animal</span>(<span class=\"hljs-string\">&quot;Cat&quot;</span>); <span class=\"hljs-comment\">// TypeError:  Class constructor Animal cannot be invoked without &#x27;new&#x27;</span><br></code></pre></td></tr></table></figure>\n<br></li>\n</ul>\n<p>在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">animal.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出 &quot;你好，我的名字是Dog&quot;</span><br></code></pre></td></tr></table></figure></p>\n<hr>\n<p>下面给出与普通函数的区别:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Car</span>(<span class=\"hljs-params\">model</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">model</span> = model;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> car = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;Toyota&quot;</span>); <span class=\"hljs-comment\">// 正常</span><br><span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;Honda&quot;</span>); <span class=\"hljs-comment\">// 不抛出错误，但 this 会指向全局对象.</span><br><span class=\"hljs-keyword\">const</span> anotherCar = <span class=\"hljs-title class_\">Car</span>(<span class=\"hljs-string\">&quot;cat&quot;</span>); <span class=\"hljs-comment\">//此时全局对象下的model值为 &quot;cat&quot;, 覆盖了上一行的定义.</span><br></code></pre></td></tr></table></figure><br>总结:</p>\n<ul>\n<li>以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;</li>\n<li>如果以new方法构造得到对象实例, 依旧正常.</li>\n</ul>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"默认行为\"><a href=\"#默认行为\" class=\"headerlink\" title=\"默认行为\"></a>默认行为</h2><p>$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.</p>\n<ul>\n<li>比如存在以下的默认行为:<ul>\n<li>滚动事件：触摸屏上滑动手指，页面会滚动;</li>\n<li>拖拽文件到浏览器：浏览器会尝试加载文件;</li>\n<li>点击链接 <code>(&lt;a href=&quot;...&quot;&gt;)</code>：跳转到指定的 URL;</li>\n</ul>\n</li>\n</ul>\n<p>$\\underline{阻止默认行为}$ 使用 <code>event.preventDefault()</code> 方法可以阻止事件的默认行为.</p>\n<ul>\n<li><p>e.g: 阻止链接跳转</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>).<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>    event.<span class=\"hljs-title function_\">preventDefault</span>(); <span class=\"hljs-comment\">// 阻止点击链接时的默认行为</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;链接被点击，但没有跳转&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>通过阻止默认行为, 可以实现自定义逻辑.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ul>\n<li><code>this</code>可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;</li>\n<li><code>this</code> 指向的是<strong>当前函数的调用者</strong>，而不是函数内部定义的变量.</li>\n</ul>\n<p><br></p>\n<ul>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;b in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b in the function&quot;</span>; <span class=\"hljs-comment\">// 函数作用域</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span>); <span class=\"hljs-comment\">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class=\"hljs-title function_\">f</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处的<code>f</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"函数上下文中的this\"><a href=\"#函数上下文中的this\" class=\"headerlink\" title=\"函数上下文中的this\"></a>函数上下文中的this</h3><ul>\n<li><code>this</code>参数的值取决于函数<strong>如何</strong>被调用, 而不是函数如何被定义.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 对象可以作为第一个参数传递给 &#x27;call&#x27; 或 &#x27;apply&#x27;，</span><br><span class=\"hljs-comment\">// 并且 &#x27;this&#x27; 将被绑定到它。</span><br><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;Custom&quot;</span> &#125;;<br><br><span class=\"hljs-comment\">// 使用 var 声明的变量成为 &#x27;globalThis&#x27; 的属性。</span><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;Global&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">whatsThis</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// &#x27;this&#x27; 取决于函数如何被调用</span><br>&#125;<br><br><span class=\"hljs-title function_\">whatsThis</span>(); <span class=\"hljs-comment\">// &#x27;Global&#x27;; 在非严格模式下，&#x27;this&#x27; 参数默认为 &#x27;globalThis&#x27;</span><br>obj.<span class=\"hljs-property\">whatsThis</span> = whatsThis;<br>obj.<span class=\"hljs-title function_\">whatsThis</span>(); <span class=\"hljs-comment\">// &#x27;Custom&#x27;; &#x27;this&#x27; 参数被绑定到 obj</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol>\n<li>同样是调用函数<code>whatsThis()</code>, 但是<code>this</code>参数被绑定到不同的对象上, 导致返回值不同;</li>\n<li>在非严格模式下, <code>this</code>参数默认指向<code>globalThis</code>, 即全局对象;</li>\n<li>对于典型函数, <code>this</code>指向函数访问的对象;</li>\n</ol>\n<ul>\n<li><p>e.g. </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;b in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b in the function&quot;</span>; <span class=\"hljs-comment\">// 函数作用域</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span>); <span class=\"hljs-comment\">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-string\">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class=\"hljs-title function_\">f</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处<code>f</code>作为<code>obj</code>对象的方法被调用, 因此普通函数的<code>this</code>指向<code>obj</code>.</p>\n</blockquote>\n</li>\n<li><p>e.g. 直接调用的普通函数<code>this</code>指向全局:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">const</span> funcA = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> &#125;; <span class=\"hljs-comment\">// 普通函数，this 由调用方式决定</span><br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">funcA</span>()); <span class=\"hljs-comment\">// 访问 this.a</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br>obj.<span class=\"hljs-title function_\">f</span>(); <span class=\"hljs-comment\">// &quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的<code>funcA</code>并没有类似于作为对象的属性调用(<code>obj.funcA()</code>), 因此其<code>this</code>指向全局作用域(<code>window</code>), 输出<code>undefined</code>, 而是直接调用的形式, 因此其<code>this</code>指向全局作用域.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"对this传值\"><a href=\"#对this传值\" class=\"headerlink\" title=\"对this传值\"></a>对this传值</h3><p>使用<code>call()</code>以及<code>apply()</code>方法可以将<code>this</code>绑定到其他对象上.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h4><ul>\n<li>形式: <code>func.call(thisArg, arg1, arg2, ...)</code></li>\n<li>e.g:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">c, d</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> + c + d;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-comment\">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class=\"hljs-comment\">// 剩余的参数被绑定到命名参数。</span><br>add.<span class=\"hljs-title function_\">call</span>(o, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 16</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><ul>\n<li>形式: <code>func.apply(thisArg, [argsArray])</code></li>\n<li>e.g:<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">c, d</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span> + c + d;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">3</span> &#125;;<br><br><span class=\"hljs-comment\">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class=\"hljs-comment\">// 第二个参数是一个数组，其成员被绑定到命名参数。</span><br>add.<span class=\"hljs-title function_\">apply</span>(o, [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>]); <span class=\"hljs-comment\">// 34</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h4><ul>\n<li>形式: <code>f.bind(someObject)</code>;</li>\n<li><strong>作用</strong>: <ul>\n<li>创建一个新的函数(需要重新赋值), 具有与<code>f</code>相同的函数体和作用域;</li>\n<li>新函数的<code>this</code>被 <strong>永久地</strong> 绑定到<code>someObject</code>, 不随调用方式的变化而变化.</li>\n</ul>\n</li>\n<li><strong>限制</strong>: <ul>\n<li><code>bind</code>无法多次生效. 即对函数f<code>bind</code>得到的g, 无法继续用<code>bind</code>得到期望的h;</li>\n</ul>\n</li>\n<li><p>e.g. 多次<code>bind</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> g = f.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;azerty&quot;</span> &#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> h = g.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;yoo&quot;</span> &#125;); <span class=\"hljs-comment\">// bind 只能生效一次！</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">37</span>, f, g, h &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(o.<span class=\"hljs-property\">a</span>, o.<span class=\"hljs-title function_\">f</span>(), o.<span class=\"hljs-title function_\">g</span>(), o.<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// 37 37 undefined undefined</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>由于<code>bind</code>只能对一个原始函数作用, 因此由f得到的g无法继续由<code>bind</code>绑定<code>this</code>得到期望的h, 此处h的<code>this</code>依旧是<code>&#123;b: &quot;azerty&quot;&#125;</code>, 因此在输出对象<code>a</code>时显示<code>undefined</code>;</li>\n<li><code>o.f()</code>的调用是普通函数的调用, 因此其<code>this</code>继承自对象<code>o</code>, 输出<code>37</code>;</li>\n</ul>\n</blockquote>\n</li>\n<li><p>e.g. 对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span> + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">c</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> g = f.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;azerty&quot;</span> , <span class=\"hljs-attr\">c</span>:<span class=\"hljs-string\">&quot;ccc&quot;</span>&#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// &quot;undefined ccc&quot;</span><br><br><span class=\"hljs-keyword\">const</span> h = g.<span class=\"hljs-title function_\">bind</span>(&#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;yoo&quot;</span> &#125;); <span class=\"hljs-comment\">// bind 只能生效一次！</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// &quot;undefined ccc&quot;</span><br><br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">37</span>, f, g, h &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(o.<span class=\"hljs-property\">a</span>, o.<span class=\"hljs-title function_\">f</span>(), o.<span class=\"hljs-title function_\">g</span>(), o.<span class=\"hljs-title function_\">h</span>()); <span class=\"hljs-comment\">// 37 37 azerty azerty</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>bind</code>绑定的<code>this</code>是永久覆盖, 而非简单叠加;</li>\n<li>由于<code>bind</code>绑定的<code>this</code>不随者调用方式的变化而变化, 因此即使处于对象<code>o</code>当中, <code>g</code>,<code>h</code>依旧不会输出<code>o</code>中的<code>a</code>.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。</p>\n<p>普通函数:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br> <span class=\"hljs-attr\">f</span>: foo<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>()); <span class=\"hljs-comment\">// &quot;a in the obj&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p><code>call()</code>、 <code>apply()</code>、 <code>bind()</code> 无法改变箭头函数的<code>this</code>(但是call与apply的其他参数可以正常传递:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">foo</span> = (<span class=\"hljs-params\"></span>)=&gt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br> <span class=\"hljs-attr\">f</span>: foo.<span class=\"hljs-title function_\">bind</span>(&#123;<span class=\"hljs-attr\">a</span>:<span class=\"hljs-string\">&quot;a in the bind&quot;</span>&#125;) <span class=\"hljs-comment\">// 显式绑定 this 到 obj, 但是无法生效</span><br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>()); <span class=\"hljs-comment\">// undefined</span><br><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>换成普通函数则输出<code>a in the obj</code>.</p>\n</blockquote>\n<ul>\n<li>全局作用域<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">foo1</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>\t<span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>\t<span class=\"hljs-attr\">f</span>: <span class=\"hljs-function\">()=&gt;</span> a<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n<li>块级作用域: 由<code>let</code>或<code>const</code>声明的变量的作用域.(对于<code>var</code>无效);</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// 1</span><br><br>&#123;<br>  <span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<p>Notices:</p>\n<ul>\n<li>对象本身并不会创建作用域, 只是一个键值对的集合;</li>\n<li>箭头函数也不会创建自己的作用域, 而是 <strong>继承</strong> 外层作用域中的<code>this</code>;</li>\n</ul>\n<h3 id=\"变量与作用域\"><a href=\"#变量与作用域\" class=\"headerlink\" title=\"变量与作用域\"></a>变量与作用域</h3><ul>\n<li><code>var</code>在全局作用域中声明时会成为 <strong>全局对象</strong> (<code>window</code>或<code>global</code>)的属性;</li>\n<li><code>let</code>和<code>const</code>即使在全局作用域中声明, 也不会成为全局对象的属性;<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;1&quot;</span>;<br><span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-string\">&quot;2&quot;</span>;<br><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// &quot;1&quot;</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">b</span>; <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>因此, 建议在全局作用域中不要使用<code>var</code>声明变量, 而使用<code>let</code>或<code>const</code>声明变量. 从而避免导致意外的覆盖和冲突.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"函数与作用域\"><a href=\"#函数与作用域\" class=\"headerlink\" title=\"函数与作用域\"></a>函数与作用域</h3><h4 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h4><p>普通函数和匿名函数的作用域继承自其定义时的作用域.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">insideObj</span>: &#123;<br>        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// 普通函数，this 动态绑定到 insideObj</span><br>        &#125;<br>    &#125;,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>; <span class=\"hljs-comment\">// 普通函数，this 动态绑定到 obj</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());        <span class=\"hljs-comment\">// &quot;a in the obj&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">insideObj</span>.<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">// undefined，因为 insideObj 中没有 a</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>e.g. <strong>箭头函数继承外层作用域</strong>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">&quot;a in the global&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;a in the obj&quot;</span>,<br>    <span class=\"hljs-attr\">insideObj</span>: &#123;<br>        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span><br>    &#125;,<br>    <span class=\"hljs-attr\">f</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span><br>&#125;;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-title function_\">f</span>());        <span class=\"hljs-comment\">// &quot;a in the global&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">insideObj</span>.<span class=\"hljs-title function_\">g</span>()); <span class=\"hljs-comment\">//&quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure><br>由于对象不会创建作用域, 因此此处的箭头函数的<code>this</code>继承了外层作用域(window)的<code>this</code>, 且<code>var</code>创建的变量存在于全局作用域中.</p>\n<h2 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h2><p>$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.</p>\n<ul>\n<li>本质上没有增加语言的功能, 而是对已有功能的 <strong>包装</strong> 或者优化;</li>\n<li><strong>可读性提升</strong>: <del>让代码更填</del> 使得代码更加容易理解和书写;</li>\n<li><strong>底层实现</strong>: 实质上依旧用基础的语法实现.</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类 <code>class</code> 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承<code>prototype</code>的封装.</p>\n<p>使用<code>class</code>的写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>);<br>person.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p>\n<p>等价的原型写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">greet</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Hello, my name is <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> person = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>);<br>person.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"箭头函数-2\"><a href=\"#箭头函数-2\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.</p>\n<ul>\n<li>e.g.<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 使用箭头函数</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; a + b;<br><br><span class=\"hljs-comment\">// 等价的普通函数</span><br><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h3><p>$\\underline{结构赋值}$ 手动提取<strong>对象</strong>属性的语法糖.</p>\n<ul>\n<li><p>使用结构赋值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;Zhuo&quot;</span>, <span class=\"hljs-attr\">gender</span>:<span class=\"hljs-string\">&quot;male&quot;</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> &#123;name, gender&#125; = person;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>等价的原型写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123;<span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&quot;Zhuo&quot;</span>, <span class=\"hljs-attr\">gender</span>:<span class=\"hljs-string\">&quot;male&quot;</span>&#125;;<br><br><span class=\"hljs-keyword\">const</span> name = person.<span class=\"hljs-property\">name</span>;<br><span class=\"hljs-keyword\">const</span> gender = person.<span class=\"hljs-property\">gender</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"赋值规则\"><a href=\"#赋值规则\" class=\"headerlink\" title=\"赋值规则\"></a>赋值规则</h4><p>结构赋值时, 基于 <strong>属性名匹配</strong> 而非顺序.<br>因此, 对象结构的<code>&#123;&#125;</code>内部属性必须和 <strong>对象的属性名</strong> 相对应.</p>\n<p><strong>错误</strong>的示例:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; a, b &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：undefined</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：undefined</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>重命名属性</strong>的写法:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">name</span>: a, <span class=\"hljs-attr\">age</span>: b &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：25</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>手动赋值</strong>: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> person = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;Alice&quot;</span> &#125;;<br><span class=\"hljs-keyword\">const</span> &#123; name, age = <span class=\"hljs-number\">30</span> &#125; = person;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(name); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(age);  <span class=\"hljs-comment\">// 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）</span><br></code></pre></td></tr></table></figure></p>\n<h4 id=\"数组的结构赋值\"><a href=\"#数组的结构赋值\" class=\"headerlink\" title=\"数组的结构赋值\"></a>数组的结构赋值</h4><p>上述讨论的结构赋值都是对 <strong>对象</strong> 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— <strong>基于顺序</strong>赋值:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-number\">25</span>];<br><span class=\"hljs-keyword\">const</span> [a, b] = arr;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出：Alice</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(b); <span class=\"hljs-comment\">// 输出：25</span><br></code></pre></td></tr></table></figure></p>\n"},{"title":"cpp学习记录","date":"2025-02-14T12:21:21.000Z","excerpt":"一起来学习cpp","math":true,"_content":"\n编译时, 从`c`的`gcc`转变为了`g++`.\n\n# 基本语法\n在C语言中,我们主要使用`malloc()`和`free()`来进行动态内存管理。但这种方式存在一些问题:\n- 它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n- 容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了`new`和`delete.\n\nnew的基本语法十分直观:\n```cpp\nType* pointer = new Type;           // 分配单个对象\nType* pointer = new Type[size];     // 分配对象数组\n```\n\n可以在创建时进行初始化:\n```cpp\nint* p1 = new int(5);              // 初始化为5\nstring* p2 = new string(\"hello\");   // 初始化为\"hello\"\n```\n\n也可以根据变量进行动态的内存分配:\n```cpp\nint size;\ncin >> size;\nint* arr = new int[size];  // 根据输入分配内存\n```\n\n\n# 输入输出流\n通过包含头文件 -- `#include <iostream>` 来使用输入输出流 `cin` 和 `cout`.\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(){\n    int age; \n    cin >> age;\n    cout << \"You are \" << age << \" years old\" << endl;\n    // endl 是换行符\n    return 0;\n}\n```\n\n- `cin`读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n```cpp\nstring str=\"Hello world!\";\nofstream fout(\"out.txt\");\nfout<<str<<endl;\n\nifstream fin(\"out.txt\");\nstring str1,str2;\n\n// 读取文件中的两个字符串\nfin>>str1>>str2; \n\ncout << str1 << endl << str2 << endl;\n// 输出:\n// Hello\n// world!\n\nreturn 0;\n```\n\n\n## 文件流\n\n### 输入输出流基础\n- 头文件: `#include <fstream>`\n- 类: `ifstream`(输入流), `ofstream`(输出流)\n```cpp\n#include <fstream>  // 需要包含这个头文件\nusing namespace std;\n\n// 文件输出（写入文件）\nofstream outFile(\"output.txt\");\noutFile << \"Hello World\" << endl;\noutFile.close();\n\n// 文件输入（读取文件）\nifstream inFile(\"input.txt\");\nstring line;\ngetline(inFile, line);\ninFile.close();\n```\n  - 写入文件时, 如果没有文件, 会自动创建.\n\n\n### 常用操作示例\n\n1. **写入文件**\n```cpp\nofstream outFile;\noutFile.open(\"test.txt\");  // 打开文件\nif (outFile.is_open()) {   // 检查是否成功打开\n    outFile << \"第一行\" << endl;\n    outFile << \"第二行\" << endl;\n    outFile.close();       // 完成后关闭文件\n}\n```\n\n2. **读取文件**\n```cpp\nifstream inFile(\"test.txt\");\nstring line;\nwhile (getline(inFile, line)) {  // 逐行读取\n    cout << line << endl;\n}\ninFile.close();\n```\n\n3. **以追加模式打开文件**\n```cpp\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式\noutFile << \"这行会被添加到文件末尾\" << endl;\noutFile.close();\n```\n\n\n### 文件打开模式\n\n- `ios::in` - 读取模式\n- `ios::out` - 写入模式\n- `ios::app` - 追加模式\n- `ios::ate` - 打开文件后立即定位到文件末尾\n- `ios::binary` - 二进制模式\n- `ios::trunc` - 如果文件存在则**截断**文件\n  - 如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n```cpp\n// 假设 test.txt 原本内容是:\n// Hello World\n// This is a test\n\n// 使用 trunc 模式打开\nofstream outFile(\"test.txt\", ios::out | ios::trunc);  \noutFile << \"新的内容\" << endl;\noutFile.close();\n\n// 现在 test.txt 的内容只有:\n// 新的内容\n```\n>  或直接用 `ios::out`，因为out默认包含trunc\n\n\n- 使用位或运算符`|`来同时指定多个模式:\n```cpp\n// 组合使用打开模式\nofstream outFile(\"test.txt\", ios::out | ios::app);\n```\n\n### 错误处理\n\n```cpp\nifstream inFile(\"nonexistent.txt\");\nif (!inFile) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n\n// 或者使用is_open()\nif (!inFile.is_open()) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n```\n\n# 变量\n## String\n需要先引入指定的头文件:\n```cpp\n#include <string>\n```\n\n- 定义时可以使用等号或者用括号包裹字符串:\n```cpp\nstring name = \"John\"; \n// string name(\"John\");\n```\n\n---\n\n### stringstream\n`stringstream` 表示**双向**字符串流:\n- 需要导入头文件`#include <sstream>`;\n- `istringstream` 表示**输入**字符串流\n  - 作用: 将字符串转换成一个类似于输入流的对象;\n  - 内部维护了一个字符串和一个位置指针;\n  - 每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n- `ostringstream` 表示**输出**字符串流.\n\n\n#### 字符串分词\n自动以**空白字符**(空格、制表符\\t、换行符\\n等)分割字符串;\n\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string name ( \"Xiao Ming\");\n\n    // 使用括号包字符串\n    istringstream is (name); \n    string s;\n    while (is>>s){\n        cout << s << endl;\n    }\n}\n```\n> `>>` 表示从输入流中读取数据;\n>\n> 注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\n```shell\nXiao Ming\nXiao\nMing\n```\n\n包含更多分词的字符串:\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string words = \"hello \\n world! \\t I am \\n here!\";\n    stringstream is (words);\n    \n    string word;\n    int count  = 1;\n    while(is >> word){\n        cout << \"Word \" << count << \": \" << word << endl;\n        count++;\n    }\n}\n```\nOutput:\n```shell\nWord 1: hello\nWord 2: world!\nWord 3: I\nWord 4: am\nWord 5: here!\n```\n\n#### 字符串拼接\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    string result = oss.str();\n    cout << result << endl;\n}\n```\nOutput:\n```shell\nName: Alice, Age: 25\n```\n> 通过`.str()`方法可以对象转换为字符串类型, 从而**格式化输出**.\n\n<br>\n\n`.str(\"\")`方法可以**清空**字符串流:\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    oss.str(\"\");\n    string result = oss.str();\n    cout << result << \"Nothing\" << endl;\n}\n```\nOutput:\n```shell\nNothing\n```\n\n### Getline\n**基本语法:**\n```cpp\ngetline(istream& is, string& str, char delim = '\\n');\n```\n- `is`: 输入流（通常是cin;\n- `str`: 存储结果的字符串;\n- `delim`: 分隔符, 默认为换行符`\\n`.\n\n**Example**:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string line;\n    \n    cout << \"请输入一行文本：\";\n    getline(cin, line);  // 读取整行，包括空格\n    cout << \"你输入的是：\" << line << endl;\n    \n    // 使用自定义分隔符\n    string data;\n    cout << \"请输入内容（用,分隔）：\";\n    getline(cin, data, ',');  // 读取直到遇到逗号\n    cout << \"读取到逗号前的内容：\" << data << endl;\n}\n```\n\n### cin\n**特点**:\n- 以空白字符（空格、制表符、换行符）为分隔符;\n- **忽略**前导空白字符;\n- 遇到空白字符就停止读取.\n\n\n通常需要与`getchar()`方法配合来清除缓冲区当中的`\\n`字符:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int number;\n    string line;\n    \n    cout << \"输入一个数字：\";\n    cin >> number;\n    \n    //清除输入缓冲区中的换行符\n    getchar(); // or cin.ignore(); \n   \n    cout << \"输入一行文本：\";\n    getline(cin, line);  // 现在可以正确读取整行\n    \n    cout << \"数字：\" << number << endl;\n    cout << \"文本：\" << line << endl;\n}\n```\n> 如果输入`8 \\n`, 则`getchar()`读取空格, 文本为空.\n\n### Alter String\n**outline** 常用的字符串方法(成员函数):\n```cpp\ninsert(size_t pos, const string& s);\nerase (size_t pos = 0, size_tlen = npos);\nappend (const string& str);\nreplace (size_t pos,size_t len,const string& str);\n```\n\n---\n#### 常用方法\n\n- `insert(int pos, string str)` 在指定位置插入字符串\n```cpp\nstring str = \"Hello World\";\n// 在位置5处插入字符串\nstr.insert(5, \" Beautiful\");\ncout << str << endl;  // 结果: \"Hello Beautiful World\"\n\n// 在字符串末尾插入内容\nstr.insert(str.length(), \"!\");\ncout << str << endl;  // 结果: \"Hello Beautiful World!\"\n\n// 插入单个字符（使用string构造）\nstr.insert(0, \">\");\ncout << str << endl;  // 结果: \">Hello Beautiful World!\"\n```\n\n---\n- `erase(int pos, int length)` 删除从指定位置开始的若干个字符\n```cpp\nstring str = \"Hello Beautiful World!\";\n\n// 删除从下标6开始的9个字符\nstr.erase(6, 9); \ncout << str << endl;  // 结果: \"Hello World!\"\n\n// 删除从某个位置开始到末尾的所有字符\nstr.erase(5);\ncout << str << endl;  // 结果: \"Hello\"\n```\n> `length`参数省略, 则删除从`pos`位置开始到字符串末尾的所有字符.\n\n\n---\n\n- `replace (int pos, int length, string)` 替换指定位置的字符串\n```cpp\n// 从位置6开始，替换5个字符为\"C++\"\nstring str = \"Hello World!\";\nstr.replace(6, 5, \"C++\");\ncout << str << endl;  // 结果: \"Hello C++!\"\n```\n\n\n---\n\n\n- `append (const string& str);`\n```cpp\n// 添加整个字符串\nstring1.append(string2);\n\n// 添加指定位置的字符(索引从开始)\nstring1.append(string2, start, length);\n\n// 重复字符的添加\nstring1.append(count, char);\n\n```\n\n除此之外, 还存在着使用$\\underline{迭代器}$的用法: \n> 类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string source = \"World!\";\n    string target = \"Hello \";\n    \n    // 添加source中的部分字符（从开始到结束）\n    target.append(source.begin(), source.end());\n    cout << target << endl;  // 输出: Hello World!\n    \n    // 只添加部分字符\n    string target2 = \"Hello \";\n    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"\n    cout << target2 << endl;  // 输出: Hello World\n    \n    return 0;\n}\n```\n1. `begin()`方法返回字符串的第一个字符的迭代器, `end()`方法返回字符串最后一个字符的**下一个**位置的迭代器;\n2. 迭代器的范围是**左闭右开**.\n\n---\n\n#### 其他方法\n\n- `find(string, int pos)` 寻找指定的字符串位置\n```cpp\nstring str = \"Hello World Hello\";\n// 从位置0开始查找\"Hello\"\ncout << str.find(\"Hello\", 0) << endl;     // 结果: 0\n// 从位置1开始查找\"Hello\"\ncout << str.find(\"Hello\", 1) << endl;     // 结果: 12\n// 查找不存在的字符串\ncout << str.find(\"Python\") << endl;       // 结果: string::npos\n```\n  - `string::npos`是`size_t`类型的最大值;\n  - 可以使用`str.find(\"Python\") == string::npos`作为判断条件, 检查是否找到字符串.\n\n---\n\n- `compare(string)` 字符串比较\n```cpp\nstring str1 = \"Hello\";\nstring str2 = \"Hello\";\nstring str3 = \"World\";\n\ncout << str1.compare(str2) << endl;  // 结果: 0  (相等)\ncout << str1.compare(str3) << endl;  // 结果: -15 (str1 < str3) \ncout << str3.compare(str1) << endl;  // 结果: 15  (str3 > str1)\n```\n  - 按照字典序比较得到结果\n\n---\n\n- `to_string(int)` 将数字转换成字符串\n```cpp\nint num = 123;\nstring str = to_string(num);\ncout << str << endl;          // 结果: \"123\"\ncout << str + \"456\" << endl;  // 结果: \"123456\"\n```\n  - 字符串之间可以通过`+`直接拼接.\n\n---\n\n- `stoi(string)` 将字符串转换成整数\n```cpp\nstring str = \"123\";\nint num = stoi(str);\ncout << num + 456 << endl;    // 结果: 579\n// 注意：字符串必须是合法的数字格式\n// string str = \"abc\"; \n// int num = stoi(str);  // 这会抛出异常\n```\n  - 字符串必须是合法的数字格式;\n  - ` int num = stoi(\"abc\");`  将会抛出异常\n\n---\n\n### 构造函数\n**Outline:**\n```cpp\nstring(const char *cp, int len);\nstring(const string& s2, int pos);\nstring(const string& s2, int pos, int len);\n```\n\n---\n\n- `string(const char *cp, int len)` 字符数组创建字符串\n```cpp\nstring str1(\"Hello World\", 5);\ncout << str1 << endl;\n// 输出: Hello\n```\n\n- `string(const string& s2, int pos)` 从现有字符串创建新字符串，从指定位置到末尾\n```cpp\nstring s2 = \"Hello World\";\nstring str2(s2, 6);\ncout << str2 << endl;\n// 输出: World\n```\n\n- `string(const string& s2, int pos, int len)` 从现有字符串创建新字符串，指定起始位置和长度\n```cpp\nstring s3 = \"Hello World\";\nstring str3(s3, 6, 3);\ncout << str3 << endl;\n// 输出: Wor\n```\n\n- `string(int length, char c)` 用指定长度的字符c初始化字符串\n```cpp\nstring str4(5, '*');\ncout << str4 << endl;\n// 输出: *****\n\n// 实际应用示例\nint num = 432;\nstring str = to_string(num);\ncout << string(5 - str.length(), '0') + str << endl;\n// 输出: 00432\n```\n\n\n### 成员函数\n\n```cpp\n// 提取子字符串\nsubstr(int pos, int len);\nstring str = \"Hello World\";\nstring sub = str.substr(6, 3);  // 结果: \"Wor\"\n```\n\n```cpp\n// 字符串赋值\nassign();\nstring str1 = \"Hello\";\nstring str2;\nstr2.assign(str1);  // str2现在是 \"Hello\"\n```\n\n\n```cpp\n// 在指定位置插入字符串\n    string str1 = \"hello\";\n    string str2 = \"world\";\n    str1.insert(3, str2);\n    cout << str1 << endl;\n// 结果: helworldlo \n```\n\n```cpp\n// 删除指定位置的指定长度的字符\nerase(int pos, int len);\nstring str = \"Hello World\";\nstr.erase(5, 6);  // 结果: \"Hello\"\n```\n\n**Notice：**\n1. 所有位置索引都是从0开始计数\n2. 如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n3. 使用这些函数时要注意检查参数的有效性，避免越界访问\n\n---\n### Substr\n在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. `substr()`方法可以精确地获取字符串片段.\n\n`substr`即substring的缩写, 表示子字符串.\n\n**基本语法**\n```cpp\nstring substr(int pos, int len) ;\n```\n参数分别表示截取的起始下标以及要截取的长度(如果省略`len`将截取到字符串的末尾).\n\n**e.g.**:\n```cpp\nstring email = \"user.name@example.com\";\n\n// 获取用户名的部分\nint atPos = email.find('@');\nstring username = email.substr(0, atPos); // result: \"user.name\"\n\n// 获取域名部分\nstring domain =  email.substr(atPos + 1); // result: \"example.com\"\n\n// 获取顶级域名(最后一个.之后的部分)\nint lastDotPos = email.rfind('.');\nstring topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n```\n- `rfind()`方法: 会从字符串的**末尾向前**搜索，从而返回要查找的字符或子字符串最后一次出现的位置。如果没有找到，则返回 string::npos。\n\n---\n\n# Group\n**选择的标准:**\n- 一般情况 $\\Rightarrow$ `vector`;\n- 程序需要对元素进行**随机访问** $\\Rightarrow$ `vector` or `deque`;\n- 程序需要在容器**中间插入**元素 $\\Rightarrow$ `list` or `forward_list`;\n- 程序需要在容器的**首尾插入**元素 $\\Rightarrow$ `deque`;\n- 容器中的元素**相对较小**但是数量较多 $\\nRightarrow$ `list` nor `forward_list`.\n  - 否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n## Vector\n\n存储元素在**连续的内存空间**中, 支持**随机访问**.\n- 可以动态增长, 适合存储**未知数量**的元素;\n- 通过下标访问元素的时间复杂度为 O(1);\n- 在末尾插入和删除元素的时间复杂度为 O(1);\n- 在中间插入和删除元素的时间复杂度为 O(n);\n- **使用场景**: 需要随机访问、排序、内存连续存储的场景.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器:\n  ```c++\n  auto it = find(vec.begin(), vec.end(), value);  // 查找 value\n    if (it != vec.end()) {         // 如果找到了（即没有返回 end()）\n        vec.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用 `.push_back()`在末尾插入元素, 或者使用`.emplace_back()`在末尾原位构造元素(更加高效);\n  ```c++\n  vec.push_back(10);\n  vec.emplace_back(20); //更加高效\n  ```\n  > `emplace_back`方法**直接**在容器的**内存空间中构造**对象, 相比于`push_back`而言更加**高效**.\n- `.erase()`方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  \n    ```c++\n     vec.erase(vec.begin() + 1);       // 删除第二个元素\n     vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素\n     vec.clear();                      // 清空整个 vector\n    ```\n    > `vec.clear();` 将会清空整个vector.\n    >\n    > 和`insert`需要的参数一样, 都需要**迭代器**而非索引来定位.\n- `vec[i]`的形式访问, 使用`vec.at(i)`的方式可以在越界时抛出异常;\n- `.begin()`和`.end()`获取迭代器, 使用范围for循环遍历元素;\n    ```c++\n     cout << \"Vector elements:\" << endl;\n     for (int num : vec) {\n        cout << num << \" \";\n     }\n     cout << endl;\n    \n    //使用迭代器遍历\n    for (auto it = vec.begin(); it != vec.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n    ```\n- `.size()`获取`vector`的大小, `.empty()`判断`vector`是否为空;\n  ```c++\n  cout << \"Vector size: \" << vec.size() << endl;\n  if (vec.empty()) {\n      cout << \"Vector is empty.\" << endl;\n  }\n  ```\n- 使用`sort()`对`vector`进行排序, 使用`find()`查找元素;\n  ```c++\n  sort(vec.begin(), vec.end());   // 排序\n  auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n  ```\n\n### Reserve\n为了避免频繁地扩展内存, 可以通过`reserve`预先分配合适的空间, 同时通过`.reszie()`调整大小;\n```cpp\nvector<string> v2;\nv2.reserve(1000);  // 一次性分配 1000 个元素的空间\n\nv2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n```\n\n`reserve`只分配空间而不创建元素,`resize`将同时分配元素(默认值):\n\n```cpp\nvector<string> vec;\n// reserve: 只分配空间，不创建元素\nvec.reserve(10);  \ncout << \"The capacity with reserve: \" << vec.capacity() << endl;\ncout << \"The size with reserve: \" << vec.size() << endl;    \n\n// resize: 分配空间并创建元素\nvec.resize(10);   \ncout << \"The capacity with resize: \" << vec.capacity() << endl;\ncout << \"The size with resize: \" << vec.size() << endl;   \n```\n\n**Output**:\n```shell\nThe capacity with reserve: 10\nThe size with reserve: 0\nThe capacity with resize: 10\nThe size with resize: 10\n```\n> [!important]\n>\n> `.push_back()`的实际作用是在容器索引的`size`处插入元素.\n>\n>  而`reserve`不会影响容器的`size`,  初始化和`resize`会影响并且填充默认值:\n\n**e.g.  验证:**\n\n```cpp\nint main() {\n    vector<int> vec(10);\n    \n    // 打印初始状态\n    cout << \"初始状态：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    // 预留5个空间\n    vec.reserve(15);\n    cout << \"reserve(15) 后：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    vec[20] =20;\n\n    // 添加元素并观察\n    cout << \"添加元素过程：\\n\";\n    for(int i = 1; i <= 6; i++) {\n        vec.push_back(i);\n        cout << \"添加 \" << i << \" 后 - \";\n        cout << \"size: \" << vec.size() \n             << \", capacity: \" << vec.capacity()\n             << \", 元素: \";\n        for(int x : vec) cout << x << \" \";\n        cout << \"\\n\";\n    }\n    \n    return 0;\n}\n\n```\n\n**Output:**\n\n```shell\n初始状态：\nsize: 10, capacity: 10\n\nreserve(15) 后：\nsize: 10, capacity: 15\n\n添加元素过程：\n添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 \n添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 \n添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 \n添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 \n添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 \n添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n```\n\n1. 此处的 `vector<int> vec(10);`初始化了10个默认值的`int`类型的元素;\n2. `vec[20] = 20;`没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n   1. 如果换成`vec.at(20) = 20`将会在编译时报错;\n3. 可以发现, `reserve`的作用就是避免了多次自动扩容.\n\n> `reserve`的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\n\n\n## List\n\n- 在`list`容器当中, 迭代器是双向迭代器;\n  - 双向迭代器不支持大小的比较, 只支持 `==`,`!=`,`++`,`--`;\n  因此, 注意实际的使用:\n```cpp\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin();\nlist<int>::iterator iter2 = lst1.end();\n\n// 正确的写法\nwhile (iter1 != iter2) {\n    // 处理当前元素\n    ++iter1;\n}\n\n// 错误的比较\n// while(iter1 < iter2) \n    \n```\n\n### 有序链表\n```cpp\n#include <iostream>\n#include <list>\n#include <string>\n\n\nusing namespace std;\n\nint main() {\n    list<string> s;\n    string str;\n    list<string> :: iterator p;\n    int count ;\n\n    cout << \"enter the number of the strings:\" << endl;\n\n    cin >> count; \n\n\n    for(int i = 0; i < count; i++){\n        cout << \"enter a string:\" ;\n        cin >>str;\n        \n        p = s.begin();\n        while(p != s.end() && *p <str)\n            p++;\n        s.insert(p,str);\n    }\n    for(p = s.begin(); p!=s.end(); p++)\n        cout << *p << endl;\n    cout << endl;\n    return 0;\n}\n```\n\n**分析:**\n- `while(p != s.end() && *p <str)` 每次输入`str`时, 令迭代器从`list`的开头开始, 进行字典序的比较;\n- 找到插入的位置, 利用`insert()`方法插入.\n\n\n\n## Deque\n`deque`即 double-ended queue, **双端队列**.\n\n支持:\n- 在两端快速的插入或删除;\n- 随机访问;\n\n**语法**:\n```cpp\n#include <deque>\ndeque<int> dq;\n\n// 1. 插入操作\ndq.push_back(1);    // 在末尾插入\ndq.push_front(2);   // 在开头插入\ndq.insert(pos, val);// 在指定位置插入\n\n// 2. 删除操作\ndq.pop_back();      // 删除末尾元素\ndq.pop_front();     // 删除首部元素\ndq.erase(pos);      // 删除指定位置元素\n\n// 3. 访问操作\ndq[0];              // 随机访问\ndq.at(1);           // 带边界检查的访问\ndq.front();         // 访问第一个元素\ndq.back();          // 访问最后一个元素\n```\n\n**示例:**\n```cpp\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    deque<int> dq;\n    \n    // 在两端插入元素\n    dq.push_back(3);\n    dq.push_front(1);\n    dq.push_back(4);\n    dq.push_front(8);\n    \n    // dq ：{8, 1, 3, 4}\n    \n    // 使用随机访问\n    for(size_t i = 0; i < dq.size(); ++i) {\n        cout << dq[i] << \" \";\n    }\n\n}\n\n```\n\n### Forward_list\n`forward_list`即 单项链表.\n- 只能向前遍历, 即对应的迭代器不支持`--`而支持`++`.\n- 同时不支持下标访问以及随机访问.\n- 单项链表的设计, 使得内部的每个节点只需要**一个**指针来指向下一个节点, 从而比`list`双向链表更加节省内存.\n\n**语法**:\n```cpp\n#include <forward_list>\nforward_list<int> fl;\n\n// 1. 插入操作\nfl.push_front(1);           // 在开头插入\nfl.insert_after(pos, val);  // 在指定位置之后插入\n\n// 2. 删除操作\nfl.pop_front();            // 删除第一个元素\nfl.erase_after(pos);       // 删除指定位置之后的元素\n\n// 3. 访问操作\nfl.front();               // 访问第一个元素\n\n// 4. 特殊操作\nfl.before_begin();        // 返回第一个元素之前的迭代器\nfl.begin();               // 返回第一个元素的迭代器\n```\n\n**示例**:\n\n```cpp\n#include <forward_list>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    forward_list<int> fl;\n    \n    // 插入元素\n    fl.push_front(3);\n    fl.push_front(2);\n    fl.push_front(1);\n    \n    // 在特定位置后插入\n    auto it = fl.begin(); // 指向第一个元素\n    fl.insert_after(it, 4); // 在第一个元素后插入4\n    \n    // 遍历打印\n    for(const auto& val : fl) {\n        cout << val << \" \";\n    }\n    // 输出：1 4 2 3\n}\n```\n\n#### 访问前一个元素\n由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合`before_begin()`方法.\n\n```cpp\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历\nauto prev = fl.before_begin();\nauto curr = fl.begin();\nwhile(curr != fl.end() && *curr != target) {\n    ++prev;\n    ++curr;\n}\n```\n\n## Map\n作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键**自动排序**\n- 如果插入重复的key, 将会覆盖原有的value;\n- 通过键查找元素、插入和删除的时间复杂度均为O(log n);\n- **使用场景**: 字典、索引、统计等.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于`map`当中;\n  ```cpp\n  auto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"\n    if (it != ages.end()) {         // 如果找到了（即没有返回 end()）\n        ages.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用下标(键)直接插入,或者通过键值对插入\n  ```cpp\n  ages[\"Alice\"] = 25;\n  ages.insert({\"Bob\", 30});\n  ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n  ```\n  > `emplace`方法指**直接**在容器的**内存空间中构造**对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于`insert`而言更加**高效**.\n- `.erase()`方法删除指定key的元素, 也可以通过`.find()`找到key对应的迭代器`it`, 然后`erase(it)`.\n  \n    ```cpp\n    ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素\n    \n    auto it = ages.find(\"Charlie\");\n    if (it != ages.end()) {\n        ages.erase(it);         // 删除迭代器指向的元素\n    }\n    ```\n    > `ages.clear();` 将会清空整个map.\n- `map[key]`的形式访问, 使用`map.at(key)`的方式可以在key不存在时抛出异常;\n- `.find(key)`查找对应键的元素( 返回**迭代器** ), `.count(key)`返回对应键的元素个数(0 or 1)\n- `.size()`获取map的大小.\n- 迭代器的`->first`和`->second`可以分别访问键和值.\n    ```cpp\n     cout << \"Map elements:\" << endl;\n     for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {\n        cout << mapIt->first << \": \" << mapIt->second << endl; // 访问键和值\n     }\n    ```\n\n## Iterator\n迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n- **标记位置**: `.begin()`和`.end()` 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n- 输入迭代器: 支持读取和递增操作;\n  - `istream_iterator`: 用于从输入流读取数据;\n- 输出迭代器: 支持写入和递增操作;\n  - `ostream_iterator`: 用于向输出流写入数据;\n- 前向迭代器: 具有输入、输出迭代器的**所有**功能, 并且可以多次遍历同一个序列;\n  - 比如`forwarf_list`的迭代器:`auto it = flist.begin()` or `forward_list<int>::iterator it = flist.begin()`;\n- 双向迭代器: 在前向迭代器的原有功能上, 同时支持**递减**操作;\n  - 比如双向链表`list`的迭代器.\n    ```cpp\n    #include <iostream>\n    #include <list>\n    using namespace std;\n    \n    int main() {\n        list<int> myList = {10, 20, 30, 40, 50};\n    \n        // 使用双向迭代器正向遍历\n        cout << \"Forward traversal: \";\n        for ( list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {\n            cout << *it << \" \";\n        }\n        cout <<  endl;\n    \n        // 使用双向迭代器逆向遍历\n        cout << \"Reverse traversal: \";\n        for ( list<int>::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {\n            cout << *rit << \" \";\n        }\n        cout <<  endl;\n    \n        return 0;\n        // Forward traversal: 10 20 30 40 50 \n        // Reverse traversal: 50 40 30 20 10 \n    }\n    ```\n    > 1. `reverse_iterator`用于声明逆向遍历的迭代器, 也可以使用`auto`直接声明.\n    > 2. `rbegin()`和`rend()`分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的`++`相当于正向遍历时的`--`操作.\n- 随机访问迭代器: 具有双向迭代器的所有功能, 同时支持**随机访问**, 如`it+n`,`it[n]`.\n  - 比如`vector`的迭代器.\n  ```cpp\n    vector<int> vec = {10, 20, 30, 40, 50};\n    cout << \"Vector elements (random access): \";\n    for (int i = 0; i < vec.size(); ++i) {\n        cout << vec[i] << \" \"; // 使用下标随机访问\n    }\n    cout << endl;\n  ```\n\n另外, 还有一种迭代器称为**插入迭代器**, 比如`back_inserter`\n```cpp\nvector<int> vec = {10, 20, 30, 40, 50};\n\n//结合copy将容器的元素直接插入到另一个容器中\nvector<int> dest = {60,70};\ncopy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素\ncout << \"Copied vector: \";\nfor (int num : dest) {\n    cout << num << \" \";\n}\ncout << endl;\n// Copied vector: 60 70 10 20 30 40 50 \n```\n\n## for-each\nfor-each 循环的语法：\n```cpp\nfor (range_declaration : range_expression) {\n    loop_statement;\n}\n```\n- range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 `auto `关键字让编译器自动推导类型;\n- range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或**字符串**;\n- loop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // 使用 for-each 循环遍历 vector\n    for (int num : numbers) {\n        std::cout << num << \" \"; // 输出每个元素\n    }\n    std::cout << std::endl;\n\n    // 使用 auto 关键字自动推导类型\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // 修改容器中的元素（需要使用引用）\n    for (int &num : numbers) {\n        num *= 2; // 将每个元素乘以 2\n    }\n\n    // 输出修改后的元素\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n- `for (int &num : numbers)`：使用引用 &，可以直接修改容器中的元素.\n\n### Map的循环\n当range_expression是`map`时, 可以使用`auto`自动推导range_declaration的类型.需要注意是:\n- 用迭代器的方式访问`map`中的键值对的性质是 `it->first`与`it->second`;\n- 在`for-each`循环当中, range_declaration是一个值, 因此使用`.first`与`.second`来访问键和值.\n    ```cpp\n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <string>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int main(){\n        map<string, string> m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};\n        vector<string> vec;\n    \n        for(auto& entry : m){\n            vec.push_back(entry.first + \":\" + entry.second );\n        }\n        copy(vec.begin(), vec.end(), ostream_iterator<string>(cout, \" \"));\n    }\n    ```\n    **Output:**\n    ```shell\n    one:1 three:3 two:2\n    ```\n> 此处由于`map`自动按照键的字典序进行排序, 因此输出时`three`的元素在`two`前;\n\n在上述的示例中, 也可以使用下面的方式进行`vec`的输出:\n```cpp\nfor(const auto& s : vec) {\n    cout << s << \" \";\n}\n```\n此时`auto`会自动推导为`string`类型, 且`&`对数组的元素进行了引用, 使得输出更加高效.\n\n### Pro&Con\n`for-each`循环的优点:\n- 消除了访问数组等越界的风险;\n- 不需要事先初始化迭代器;\n\n`for-each`循环的缺点:\n- 无法获取元素的索引;\n- 只能顺序地遍历.\n\n## typedef\n我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\n```cpp\ntypedef old_type new_type;\n```\n\n## Notices\n1. 直接对数组、字符串和`vector`进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n2. 对于`vector`, 可以通过`.at() = `的方式进行安全访问, 编译器会进行边界检查. 或者通过`.push_back()` or `.emplace_back`的方式在末尾赋值. 同时注意用`.reserve()`预先分配充分的内存空间.\n3. 避免不经意地向`map`当中插入元素:\n   1. 错误的示范:\n    ```cpp\n    if(foo[\"bob\"] == 1){...}\n    ```\n   2. 使用`.count()`方法正确检查元素是否存在:\n    ```cpp\n    if( foo.count(\"bob\") ){...}\n    ```\n   3. 也可以使用`find()`方法检查元素是否存在:\n   ```cpp\n    auto it = m.find(\"four\");\n   \n    if(it  != m.end()){\n        cout << it->second << endl;\n    }\n    else{\n        cout << \"Not found\" << endl;\n    }\n   ```\n4. 使用`.empty()`方法来检查容器**整体是否为空**, 而非`.count() == 0`的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n5. `erase()` 方法会返回**指向**被删除元素的**下一个**元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n   \n    ```cpp\n    //Initialize a list\n    list<int> L;\n    list<int>::iterator li = L.begin();\n    \n    // Wrong:\n    L.erase(li);    // 删除元素后，li 变成了无效迭代器\n    ++li;           // 错误, 不能对无效迭代器进行操作\n    \n    // Correct:\n    li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n    ```\n\n# 指针\n- Pointers to Objects\n```cpp\nstring str = \"hello\";\nstring *p = &str;\n```\n\n- Oprators with Pointers\n  - `&`: 取地址;\n  - `*`: 解引用;\n  - `->`: 用于访问对象的成员.\n```cpp\n(*p).length();\n// 等价于\np->length();\n```\n> `length()`即为`string`类的成员函数, 因此可以用`->`来访问.\n\n\n# 常量\n\n## 指针\n> 以`char`为例.\n\n- 常量指针 `char * const p`\n  - 地址是`const`类型, 无法赋予`p`新的地址;\n  - 但是可以改变指针指向对象的值.\n- 指针常量 `char const * p`\n  - 指针指向的值无法改变;\n  - 但是可以改变指针的值(指向的对象).\n  如果需要同时保证地址和值都无法改变, 则需要使用`const char * const p`.\n\ne.g:\n```cpp\nint a = 10;\nint b = 20;\nconst int *p = &a;  // 常量指针\nint const *p = &a;  // 指针常量\nint const * const p = &a;  // 常量指针常量\n// 错误示例\n// p = &b;  // 常量指针的值无法改变\n// *p = 30;  // 指针指向的值无法改变\n// 正确示例\nint c = 30;\np = &c;  // 常量指针的值可以改变\n*p = 40;  // 指针指向的值可以改变\n```\n> to be checked.\n\n\n\n\n\n如果`sp`是指向字符串的指针, 那么这两种的写法是等价的, 注意`.`的优先级高于`*`, 因此括号不可忽略.\n\n```cpp\nsp->length();\n(*sp).length();\n```\n\n\n\n# Class\n\n### `::`\n\n`::` resolver: 作用域解析运算符\n\n- 作用: \n\n  - 访问全局的作用域\n    当局部变量和全局变量同名时, 可以使用 `::` 来访问全局变量\n\n    ```cpp\n    int value = 10; // 全局变量\n    \n    void function() {\n        int value = 20; // 局部变量\n        cout << value;    // 输出 20（局部变量）\n        cout << ::value;  // 输出 10（全局变量）\n    }\n    ```\n\n  - 访问命名空间中的成员\n\n    ```cpp\n    namespace Math {\n        const double PI = 3.14159;\n    }\n    \n    double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n    ```\n\n- 语法:\n\n  - `<class_name> :: <function_name>`\n  - `::<function_name>`\n\n\n\ne.g. \n\n```cpp\nvoid S::f() {\n    ::f();  // Would be recursive otherwise!\n    ::a++;  // Select the global a\n    a--;    // The a at class scope\n}\n```\n\n> `S::f()`: 定义了属于类S的成员函数f;\n>\n> `::f()`:表示调用全局作用域中的函数 `f()`, 默认为递归调用当前的成员函数;\n>\n> `::a++`表示将全局作用域的 `a` 自增, `a--`则访问并递减类作用域中的成员变量 `a`.\n\n\n\n### `this`\n\n`this`指针是成员函数的隐藏参数. 指向**当前对象的实例**.\n\n```cpp\nvoid Point::move(int dx, int dy);\n//等价于\nvoid Point::move(Point *this, int dx, int dy);\n```\n\n当调用成员函数时, 对象的地址会自动作为 `this`参数传递.\n\n\n\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 `this`:\n\ne.g\n\n```cpp\nclass Point {\nprivate:\n    int x, y;\n    \npublic:\n    // 移动点的位置\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n    \n    // 打印点的坐标\n    void print() {\n        std::cout << \"Point at (\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    // 组合以上两个功能的函数\n    void move_and_print(int dx, int dy) {\n        move(dx, dy);  // 等同于 this->move(dx, dy)\n        print();       // 等同于 this->print()\n    }\n};\n```\n\n> 但是也可以显式指定 `this->move`, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n\n\n### 封装特性\n\n在OOP中, Object = Attributes + Services, 即数据和操作被**封装**在一起, 构成一个完整的对象.\n\n\n\n### 声明与定义\n\n我们应当在头文件中声明对象的成员及其 `public`,`private`和 `protected`等属性, 并且在 `cpp`文件中给出具体的定义:\n\n> 最好为每个类都建立如此对应的头文件和源文件 `cpp`.\n\ne.g. \n\n```cpp\n// Student.h - 类的声明\n#ifndef STUDENT_H\n#define STUDENT_H\n\n#include <string>\nusing namespace std;  // 在头文件中使用\n\nclass Student {\nprivate:\n    // 数据成员\n    string name;     // 不再需要 std:: 前缀\n    int id;\n    float gpa;\n    \npublic:\n    // 构造函数原型\n    Student(const string& name, int id);\n    \n    // 成员函数原型\n    void setName(const string& newName);\n    string getName() const;\n    void calculateGPA();\n    bool isEligibleForScholarship() const;\n};\n\n#endif // STUDENT_H\n\n```\n\n```cpp\n// Student.cpp - 成员函数的定义\n#include \"Student.h\"\nusing namespace std;  // 在源文件中使用\n\n// 构造函数实现\nStudent::Student(const string& name, int id) {\n    this->name = name;\n    this->id = id;\n    this->gpa = 0.0;\n}\n\n// 成员函数实现\nvoid Student::setName(const string& newName) {\n    name = newName;\n}\n\nstring Student::getName() const {\n    return name;\n}\n\nvoid Student::calculateGPA() {\n    // 实现GPA计算逻辑\n    // ...\n}\n\nbool Student::isEligibleForScholarship() const {\n    return gpa >= 3.5;\n}\n```\n\n> ` Student::getName() `指的就是类 `Student`中的成员函数 `getName()`.\n\n\n\n具体来说, `.h`头文件当中应该有:\n\n- 外部变量的声明\n  e.g. `extern int globalCounter;  // 仅声明，不定义`\n\n- 函数原型\n  e.g. `int calculateSum(int a, int b);  // 函数声明，不包含实现`\n\n- 类/结构体的声明\n  e.g.\n\n  ```cpp\n  class Student;  // 前向声明\n  \n  // 或完整类声明（不含成员函数定义）\n  class Rectangle {\n  private:\n      double width;\n      double height;\n  public:\n      Rectangle(double w, double h);\n      double getArea() const;\n  };\n  ```\n\n\n\n回顾 `#include`: 将被引用的文件插入 `.cpp` 文件当中\n\n- `#include \"xx.h\"`: 首先在当前目录下寻找;\n\n- `#include <xx.h>`: 直接在指定的目录中寻找\n\n  > 等价于 `#include <xx>`.\n\n\n\n为了避免在多个 `.cpp` 文件中重复引用相同的头文件, 可以通过 `#ifndef`等标记来判断是否需要引用当前的头文件:\n\n```cpp\n#ifndef HEADER_FLAG\n#define HEADER_FLAG\n\n#endif \n```\n\n> `HEADER_FLAG`一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n\n```cpp\n// 文件: vector.h\n#ifndef VECTOR_H\n#define VECTOR_H\n// ...\n#endif // VECTOR_H\n```\n\n## 生命周期管理\n\n当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n\n为了确保这些工作不被遗忘, `cpp`的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n\n### 构造函数\n\n构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n- 语法: \n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName();\n    \n    // 带参数的构造函数\n    ClassName(参数列表);\n    \n    // 拷贝构造函数\n    ClassName(const ClassName& other);\n    \n};\n```\n\n> 1. **默认构造函数**：不带参数或所有参数都有默认值;\n> 2. **带参数的构造函数**：接受一个或多个参数;\n> 3. **拷贝构造函数**：从同类型的另一个对象创建新对象.\n\n\n\n- 构造函数初始化列表\n\n  ```cpp\n  Point::Point(int xx, int yy) :x(xx), y(yy) {\n    ...\n  }\n  ```\n\n  > 构造函数时, 传递参数并直接赋值给内部的成员变量 `x` , `y`.\n\n\n\n- 结构体中的构造函数:\n\n  ```cpp\n  struct Y { \n      float f;     // 浮点型成员变量\n      int i;       // 整型成员变量\n      Y(int a);    // 声明了一个接受int参数的构造函数\n  };\n  ```\n\n  > 1. 此处只是声明了构造函数需要 `int a`作为参数, 但是没有给出具体的实现;\n  > 2. 声明结构体对象 e.g. `Y y1[] = { Y(1), Y(2), Y(3) };`\n\n\n\n### 默认构造\n\n`auto` default constructor: 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数:\n\n- 对于成员变量: 不进行初始化;\n\n### 析构函数\n\n析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 `~`. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\n\n```cpp\nclass ClassName {\npublic:\n    ~ClassName();\n};\n```\n\n\n\n运用的示例:\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nclass MyString {\nprivate:\n    char* data;\n\npublic:\n    // 默认构造函数\n    MyString() : data(nullptr) {\n        std::cout << \"默认构造函数调用\" << std::endl;\n    }\n\n    // 带参数的构造函数\n    MyString(const char* str) {\n        if (str) {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"参数构造函数调用\" << std::endl;\n    }\n\n    // 拷贝构造函数\n    MyString(const MyString& other) {\n        if (other.data) {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"拷贝构造函数调用\" << std::endl;\n    }\n\n    // 析构函数\n    ~MyString() {\n        delete[] data;\n        std::cout << \"析构函数调用\" << std::endl;\n    }\n\n    // 打印字符串\n    void print() const {\n        std::cout << (data ? data : \"空字符串\") << std::endl;\n    }\n};\n\nint main() {\n    // 测试各种构造函数\n    MyString s1;                  // 默认构造函数\n    MyString s2(\"Hello\");         // 带参数的构造函数\n    MyString s3 = s2;             // 拷贝构造函数\n    \n    s1.print();\n    s2.print();\n    s3.print();\n    \n    return 0;  // 所有对象在这里被销毁，调用析构函数\n}\n```\n\n\n\n# 其他\n\n- 使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n  - 另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n\n\n## Includes\n\n### Algorithm\n`copy(first, last, result)`:\n- `fisrt`和`last`是输入迭代器, 表示要复制的范围, 左闭右开即`last`应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\n- `result`是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\n  - e.g.\n    ```cpp\n    std::vector<int> source = {1, 2, 3, 4, 5};\n    std::vector<int> destination(5); // 确保目标容器有足够的空间\n    \n    std::copy(source.begin(), source.end(), destination.begin());\n    \n    for (int num : destination) {\n        std::cout << num << \" \"; // 输出：1 2 3 4 5\n    }\n    std::cout << std::endl;\n    ```\n- `result`可以直接输出到`cout`中.\n    ```cpp\n    vector<int> vec;\n    \n    for(int i = 0; i < 5; i++){\n        vec.push_back(i);\n    }\n    \n    vec.erase(vec.begin()+2); //删除第三个元素\n    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, \",\"));\n    cout << endl;\n    // 0,1,3,4,\n    ```\n\n---\n\n- 数组之间**不可以**直接赋值, 但是字符串可以直接赋值\n```cpp\nchar str1[] = \"Hello\";\nchar str2[] = \"World\";\nstr1 = str2;  // 错误，数组之间不可以直接赋值\n\nstring s1 = \"Hello\";\nstring s2 = \"World\";\ns1 = s2;  // 正确，字符串可以直接赋值\n\n```\n\n\n## 深拷贝\n```cpp\nstring s1 = \"Hello\";\nstring s2 = \"World\";\n\ncout << \"初始状态：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：Hello\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\ns1 = s2;  // 赋值操作\n\ncout << \"赋值后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\n// 修改 s2 不会影响 s1，因为是深拷贝\ns2 = \"Changed\";\ncout << \"修改 s2 后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：Changed\n```\n\n## Temp\n```cpp\n// 迭代器\nI.begin();\nI.end();\n\n// Item Access\nV.front();;\nV.back();\n```\n\n## 区分\n### find\n`find`是字符串类的一种方法, 同时也是标准库`algorithm`中的一个函数.\n- `find`方法: 用于在字符串中查找子字符串的位置。\n```cpp\nstring str = \"Hello World\";\nsize_t pos = str.find(\"World\");\nif (pos != string::npos) {\n    cout << \"Found 'World' at position \" << pos << endl;\n}\n```\n- `algorithm`中的`find`函数: 用于在容器（如数组、向量等）中查找元素。\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main() {\n    vector<int> vec = {1, 2, 3, 4, 5};\n    vector<int>::iterator it = find(vec.begin(), vec.end(), 3);\n    if (it != vec.end()) {\n        cout << \"Found 3 at position \" << distance(vec.begin(), it) << endl;\n    }\n}\n// Found 3 at position 2\n```\n> 编译: `g++ -std=c++11 test.cpp -o test`\n\n### erase\n- 对于字符串的方法: `str.erase(pos, len)`\n  - 删除从指定位置开始的指定个数字符\n```cpp\nstring str = \"Hello World\";\nstr.erase(6, 5);\ncout << str << endl;  // 输出: Hello\n```\n\n---\n\n- 对于容器的方法: `erase(pos1, pos2)`\n  - 左闭右开式删除容器当中的元素.\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5, 6};\n    std::cout << \"Original vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素\n    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]\n\n    std::cout << \"Modified vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl; // 输出 \"1 5 6\"\n\n    return 0;\n}\n```\n\n## 不知道放在哪里的代码块\n```cpp\n#include <iostream>\n#include <list>\nusing namespace std;\n\nint main() {\n// 1. 创建并填充链表\nlist<int> L;                      // 创建一个空的整数链表\nfor(int i=1; i<=5; ++i)          // 循环5次\n    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5\n                                 // 此时链表内容为：1,2,3,4,5\n\n// 2. 删除第二个元素\nL.erase( ++L.begin() );          // L.begin()指向第一个元素\n                                 // ++L.begin()指向第二个元素\n                                 // erase删除迭代器指向的元素\n                                 // 此时链表内容为：1,3,4,5\n\n// 3. 打印链表内容\ncopy(                            // 标准库算法，用于复制序列\n    L.begin(),                   // 源序列的起始位置\n    L.end(),                     // 源序列的结束位置\n    ostream_iterator<int>(       // 输出流迭代器\n        cout,                    // 指定输出到标准输出\n        \",\"                      // 每个元素后面追加的分隔符\n    )\n);\ncout << endl;                    // 换行\n\n}\n```\n\n\n\n# 课堂缓冲区\n\n# 题目梳理\n\n## HW2\n\n![image-20250225160042809](cpp学习记录.assets/image-20250225160042809.png)\n\n- ANS:  B\n- 由于此处的`map`以`char *`作为key, 同时初始化`str`的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n---\n\n![image-20250225160652522](cpp学习记录.assets/image-20250225160652522.png)\n\n- 逗号表达式, 结果为1. \n\n\n\n","source":"_posts/编程语言/cpp学习记录.md","raw":"---\ntitle: cpp学习记录\ndate: 2025-02-14 20:21:21\ntags:\ncategories:\nexcerpt: 一起来学习cpp\nmath: true\n---\n\n编译时, 从`c`的`gcc`转变为了`g++`.\n\n# 基本语法\n在C语言中,我们主要使用`malloc()`和`free()`来进行动态内存管理。但这种方式存在一些问题:\n- 它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n- 容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了`new`和`delete.\n\nnew的基本语法十分直观:\n```cpp\nType* pointer = new Type;           // 分配单个对象\nType* pointer = new Type[size];     // 分配对象数组\n```\n\n可以在创建时进行初始化:\n```cpp\nint* p1 = new int(5);              // 初始化为5\nstring* p2 = new string(\"hello\");   // 初始化为\"hello\"\n```\n\n也可以根据变量进行动态的内存分配:\n```cpp\nint size;\ncin >> size;\nint* arr = new int[size];  // 根据输入分配内存\n```\n\n\n# 输入输出流\n通过包含头文件 -- `#include <iostream>` 来使用输入输出流 `cin` 和 `cout`.\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(){\n    int age; \n    cin >> age;\n    cout << \"You are \" << age << \" years old\" << endl;\n    // endl 是换行符\n    return 0;\n}\n```\n\n- `cin`读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n```cpp\nstring str=\"Hello world!\";\nofstream fout(\"out.txt\");\nfout<<str<<endl;\n\nifstream fin(\"out.txt\");\nstring str1,str2;\n\n// 读取文件中的两个字符串\nfin>>str1>>str2; \n\ncout << str1 << endl << str2 << endl;\n// 输出:\n// Hello\n// world!\n\nreturn 0;\n```\n\n\n## 文件流\n\n### 输入输出流基础\n- 头文件: `#include <fstream>`\n- 类: `ifstream`(输入流), `ofstream`(输出流)\n```cpp\n#include <fstream>  // 需要包含这个头文件\nusing namespace std;\n\n// 文件输出（写入文件）\nofstream outFile(\"output.txt\");\noutFile << \"Hello World\" << endl;\noutFile.close();\n\n// 文件输入（读取文件）\nifstream inFile(\"input.txt\");\nstring line;\ngetline(inFile, line);\ninFile.close();\n```\n  - 写入文件时, 如果没有文件, 会自动创建.\n\n\n### 常用操作示例\n\n1. **写入文件**\n```cpp\nofstream outFile;\noutFile.open(\"test.txt\");  // 打开文件\nif (outFile.is_open()) {   // 检查是否成功打开\n    outFile << \"第一行\" << endl;\n    outFile << \"第二行\" << endl;\n    outFile.close();       // 完成后关闭文件\n}\n```\n\n2. **读取文件**\n```cpp\nifstream inFile(\"test.txt\");\nstring line;\nwhile (getline(inFile, line)) {  // 逐行读取\n    cout << line << endl;\n}\ninFile.close();\n```\n\n3. **以追加模式打开文件**\n```cpp\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式\noutFile << \"这行会被添加到文件末尾\" << endl;\noutFile.close();\n```\n\n\n### 文件打开模式\n\n- `ios::in` - 读取模式\n- `ios::out` - 写入模式\n- `ios::app` - 追加模式\n- `ios::ate` - 打开文件后立即定位到文件末尾\n- `ios::binary` - 二进制模式\n- `ios::trunc` - 如果文件存在则**截断**文件\n  - 如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n```cpp\n// 假设 test.txt 原本内容是:\n// Hello World\n// This is a test\n\n// 使用 trunc 模式打开\nofstream outFile(\"test.txt\", ios::out | ios::trunc);  \noutFile << \"新的内容\" << endl;\noutFile.close();\n\n// 现在 test.txt 的内容只有:\n// 新的内容\n```\n>  或直接用 `ios::out`，因为out默认包含trunc\n\n\n- 使用位或运算符`|`来同时指定多个模式:\n```cpp\n// 组合使用打开模式\nofstream outFile(\"test.txt\", ios::out | ios::app);\n```\n\n### 错误处理\n\n```cpp\nifstream inFile(\"nonexistent.txt\");\nif (!inFile) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n\n// 或者使用is_open()\nif (!inFile.is_open()) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n```\n\n# 变量\n## String\n需要先引入指定的头文件:\n```cpp\n#include <string>\n```\n\n- 定义时可以使用等号或者用括号包裹字符串:\n```cpp\nstring name = \"John\"; \n// string name(\"John\");\n```\n\n---\n\n### stringstream\n`stringstream` 表示**双向**字符串流:\n- 需要导入头文件`#include <sstream>`;\n- `istringstream` 表示**输入**字符串流\n  - 作用: 将字符串转换成一个类似于输入流的对象;\n  - 内部维护了一个字符串和一个位置指针;\n  - 每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n- `ostringstream` 表示**输出**字符串流.\n\n\n#### 字符串分词\n自动以**空白字符**(空格、制表符\\t、换行符\\n等)分割字符串;\n\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string name ( \"Xiao Ming\");\n\n    // 使用括号包字符串\n    istringstream is (name); \n    string s;\n    while (is>>s){\n        cout << s << endl;\n    }\n}\n```\n> `>>` 表示从输入流中读取数据;\n>\n> 注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\n```shell\nXiao Ming\nXiao\nMing\n```\n\n包含更多分词的字符串:\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string words = \"hello \\n world! \\t I am \\n here!\";\n    stringstream is (words);\n    \n    string word;\n    int count  = 1;\n    while(is >> word){\n        cout << \"Word \" << count << \": \" << word << endl;\n        count++;\n    }\n}\n```\nOutput:\n```shell\nWord 1: hello\nWord 2: world!\nWord 3: I\nWord 4: am\nWord 5: here!\n```\n\n#### 字符串拼接\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    string result = oss.str();\n    cout << result << endl;\n}\n```\nOutput:\n```shell\nName: Alice, Age: 25\n```\n> 通过`.str()`方法可以对象转换为字符串类型, 从而**格式化输出**.\n\n<br>\n\n`.str(\"\")`方法可以**清空**字符串流:\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    oss.str(\"\");\n    string result = oss.str();\n    cout << result << \"Nothing\" << endl;\n}\n```\nOutput:\n```shell\nNothing\n```\n\n### Getline\n**基本语法:**\n```cpp\ngetline(istream& is, string& str, char delim = '\\n');\n```\n- `is`: 输入流（通常是cin;\n- `str`: 存储结果的字符串;\n- `delim`: 分隔符, 默认为换行符`\\n`.\n\n**Example**:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string line;\n    \n    cout << \"请输入一行文本：\";\n    getline(cin, line);  // 读取整行，包括空格\n    cout << \"你输入的是：\" << line << endl;\n    \n    // 使用自定义分隔符\n    string data;\n    cout << \"请输入内容（用,分隔）：\";\n    getline(cin, data, ',');  // 读取直到遇到逗号\n    cout << \"读取到逗号前的内容：\" << data << endl;\n}\n```\n\n### cin\n**特点**:\n- 以空白字符（空格、制表符、换行符）为分隔符;\n- **忽略**前导空白字符;\n- 遇到空白字符就停止读取.\n\n\n通常需要与`getchar()`方法配合来清除缓冲区当中的`\\n`字符:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int number;\n    string line;\n    \n    cout << \"输入一个数字：\";\n    cin >> number;\n    \n    //清除输入缓冲区中的换行符\n    getchar(); // or cin.ignore(); \n   \n    cout << \"输入一行文本：\";\n    getline(cin, line);  // 现在可以正确读取整行\n    \n    cout << \"数字：\" << number << endl;\n    cout << \"文本：\" << line << endl;\n}\n```\n> 如果输入`8 \\n`, 则`getchar()`读取空格, 文本为空.\n\n### Alter String\n**outline** 常用的字符串方法(成员函数):\n```cpp\ninsert(size_t pos, const string& s);\nerase (size_t pos = 0, size_tlen = npos);\nappend (const string& str);\nreplace (size_t pos,size_t len,const string& str);\n```\n\n---\n#### 常用方法\n\n- `insert(int pos, string str)` 在指定位置插入字符串\n```cpp\nstring str = \"Hello World\";\n// 在位置5处插入字符串\nstr.insert(5, \" Beautiful\");\ncout << str << endl;  // 结果: \"Hello Beautiful World\"\n\n// 在字符串末尾插入内容\nstr.insert(str.length(), \"!\");\ncout << str << endl;  // 结果: \"Hello Beautiful World!\"\n\n// 插入单个字符（使用string构造）\nstr.insert(0, \">\");\ncout << str << endl;  // 结果: \">Hello Beautiful World!\"\n```\n\n---\n- `erase(int pos, int length)` 删除从指定位置开始的若干个字符\n```cpp\nstring str = \"Hello Beautiful World!\";\n\n// 删除从下标6开始的9个字符\nstr.erase(6, 9); \ncout << str << endl;  // 结果: \"Hello World!\"\n\n// 删除从某个位置开始到末尾的所有字符\nstr.erase(5);\ncout << str << endl;  // 结果: \"Hello\"\n```\n> `length`参数省略, 则删除从`pos`位置开始到字符串末尾的所有字符.\n\n\n---\n\n- `replace (int pos, int length, string)` 替换指定位置的字符串\n```cpp\n// 从位置6开始，替换5个字符为\"C++\"\nstring str = \"Hello World!\";\nstr.replace(6, 5, \"C++\");\ncout << str << endl;  // 结果: \"Hello C++!\"\n```\n\n\n---\n\n\n- `append (const string& str);`\n```cpp\n// 添加整个字符串\nstring1.append(string2);\n\n// 添加指定位置的字符(索引从开始)\nstring1.append(string2, start, length);\n\n// 重复字符的添加\nstring1.append(count, char);\n\n```\n\n除此之外, 还存在着使用$\\underline{迭代器}$的用法: \n> 类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string source = \"World!\";\n    string target = \"Hello \";\n    \n    // 添加source中的部分字符（从开始到结束）\n    target.append(source.begin(), source.end());\n    cout << target << endl;  // 输出: Hello World!\n    \n    // 只添加部分字符\n    string target2 = \"Hello \";\n    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"\n    cout << target2 << endl;  // 输出: Hello World\n    \n    return 0;\n}\n```\n1. `begin()`方法返回字符串的第一个字符的迭代器, `end()`方法返回字符串最后一个字符的**下一个**位置的迭代器;\n2. 迭代器的范围是**左闭右开**.\n\n---\n\n#### 其他方法\n\n- `find(string, int pos)` 寻找指定的字符串位置\n```cpp\nstring str = \"Hello World Hello\";\n// 从位置0开始查找\"Hello\"\ncout << str.find(\"Hello\", 0) << endl;     // 结果: 0\n// 从位置1开始查找\"Hello\"\ncout << str.find(\"Hello\", 1) << endl;     // 结果: 12\n// 查找不存在的字符串\ncout << str.find(\"Python\") << endl;       // 结果: string::npos\n```\n  - `string::npos`是`size_t`类型的最大值;\n  - 可以使用`str.find(\"Python\") == string::npos`作为判断条件, 检查是否找到字符串.\n\n---\n\n- `compare(string)` 字符串比较\n```cpp\nstring str1 = \"Hello\";\nstring str2 = \"Hello\";\nstring str3 = \"World\";\n\ncout << str1.compare(str2) << endl;  // 结果: 0  (相等)\ncout << str1.compare(str3) << endl;  // 结果: -15 (str1 < str3) \ncout << str3.compare(str1) << endl;  // 结果: 15  (str3 > str1)\n```\n  - 按照字典序比较得到结果\n\n---\n\n- `to_string(int)` 将数字转换成字符串\n```cpp\nint num = 123;\nstring str = to_string(num);\ncout << str << endl;          // 结果: \"123\"\ncout << str + \"456\" << endl;  // 结果: \"123456\"\n```\n  - 字符串之间可以通过`+`直接拼接.\n\n---\n\n- `stoi(string)` 将字符串转换成整数\n```cpp\nstring str = \"123\";\nint num = stoi(str);\ncout << num + 456 << endl;    // 结果: 579\n// 注意：字符串必须是合法的数字格式\n// string str = \"abc\"; \n// int num = stoi(str);  // 这会抛出异常\n```\n  - 字符串必须是合法的数字格式;\n  - ` int num = stoi(\"abc\");`  将会抛出异常\n\n---\n\n### 构造函数\n**Outline:**\n```cpp\nstring(const char *cp, int len);\nstring(const string& s2, int pos);\nstring(const string& s2, int pos, int len);\n```\n\n---\n\n- `string(const char *cp, int len)` 字符数组创建字符串\n```cpp\nstring str1(\"Hello World\", 5);\ncout << str1 << endl;\n// 输出: Hello\n```\n\n- `string(const string& s2, int pos)` 从现有字符串创建新字符串，从指定位置到末尾\n```cpp\nstring s2 = \"Hello World\";\nstring str2(s2, 6);\ncout << str2 << endl;\n// 输出: World\n```\n\n- `string(const string& s2, int pos, int len)` 从现有字符串创建新字符串，指定起始位置和长度\n```cpp\nstring s3 = \"Hello World\";\nstring str3(s3, 6, 3);\ncout << str3 << endl;\n// 输出: Wor\n```\n\n- `string(int length, char c)` 用指定长度的字符c初始化字符串\n```cpp\nstring str4(5, '*');\ncout << str4 << endl;\n// 输出: *****\n\n// 实际应用示例\nint num = 432;\nstring str = to_string(num);\ncout << string(5 - str.length(), '0') + str << endl;\n// 输出: 00432\n```\n\n\n### 成员函数\n\n```cpp\n// 提取子字符串\nsubstr(int pos, int len);\nstring str = \"Hello World\";\nstring sub = str.substr(6, 3);  // 结果: \"Wor\"\n```\n\n```cpp\n// 字符串赋值\nassign();\nstring str1 = \"Hello\";\nstring str2;\nstr2.assign(str1);  // str2现在是 \"Hello\"\n```\n\n\n```cpp\n// 在指定位置插入字符串\n    string str1 = \"hello\";\n    string str2 = \"world\";\n    str1.insert(3, str2);\n    cout << str1 << endl;\n// 结果: helworldlo \n```\n\n```cpp\n// 删除指定位置的指定长度的字符\nerase(int pos, int len);\nstring str = \"Hello World\";\nstr.erase(5, 6);  // 结果: \"Hello\"\n```\n\n**Notice：**\n1. 所有位置索引都是从0开始计数\n2. 如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n3. 使用这些函数时要注意检查参数的有效性，避免越界访问\n\n---\n### Substr\n在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. `substr()`方法可以精确地获取字符串片段.\n\n`substr`即substring的缩写, 表示子字符串.\n\n**基本语法**\n```cpp\nstring substr(int pos, int len) ;\n```\n参数分别表示截取的起始下标以及要截取的长度(如果省略`len`将截取到字符串的末尾).\n\n**e.g.**:\n```cpp\nstring email = \"user.name@example.com\";\n\n// 获取用户名的部分\nint atPos = email.find('@');\nstring username = email.substr(0, atPos); // result: \"user.name\"\n\n// 获取域名部分\nstring domain =  email.substr(atPos + 1); // result: \"example.com\"\n\n// 获取顶级域名(最后一个.之后的部分)\nint lastDotPos = email.rfind('.');\nstring topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n```\n- `rfind()`方法: 会从字符串的**末尾向前**搜索，从而返回要查找的字符或子字符串最后一次出现的位置。如果没有找到，则返回 string::npos。\n\n---\n\n# Group\n**选择的标准:**\n- 一般情况 $\\Rightarrow$ `vector`;\n- 程序需要对元素进行**随机访问** $\\Rightarrow$ `vector` or `deque`;\n- 程序需要在容器**中间插入**元素 $\\Rightarrow$ `list` or `forward_list`;\n- 程序需要在容器的**首尾插入**元素 $\\Rightarrow$ `deque`;\n- 容器中的元素**相对较小**但是数量较多 $\\nRightarrow$ `list` nor `forward_list`.\n  - 否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n## Vector\n\n存储元素在**连续的内存空间**中, 支持**随机访问**.\n- 可以动态增长, 适合存储**未知数量**的元素;\n- 通过下标访问元素的时间复杂度为 O(1);\n- 在末尾插入和删除元素的时间复杂度为 O(1);\n- 在中间插入和删除元素的时间复杂度为 O(n);\n- **使用场景**: 需要随机访问、排序、内存连续存储的场景.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器:\n  ```c++\n  auto it = find(vec.begin(), vec.end(), value);  // 查找 value\n    if (it != vec.end()) {         // 如果找到了（即没有返回 end()）\n        vec.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用 `.push_back()`在末尾插入元素, 或者使用`.emplace_back()`在末尾原位构造元素(更加高效);\n  ```c++\n  vec.push_back(10);\n  vec.emplace_back(20); //更加高效\n  ```\n  > `emplace_back`方法**直接**在容器的**内存空间中构造**对象, 相比于`push_back`而言更加**高效**.\n- `.erase()`方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  \n    ```c++\n     vec.erase(vec.begin() + 1);       // 删除第二个元素\n     vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素\n     vec.clear();                      // 清空整个 vector\n    ```\n    > `vec.clear();` 将会清空整个vector.\n    >\n    > 和`insert`需要的参数一样, 都需要**迭代器**而非索引来定位.\n- `vec[i]`的形式访问, 使用`vec.at(i)`的方式可以在越界时抛出异常;\n- `.begin()`和`.end()`获取迭代器, 使用范围for循环遍历元素;\n    ```c++\n     cout << \"Vector elements:\" << endl;\n     for (int num : vec) {\n        cout << num << \" \";\n     }\n     cout << endl;\n    \n    //使用迭代器遍历\n    for (auto it = vec.begin(); it != vec.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n    ```\n- `.size()`获取`vector`的大小, `.empty()`判断`vector`是否为空;\n  ```c++\n  cout << \"Vector size: \" << vec.size() << endl;\n  if (vec.empty()) {\n      cout << \"Vector is empty.\" << endl;\n  }\n  ```\n- 使用`sort()`对`vector`进行排序, 使用`find()`查找元素;\n  ```c++\n  sort(vec.begin(), vec.end());   // 排序\n  auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n  ```\n\n### Reserve\n为了避免频繁地扩展内存, 可以通过`reserve`预先分配合适的空间, 同时通过`.reszie()`调整大小;\n```cpp\nvector<string> v2;\nv2.reserve(1000);  // 一次性分配 1000 个元素的空间\n\nv2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n```\n\n`reserve`只分配空间而不创建元素,`resize`将同时分配元素(默认值):\n\n```cpp\nvector<string> vec;\n// reserve: 只分配空间，不创建元素\nvec.reserve(10);  \ncout << \"The capacity with reserve: \" << vec.capacity() << endl;\ncout << \"The size with reserve: \" << vec.size() << endl;    \n\n// resize: 分配空间并创建元素\nvec.resize(10);   \ncout << \"The capacity with resize: \" << vec.capacity() << endl;\ncout << \"The size with resize: \" << vec.size() << endl;   \n```\n\n**Output**:\n```shell\nThe capacity with reserve: 10\nThe size with reserve: 0\nThe capacity with resize: 10\nThe size with resize: 10\n```\n> [!important]\n>\n> `.push_back()`的实际作用是在容器索引的`size`处插入元素.\n>\n>  而`reserve`不会影响容器的`size`,  初始化和`resize`会影响并且填充默认值:\n\n**e.g.  验证:**\n\n```cpp\nint main() {\n    vector<int> vec(10);\n    \n    // 打印初始状态\n    cout << \"初始状态：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    // 预留5个空间\n    vec.reserve(15);\n    cout << \"reserve(15) 后：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    vec[20] =20;\n\n    // 添加元素并观察\n    cout << \"添加元素过程：\\n\";\n    for(int i = 1; i <= 6; i++) {\n        vec.push_back(i);\n        cout << \"添加 \" << i << \" 后 - \";\n        cout << \"size: \" << vec.size() \n             << \", capacity: \" << vec.capacity()\n             << \", 元素: \";\n        for(int x : vec) cout << x << \" \";\n        cout << \"\\n\";\n    }\n    \n    return 0;\n}\n\n```\n\n**Output:**\n\n```shell\n初始状态：\nsize: 10, capacity: 10\n\nreserve(15) 后：\nsize: 10, capacity: 15\n\n添加元素过程：\n添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 \n添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 \n添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 \n添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 \n添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 \n添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n```\n\n1. 此处的 `vector<int> vec(10);`初始化了10个默认值的`int`类型的元素;\n2. `vec[20] = 20;`没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n   1. 如果换成`vec.at(20) = 20`将会在编译时报错;\n3. 可以发现, `reserve`的作用就是避免了多次自动扩容.\n\n> `reserve`的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\n\n\n## List\n\n- 在`list`容器当中, 迭代器是双向迭代器;\n  - 双向迭代器不支持大小的比较, 只支持 `==`,`!=`,`++`,`--`;\n  因此, 注意实际的使用:\n```cpp\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin();\nlist<int>::iterator iter2 = lst1.end();\n\n// 正确的写法\nwhile (iter1 != iter2) {\n    // 处理当前元素\n    ++iter1;\n}\n\n// 错误的比较\n// while(iter1 < iter2) \n    \n```\n\n### 有序链表\n```cpp\n#include <iostream>\n#include <list>\n#include <string>\n\n\nusing namespace std;\n\nint main() {\n    list<string> s;\n    string str;\n    list<string> :: iterator p;\n    int count ;\n\n    cout << \"enter the number of the strings:\" << endl;\n\n    cin >> count; \n\n\n    for(int i = 0; i < count; i++){\n        cout << \"enter a string:\" ;\n        cin >>str;\n        \n        p = s.begin();\n        while(p != s.end() && *p <str)\n            p++;\n        s.insert(p,str);\n    }\n    for(p = s.begin(); p!=s.end(); p++)\n        cout << *p << endl;\n    cout << endl;\n    return 0;\n}\n```\n\n**分析:**\n- `while(p != s.end() && *p <str)` 每次输入`str`时, 令迭代器从`list`的开头开始, 进行字典序的比较;\n- 找到插入的位置, 利用`insert()`方法插入.\n\n\n\n## Deque\n`deque`即 double-ended queue, **双端队列**.\n\n支持:\n- 在两端快速的插入或删除;\n- 随机访问;\n\n**语法**:\n```cpp\n#include <deque>\ndeque<int> dq;\n\n// 1. 插入操作\ndq.push_back(1);    // 在末尾插入\ndq.push_front(2);   // 在开头插入\ndq.insert(pos, val);// 在指定位置插入\n\n// 2. 删除操作\ndq.pop_back();      // 删除末尾元素\ndq.pop_front();     // 删除首部元素\ndq.erase(pos);      // 删除指定位置元素\n\n// 3. 访问操作\ndq[0];              // 随机访问\ndq.at(1);           // 带边界检查的访问\ndq.front();         // 访问第一个元素\ndq.back();          // 访问最后一个元素\n```\n\n**示例:**\n```cpp\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    deque<int> dq;\n    \n    // 在两端插入元素\n    dq.push_back(3);\n    dq.push_front(1);\n    dq.push_back(4);\n    dq.push_front(8);\n    \n    // dq ：{8, 1, 3, 4}\n    \n    // 使用随机访问\n    for(size_t i = 0; i < dq.size(); ++i) {\n        cout << dq[i] << \" \";\n    }\n\n}\n\n```\n\n### Forward_list\n`forward_list`即 单项链表.\n- 只能向前遍历, 即对应的迭代器不支持`--`而支持`++`.\n- 同时不支持下标访问以及随机访问.\n- 单项链表的设计, 使得内部的每个节点只需要**一个**指针来指向下一个节点, 从而比`list`双向链表更加节省内存.\n\n**语法**:\n```cpp\n#include <forward_list>\nforward_list<int> fl;\n\n// 1. 插入操作\nfl.push_front(1);           // 在开头插入\nfl.insert_after(pos, val);  // 在指定位置之后插入\n\n// 2. 删除操作\nfl.pop_front();            // 删除第一个元素\nfl.erase_after(pos);       // 删除指定位置之后的元素\n\n// 3. 访问操作\nfl.front();               // 访问第一个元素\n\n// 4. 特殊操作\nfl.before_begin();        // 返回第一个元素之前的迭代器\nfl.begin();               // 返回第一个元素的迭代器\n```\n\n**示例**:\n\n```cpp\n#include <forward_list>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    forward_list<int> fl;\n    \n    // 插入元素\n    fl.push_front(3);\n    fl.push_front(2);\n    fl.push_front(1);\n    \n    // 在特定位置后插入\n    auto it = fl.begin(); // 指向第一个元素\n    fl.insert_after(it, 4); // 在第一个元素后插入4\n    \n    // 遍历打印\n    for(const auto& val : fl) {\n        cout << val << \" \";\n    }\n    // 输出：1 4 2 3\n}\n```\n\n#### 访问前一个元素\n由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合`before_begin()`方法.\n\n```cpp\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历\nauto prev = fl.before_begin();\nauto curr = fl.begin();\nwhile(curr != fl.end() && *curr != target) {\n    ++prev;\n    ++curr;\n}\n```\n\n## Map\n作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键**自动排序**\n- 如果插入重复的key, 将会覆盖原有的value;\n- 通过键查找元素、插入和删除的时间复杂度均为O(log n);\n- **使用场景**: 字典、索引、统计等.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于`map`当中;\n  ```cpp\n  auto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"\n    if (it != ages.end()) {         // 如果找到了（即没有返回 end()）\n        ages.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用下标(键)直接插入,或者通过键值对插入\n  ```cpp\n  ages[\"Alice\"] = 25;\n  ages.insert({\"Bob\", 30});\n  ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n  ```\n  > `emplace`方法指**直接**在容器的**内存空间中构造**对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于`insert`而言更加**高效**.\n- `.erase()`方法删除指定key的元素, 也可以通过`.find()`找到key对应的迭代器`it`, 然后`erase(it)`.\n  \n    ```cpp\n    ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素\n    \n    auto it = ages.find(\"Charlie\");\n    if (it != ages.end()) {\n        ages.erase(it);         // 删除迭代器指向的元素\n    }\n    ```\n    > `ages.clear();` 将会清空整个map.\n- `map[key]`的形式访问, 使用`map.at(key)`的方式可以在key不存在时抛出异常;\n- `.find(key)`查找对应键的元素( 返回**迭代器** ), `.count(key)`返回对应键的元素个数(0 or 1)\n- `.size()`获取map的大小.\n- 迭代器的`->first`和`->second`可以分别访问键和值.\n    ```cpp\n     cout << \"Map elements:\" << endl;\n     for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {\n        cout << mapIt->first << \": \" << mapIt->second << endl; // 访问键和值\n     }\n    ```\n\n## Iterator\n迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n- **标记位置**: `.begin()`和`.end()` 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n- 输入迭代器: 支持读取和递增操作;\n  - `istream_iterator`: 用于从输入流读取数据;\n- 输出迭代器: 支持写入和递增操作;\n  - `ostream_iterator`: 用于向输出流写入数据;\n- 前向迭代器: 具有输入、输出迭代器的**所有**功能, 并且可以多次遍历同一个序列;\n  - 比如`forwarf_list`的迭代器:`auto it = flist.begin()` or `forward_list<int>::iterator it = flist.begin()`;\n- 双向迭代器: 在前向迭代器的原有功能上, 同时支持**递减**操作;\n  - 比如双向链表`list`的迭代器.\n    ```cpp\n    #include <iostream>\n    #include <list>\n    using namespace std;\n    \n    int main() {\n        list<int> myList = {10, 20, 30, 40, 50};\n    \n        // 使用双向迭代器正向遍历\n        cout << \"Forward traversal: \";\n        for ( list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {\n            cout << *it << \" \";\n        }\n        cout <<  endl;\n    \n        // 使用双向迭代器逆向遍历\n        cout << \"Reverse traversal: \";\n        for ( list<int>::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {\n            cout << *rit << \" \";\n        }\n        cout <<  endl;\n    \n        return 0;\n        // Forward traversal: 10 20 30 40 50 \n        // Reverse traversal: 50 40 30 20 10 \n    }\n    ```\n    > 1. `reverse_iterator`用于声明逆向遍历的迭代器, 也可以使用`auto`直接声明.\n    > 2. `rbegin()`和`rend()`分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的`++`相当于正向遍历时的`--`操作.\n- 随机访问迭代器: 具有双向迭代器的所有功能, 同时支持**随机访问**, 如`it+n`,`it[n]`.\n  - 比如`vector`的迭代器.\n  ```cpp\n    vector<int> vec = {10, 20, 30, 40, 50};\n    cout << \"Vector elements (random access): \";\n    for (int i = 0; i < vec.size(); ++i) {\n        cout << vec[i] << \" \"; // 使用下标随机访问\n    }\n    cout << endl;\n  ```\n\n另外, 还有一种迭代器称为**插入迭代器**, 比如`back_inserter`\n```cpp\nvector<int> vec = {10, 20, 30, 40, 50};\n\n//结合copy将容器的元素直接插入到另一个容器中\nvector<int> dest = {60,70};\ncopy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素\ncout << \"Copied vector: \";\nfor (int num : dest) {\n    cout << num << \" \";\n}\ncout << endl;\n// Copied vector: 60 70 10 20 30 40 50 \n```\n\n## for-each\nfor-each 循环的语法：\n```cpp\nfor (range_declaration : range_expression) {\n    loop_statement;\n}\n```\n- range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 `auto `关键字让编译器自动推导类型;\n- range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或**字符串**;\n- loop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // 使用 for-each 循环遍历 vector\n    for (int num : numbers) {\n        std::cout << num << \" \"; // 输出每个元素\n    }\n    std::cout << std::endl;\n\n    // 使用 auto 关键字自动推导类型\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // 修改容器中的元素（需要使用引用）\n    for (int &num : numbers) {\n        num *= 2; // 将每个元素乘以 2\n    }\n\n    // 输出修改后的元素\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n- `for (int &num : numbers)`：使用引用 &，可以直接修改容器中的元素.\n\n### Map的循环\n当range_expression是`map`时, 可以使用`auto`自动推导range_declaration的类型.需要注意是:\n- 用迭代器的方式访问`map`中的键值对的性质是 `it->first`与`it->second`;\n- 在`for-each`循环当中, range_declaration是一个值, 因此使用`.first`与`.second`来访问键和值.\n    ```cpp\n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <string>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int main(){\n        map<string, string> m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};\n        vector<string> vec;\n    \n        for(auto& entry : m){\n            vec.push_back(entry.first + \":\" + entry.second );\n        }\n        copy(vec.begin(), vec.end(), ostream_iterator<string>(cout, \" \"));\n    }\n    ```\n    **Output:**\n    ```shell\n    one:1 three:3 two:2\n    ```\n> 此处由于`map`自动按照键的字典序进行排序, 因此输出时`three`的元素在`two`前;\n\n在上述的示例中, 也可以使用下面的方式进行`vec`的输出:\n```cpp\nfor(const auto& s : vec) {\n    cout << s << \" \";\n}\n```\n此时`auto`会自动推导为`string`类型, 且`&`对数组的元素进行了引用, 使得输出更加高效.\n\n### Pro&Con\n`for-each`循环的优点:\n- 消除了访问数组等越界的风险;\n- 不需要事先初始化迭代器;\n\n`for-each`循环的缺点:\n- 无法获取元素的索引;\n- 只能顺序地遍历.\n\n## typedef\n我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\n```cpp\ntypedef old_type new_type;\n```\n\n## Notices\n1. 直接对数组、字符串和`vector`进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n2. 对于`vector`, 可以通过`.at() = `的方式进行安全访问, 编译器会进行边界检查. 或者通过`.push_back()` or `.emplace_back`的方式在末尾赋值. 同时注意用`.reserve()`预先分配充分的内存空间.\n3. 避免不经意地向`map`当中插入元素:\n   1. 错误的示范:\n    ```cpp\n    if(foo[\"bob\"] == 1){...}\n    ```\n   2. 使用`.count()`方法正确检查元素是否存在:\n    ```cpp\n    if( foo.count(\"bob\") ){...}\n    ```\n   3. 也可以使用`find()`方法检查元素是否存在:\n   ```cpp\n    auto it = m.find(\"four\");\n   \n    if(it  != m.end()){\n        cout << it->second << endl;\n    }\n    else{\n        cout << \"Not found\" << endl;\n    }\n   ```\n4. 使用`.empty()`方法来检查容器**整体是否为空**, 而非`.count() == 0`的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n5. `erase()` 方法会返回**指向**被删除元素的**下一个**元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n   \n    ```cpp\n    //Initialize a list\n    list<int> L;\n    list<int>::iterator li = L.begin();\n    \n    // Wrong:\n    L.erase(li);    // 删除元素后，li 变成了无效迭代器\n    ++li;           // 错误, 不能对无效迭代器进行操作\n    \n    // Correct:\n    li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n    ```\n\n# 指针\n- Pointers to Objects\n```cpp\nstring str = \"hello\";\nstring *p = &str;\n```\n\n- Oprators with Pointers\n  - `&`: 取地址;\n  - `*`: 解引用;\n  - `->`: 用于访问对象的成员.\n```cpp\n(*p).length();\n// 等价于\np->length();\n```\n> `length()`即为`string`类的成员函数, 因此可以用`->`来访问.\n\n\n# 常量\n\n## 指针\n> 以`char`为例.\n\n- 常量指针 `char * const p`\n  - 地址是`const`类型, 无法赋予`p`新的地址;\n  - 但是可以改变指针指向对象的值.\n- 指针常量 `char const * p`\n  - 指针指向的值无法改变;\n  - 但是可以改变指针的值(指向的对象).\n  如果需要同时保证地址和值都无法改变, 则需要使用`const char * const p`.\n\ne.g:\n```cpp\nint a = 10;\nint b = 20;\nconst int *p = &a;  // 常量指针\nint const *p = &a;  // 指针常量\nint const * const p = &a;  // 常量指针常量\n// 错误示例\n// p = &b;  // 常量指针的值无法改变\n// *p = 30;  // 指针指向的值无法改变\n// 正确示例\nint c = 30;\np = &c;  // 常量指针的值可以改变\n*p = 40;  // 指针指向的值可以改变\n```\n> to be checked.\n\n\n\n\n\n如果`sp`是指向字符串的指针, 那么这两种的写法是等价的, 注意`.`的优先级高于`*`, 因此括号不可忽略.\n\n```cpp\nsp->length();\n(*sp).length();\n```\n\n\n\n# Class\n\n### `::`\n\n`::` resolver: 作用域解析运算符\n\n- 作用: \n\n  - 访问全局的作用域\n    当局部变量和全局变量同名时, 可以使用 `::` 来访问全局变量\n\n    ```cpp\n    int value = 10; // 全局变量\n    \n    void function() {\n        int value = 20; // 局部变量\n        cout << value;    // 输出 20（局部变量）\n        cout << ::value;  // 输出 10（全局变量）\n    }\n    ```\n\n  - 访问命名空间中的成员\n\n    ```cpp\n    namespace Math {\n        const double PI = 3.14159;\n    }\n    \n    double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n    ```\n\n- 语法:\n\n  - `<class_name> :: <function_name>`\n  - `::<function_name>`\n\n\n\ne.g. \n\n```cpp\nvoid S::f() {\n    ::f();  // Would be recursive otherwise!\n    ::a++;  // Select the global a\n    a--;    // The a at class scope\n}\n```\n\n> `S::f()`: 定义了属于类S的成员函数f;\n>\n> `::f()`:表示调用全局作用域中的函数 `f()`, 默认为递归调用当前的成员函数;\n>\n> `::a++`表示将全局作用域的 `a` 自增, `a--`则访问并递减类作用域中的成员变量 `a`.\n\n\n\n### `this`\n\n`this`指针是成员函数的隐藏参数. 指向**当前对象的实例**.\n\n```cpp\nvoid Point::move(int dx, int dy);\n//等价于\nvoid Point::move(Point *this, int dx, int dy);\n```\n\n当调用成员函数时, 对象的地址会自动作为 `this`参数传递.\n\n\n\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 `this`:\n\ne.g\n\n```cpp\nclass Point {\nprivate:\n    int x, y;\n    \npublic:\n    // 移动点的位置\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n    \n    // 打印点的坐标\n    void print() {\n        std::cout << \"Point at (\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    // 组合以上两个功能的函数\n    void move_and_print(int dx, int dy) {\n        move(dx, dy);  // 等同于 this->move(dx, dy)\n        print();       // 等同于 this->print()\n    }\n};\n```\n\n> 但是也可以显式指定 `this->move`, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n\n\n### 封装特性\n\n在OOP中, Object = Attributes + Services, 即数据和操作被**封装**在一起, 构成一个完整的对象.\n\n\n\n### 声明与定义\n\n我们应当在头文件中声明对象的成员及其 `public`,`private`和 `protected`等属性, 并且在 `cpp`文件中给出具体的定义:\n\n> 最好为每个类都建立如此对应的头文件和源文件 `cpp`.\n\ne.g. \n\n```cpp\n// Student.h - 类的声明\n#ifndef STUDENT_H\n#define STUDENT_H\n\n#include <string>\nusing namespace std;  // 在头文件中使用\n\nclass Student {\nprivate:\n    // 数据成员\n    string name;     // 不再需要 std:: 前缀\n    int id;\n    float gpa;\n    \npublic:\n    // 构造函数原型\n    Student(const string& name, int id);\n    \n    // 成员函数原型\n    void setName(const string& newName);\n    string getName() const;\n    void calculateGPA();\n    bool isEligibleForScholarship() const;\n};\n\n#endif // STUDENT_H\n\n```\n\n```cpp\n// Student.cpp - 成员函数的定义\n#include \"Student.h\"\nusing namespace std;  // 在源文件中使用\n\n// 构造函数实现\nStudent::Student(const string& name, int id) {\n    this->name = name;\n    this->id = id;\n    this->gpa = 0.0;\n}\n\n// 成员函数实现\nvoid Student::setName(const string& newName) {\n    name = newName;\n}\n\nstring Student::getName() const {\n    return name;\n}\n\nvoid Student::calculateGPA() {\n    // 实现GPA计算逻辑\n    // ...\n}\n\nbool Student::isEligibleForScholarship() const {\n    return gpa >= 3.5;\n}\n```\n\n> ` Student::getName() `指的就是类 `Student`中的成员函数 `getName()`.\n\n\n\n具体来说, `.h`头文件当中应该有:\n\n- 外部变量的声明\n  e.g. `extern int globalCounter;  // 仅声明，不定义`\n\n- 函数原型\n  e.g. `int calculateSum(int a, int b);  // 函数声明，不包含实现`\n\n- 类/结构体的声明\n  e.g.\n\n  ```cpp\n  class Student;  // 前向声明\n  \n  // 或完整类声明（不含成员函数定义）\n  class Rectangle {\n  private:\n      double width;\n      double height;\n  public:\n      Rectangle(double w, double h);\n      double getArea() const;\n  };\n  ```\n\n\n\n回顾 `#include`: 将被引用的文件插入 `.cpp` 文件当中\n\n- `#include \"xx.h\"`: 首先在当前目录下寻找;\n\n- `#include <xx.h>`: 直接在指定的目录中寻找\n\n  > 等价于 `#include <xx>`.\n\n\n\n为了避免在多个 `.cpp` 文件中重复引用相同的头文件, 可以通过 `#ifndef`等标记来判断是否需要引用当前的头文件:\n\n```cpp\n#ifndef HEADER_FLAG\n#define HEADER_FLAG\n\n#endif \n```\n\n> `HEADER_FLAG`一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n\n```cpp\n// 文件: vector.h\n#ifndef VECTOR_H\n#define VECTOR_H\n// ...\n#endif // VECTOR_H\n```\n\n## 生命周期管理\n\n当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n\n为了确保这些工作不被遗忘, `cpp`的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n\n### 构造函数\n\n构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n- 语法: \n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName();\n    \n    // 带参数的构造函数\n    ClassName(参数列表);\n    \n    // 拷贝构造函数\n    ClassName(const ClassName& other);\n    \n};\n```\n\n> 1. **默认构造函数**：不带参数或所有参数都有默认值;\n> 2. **带参数的构造函数**：接受一个或多个参数;\n> 3. **拷贝构造函数**：从同类型的另一个对象创建新对象.\n\n\n\n- 构造函数初始化列表\n\n  ```cpp\n  Point::Point(int xx, int yy) :x(xx), y(yy) {\n    ...\n  }\n  ```\n\n  > 构造函数时, 传递参数并直接赋值给内部的成员变量 `x` , `y`.\n\n\n\n- 结构体中的构造函数:\n\n  ```cpp\n  struct Y { \n      float f;     // 浮点型成员变量\n      int i;       // 整型成员变量\n      Y(int a);    // 声明了一个接受int参数的构造函数\n  };\n  ```\n\n  > 1. 此处只是声明了构造函数需要 `int a`作为参数, 但是没有给出具体的实现;\n  > 2. 声明结构体对象 e.g. `Y y1[] = { Y(1), Y(2), Y(3) };`\n\n\n\n### 默认构造\n\n`auto` default constructor: 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数:\n\n- 对于成员变量: 不进行初始化;\n\n### 析构函数\n\n析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 `~`. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\n\n```cpp\nclass ClassName {\npublic:\n    ~ClassName();\n};\n```\n\n\n\n运用的示例:\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nclass MyString {\nprivate:\n    char* data;\n\npublic:\n    // 默认构造函数\n    MyString() : data(nullptr) {\n        std::cout << \"默认构造函数调用\" << std::endl;\n    }\n\n    // 带参数的构造函数\n    MyString(const char* str) {\n        if (str) {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"参数构造函数调用\" << std::endl;\n    }\n\n    // 拷贝构造函数\n    MyString(const MyString& other) {\n        if (other.data) {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"拷贝构造函数调用\" << std::endl;\n    }\n\n    // 析构函数\n    ~MyString() {\n        delete[] data;\n        std::cout << \"析构函数调用\" << std::endl;\n    }\n\n    // 打印字符串\n    void print() const {\n        std::cout << (data ? data : \"空字符串\") << std::endl;\n    }\n};\n\nint main() {\n    // 测试各种构造函数\n    MyString s1;                  // 默认构造函数\n    MyString s2(\"Hello\");         // 带参数的构造函数\n    MyString s3 = s2;             // 拷贝构造函数\n    \n    s1.print();\n    s2.print();\n    s3.print();\n    \n    return 0;  // 所有对象在这里被销毁，调用析构函数\n}\n```\n\n\n\n# 其他\n\n- 使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n  - 另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n\n\n## Includes\n\n### Algorithm\n`copy(first, last, result)`:\n- `fisrt`和`last`是输入迭代器, 表示要复制的范围, 左闭右开即`last`应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\n- `result`是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\n  - e.g.\n    ```cpp\n    std::vector<int> source = {1, 2, 3, 4, 5};\n    std::vector<int> destination(5); // 确保目标容器有足够的空间\n    \n    std::copy(source.begin(), source.end(), destination.begin());\n    \n    for (int num : destination) {\n        std::cout << num << \" \"; // 输出：1 2 3 4 5\n    }\n    std::cout << std::endl;\n    ```\n- `result`可以直接输出到`cout`中.\n    ```cpp\n    vector<int> vec;\n    \n    for(int i = 0; i < 5; i++){\n        vec.push_back(i);\n    }\n    \n    vec.erase(vec.begin()+2); //删除第三个元素\n    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, \",\"));\n    cout << endl;\n    // 0,1,3,4,\n    ```\n\n---\n\n- 数组之间**不可以**直接赋值, 但是字符串可以直接赋值\n```cpp\nchar str1[] = \"Hello\";\nchar str2[] = \"World\";\nstr1 = str2;  // 错误，数组之间不可以直接赋值\n\nstring s1 = \"Hello\";\nstring s2 = \"World\";\ns1 = s2;  // 正确，字符串可以直接赋值\n\n```\n\n\n## 深拷贝\n```cpp\nstring s1 = \"Hello\";\nstring s2 = \"World\";\n\ncout << \"初始状态：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：Hello\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\ns1 = s2;  // 赋值操作\n\ncout << \"赋值后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\n// 修改 s2 不会影响 s1，因为是深拷贝\ns2 = \"Changed\";\ncout << \"修改 s2 后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：Changed\n```\n\n## Temp\n```cpp\n// 迭代器\nI.begin();\nI.end();\n\n// Item Access\nV.front();;\nV.back();\n```\n\n## 区分\n### find\n`find`是字符串类的一种方法, 同时也是标准库`algorithm`中的一个函数.\n- `find`方法: 用于在字符串中查找子字符串的位置。\n```cpp\nstring str = \"Hello World\";\nsize_t pos = str.find(\"World\");\nif (pos != string::npos) {\n    cout << \"Found 'World' at position \" << pos << endl;\n}\n```\n- `algorithm`中的`find`函数: 用于在容器（如数组、向量等）中查找元素。\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main() {\n    vector<int> vec = {1, 2, 3, 4, 5};\n    vector<int>::iterator it = find(vec.begin(), vec.end(), 3);\n    if (it != vec.end()) {\n        cout << \"Found 3 at position \" << distance(vec.begin(), it) << endl;\n    }\n}\n// Found 3 at position 2\n```\n> 编译: `g++ -std=c++11 test.cpp -o test`\n\n### erase\n- 对于字符串的方法: `str.erase(pos, len)`\n  - 删除从指定位置开始的指定个数字符\n```cpp\nstring str = \"Hello World\";\nstr.erase(6, 5);\ncout << str << endl;  // 输出: Hello\n```\n\n---\n\n- 对于容器的方法: `erase(pos1, pos2)`\n  - 左闭右开式删除容器当中的元素.\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5, 6};\n    std::cout << \"Original vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素\n    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]\n\n    std::cout << \"Modified vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl; // 输出 \"1 5 6\"\n\n    return 0;\n}\n```\n\n## 不知道放在哪里的代码块\n```cpp\n#include <iostream>\n#include <list>\nusing namespace std;\n\nint main() {\n// 1. 创建并填充链表\nlist<int> L;                      // 创建一个空的整数链表\nfor(int i=1; i<=5; ++i)          // 循环5次\n    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5\n                                 // 此时链表内容为：1,2,3,4,5\n\n// 2. 删除第二个元素\nL.erase( ++L.begin() );          // L.begin()指向第一个元素\n                                 // ++L.begin()指向第二个元素\n                                 // erase删除迭代器指向的元素\n                                 // 此时链表内容为：1,3,4,5\n\n// 3. 打印链表内容\ncopy(                            // 标准库算法，用于复制序列\n    L.begin(),                   // 源序列的起始位置\n    L.end(),                     // 源序列的结束位置\n    ostream_iterator<int>(       // 输出流迭代器\n        cout,                    // 指定输出到标准输出\n        \",\"                      // 每个元素后面追加的分隔符\n    )\n);\ncout << endl;                    // 换行\n\n}\n```\n\n\n\n# 课堂缓冲区\n\n# 题目梳理\n\n## HW2\n\n![image-20250225160042809](cpp学习记录.assets/image-20250225160042809.png)\n\n- ANS:  B\n- 由于此处的`map`以`char *`作为key, 同时初始化`str`的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n---\n\n![image-20250225160652522](cpp学习记录.assets/image-20250225160652522.png)\n\n- 逗号表达式, 结果为1. \n\n\n\n","slug":"编程语言/cpp学习记录","published":1,"updated":"2025-02-28T07:10:32.491Z","_id":"cm79tw4w00025dwqggdbu6x9p","comments":1,"layout":"post","photos":[],"content":"<p>编译时, 从<code>c</code>的<code>gcc</code>转变为了<code>g++</code>.</p>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>在C语言中,我们主要使用<code>malloc()</code>和<code>free()</code>来进行动态内存管理。但这种方式存在一些问题:</p>\n<ul>\n<li>它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;</li>\n<li>容易发生内存泄漏.</li>\n</ul>\n<p>为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了<code>new</code>和`delete.</p>\n<p>new的基本语法十分直观:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">Type* pointer = <span class=\"hljs-keyword\">new</span> Type;           <span class=\"hljs-comment\">// 分配单个对象</span><br>Type* pointer = <span class=\"hljs-keyword\">new</span> Type[size];     <span class=\"hljs-comment\">// 分配对象数组</span><br></code></pre></td></tr></table></figure></p>\n<p>可以在创建时进行初始化:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span>* p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">5</span>);              <span class=\"hljs-comment\">// 初始化为5</span><br>string* p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);   <span class=\"hljs-comment\">// 初始化为&quot;hello&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p>也可以根据变量进行动态的内存分配:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> size;<br>cin &gt;&gt; size;<br><span class=\"hljs-type\">int</span>* arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size];  <span class=\"hljs-comment\">// 根据输入分配内存</span><br></code></pre></td></tr></table></figure></p>\n<h1 id=\"输入输出流\"><a href=\"#输入输出流\" class=\"headerlink\" title=\"输入输出流\"></a>输入输出流</h1><p>通过包含头文件 — <code>#include &lt;iostream&gt;</code> 来使用输入输出流 <code>cin</code> 和 <code>cout</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> age; <br>    cin &gt;&gt; age;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;You are &quot;</span> &lt;&lt; age &lt;&lt; <span class=\"hljs-string\">&quot; years old&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-comment\">// endl 是换行符</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>cin</code>读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str=<span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">fout</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;out.txt&quot;</span>)</span></span>;<br>fout&lt;&lt;str&lt;&lt;endl;<br><br><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">fin</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;out.txt&quot;</span>)</span></span>;<br>string str1,str2;<br><br><span class=\"hljs-comment\">// 读取文件中的两个字符串</span><br>fin&gt;&gt;str1&gt;&gt;str2; <br><br>cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出:</span><br><span class=\"hljs-comment\">// Hello</span><br><span class=\"hljs-comment\">// world!</span><br><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><h3 id=\"输入输出流基础\"><a href=\"#输入输出流基础\" class=\"headerlink\" title=\"输入输出流基础\"></a>输入输出流基础</h3><ul>\n<li>头文件: <code>#include &lt;fstream&gt;</code></li>\n<li>类: <code>ifstream</code>(输入流), <code>ofstream</code>(输出流)<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span>  <span class=\"hljs-comment\">// 需要包含这个头文件</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 文件输出（写入文件）</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;output.txt&quot;</span>)</span></span>;<br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br><br><span class=\"hljs-comment\">// 文件输入（读取文件）</span><br><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;input.txt&quot;</span>)</span></span>;<br>string line;<br><span class=\"hljs-built_in\">getline</span>(inFile, line);<br>inFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>写入文件时, 如果没有文件, 会自动创建.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用操作示例\"><a href=\"#常用操作示例\" class=\"headerlink\" title=\"常用操作示例\"></a>常用操作示例</h3><ol>\n<li><p><strong>写入文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ofstream outFile;<br>outFile.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&quot;test.txt&quot;</span>);  <span class=\"hljs-comment\">// 打开文件</span><br><span class=\"hljs-keyword\">if</span> (outFile.<span class=\"hljs-built_in\">is_open</span>()) &#123;   <span class=\"hljs-comment\">// 检查是否成功打开</span><br>    outFile &lt;&lt; <span class=\"hljs-string\">&quot;第一行&quot;</span> &lt;&lt; endl;<br>    outFile &lt;&lt; <span class=\"hljs-string\">&quot;第二行&quot;</span> &lt;&lt; endl;<br>    outFile.<span class=\"hljs-built_in\">close</span>();       <span class=\"hljs-comment\">// 完成后关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>)</span></span>;<br>string line;<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">getline</span>(inFile, line)) &#123;  <span class=\"hljs-comment\">// 逐行读取</span><br>    cout &lt;&lt; line &lt;&lt; endl;<br>&#125;<br>inFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>以追加模式打开文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::app)</span></span>;  <span class=\"hljs-comment\">// app 表示追加模式</span><br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;这行会被添加到文件末尾&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"文件打开模式\"><a href=\"#文件打开模式\" class=\"headerlink\" title=\"文件打开模式\"></a>文件打开模式</h3><ul>\n<li><code>ios::in</code> - 读取模式</li>\n<li><code>ios::out</code> - 写入模式</li>\n<li><code>ios::app</code> - 追加模式</li>\n<li><code>ios::ate</code> - 打开文件后立即定位到文件末尾</li>\n<li><code>ios::binary</code> - 二进制模式</li>\n<li><code>ios::trunc</code> - 如果文件存在则<strong>截断</strong>文件<ul>\n<li>如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 假设 test.txt 原本内容是:</span><br><span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-comment\">// This is a test</span><br><br><span class=\"hljs-comment\">// 使用 trunc 模式打开</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::out | ios::trunc)</span></span>;  <br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;新的内容&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br><br><span class=\"hljs-comment\">// 现在 test.txt 的内容只有:</span><br><span class=\"hljs-comment\">// 新的内容</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> 或直接用 <code>ios::out</code>，因为out默认包含trunc</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>使用位或运算符<code>|</code>来同时指定多个模式:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 组合使用打开模式</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::out | ios::app)</span></span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;nonexistent.txt&quot;</span>)</span></span>;<br><span class=\"hljs-keyword\">if</span> (!inFile) &#123;<br>    cerr &lt;&lt; <span class=\"hljs-string\">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用is_open()</span><br><span class=\"hljs-keyword\">if</span> (!inFile.<span class=\"hljs-built_in\">is_open</span>()) &#123;<br>    cerr &lt;&lt; <span class=\"hljs-string\">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>需要先引入指定的头文件:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>定义时可以使用等号或者用括号包裹字符串:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string name = <span class=\"hljs-string\">&quot;John&quot;</span>; <br><span class=\"hljs-comment\">// string name(&quot;John&quot;);</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"stringstream\"><a href=\"#stringstream\" class=\"headerlink\" title=\"stringstream\"></a>stringstream</h3><p><code>stringstream</code> 表示<strong>双向</strong>字符串流:</p>\n<ul>\n<li>需要导入头文件<code>#include &lt;sstream&gt;</code>;</li>\n<li><code>istringstream</code> 表示<strong>输入</strong>字符串流<ul>\n<li>作用: 将字符串转换成一个类似于输入流的对象;</li>\n<li>内部维护了一个字符串和一个位置指针;</li>\n<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>\n</ul>\n</li>\n<li><code>ostringstream</code> 表示<strong>输出</strong>字符串流.</li>\n</ul>\n<h4 id=\"字符串分词\"><a href=\"#字符串分词\" class=\"headerlink\" title=\"字符串分词\"></a>字符串分词</h4><p>自动以<strong>空白字符</strong>(空格、制表符\\t、换行符\\n等)分割字符串;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span> <span class=\"hljs-params\">( <span class=\"hljs-string\">&quot;Xiao Ming&quot;</span>)</span></span>;<br><br>    <span class=\"hljs-comment\">// 使用括号包字符串</span><br>    <span class=\"hljs-function\">istringstream <span class=\"hljs-title\">is</span> <span class=\"hljs-params\">(name)</span></span>; <br>    string s;<br>    <span class=\"hljs-keyword\">while</span> (is&gt;&gt;s)&#123;<br>        cout &lt;&lt; s &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&gt;&gt;</code> 表示从输入流中读取数据;</p>\n<p>注意字符串流也是一种类型, 作用的对象是字符串.</p>\n</blockquote>\n<p>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Xiao Ming<br>Xiao<br>Ming<br></code></pre></td></tr></table></figure></p>\n<p>包含更多分词的字符串:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    string words = <span class=\"hljs-string\">&quot;hello \\n world! \\t I am \\n here!&quot;</span>;<br>    <span class=\"hljs-function\">stringstream <span class=\"hljs-title\">is</span> <span class=\"hljs-params\">(words)</span></span>;<br>    <br>    string word;<br>    <span class=\"hljs-type\">int</span> count  = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span>(is &gt;&gt; word)&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Word &quot;</span> &lt;&lt; count &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; word &lt;&lt; endl;<br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Word 1: hello<br>Word 2: world!<br>Word 3: I<br>Word 4: am<br>Word 5: here!<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ostringstream oss;<br>    string name = <span class=\"hljs-string\">&quot;Alice&quot;</span>;<br>    <span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>    <br>    oss &lt;&lt; <span class=\"hljs-string\">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;, Age: &quot;</span> &lt;&lt; age;<br>    string result = oss.<span class=\"hljs-built_in\">str</span>();<br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Name: Alice, Age: 25<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>通过<code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>\n</blockquote>\n<p><br></p>\n<p><code>.str(&quot;&quot;)</code>方法可以<strong>清空</strong>字符串流:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ostringstream oss;<br>    string name = <span class=\"hljs-string\">&quot;Alice&quot;</span>;<br>    <span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>    <br>    oss &lt;&lt; <span class=\"hljs-string\">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;, Age: &quot;</span> &lt;&lt; age;<br>    oss.<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>    string result = oss.<span class=\"hljs-built_in\">str</span>();<br>    cout &lt;&lt; result &lt;&lt; <span class=\"hljs-string\">&quot;Nothing&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Nothing<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Getline\"><a href=\"#Getline\" class=\"headerlink\" title=\"Getline\"></a>Getline</h3><p><strong>基本语法:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">getline</span>(istream&amp; is, string&amp; str, <span class=\"hljs-type\">char</span> delim = <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>is</code>: 输入流（通常是cin;</li>\n<li><code>str</code>: 存储结果的字符串;</li>\n<li><code>delim</code>: 分隔符, 默认为换行符<code>\\n</code>.</li>\n</ul>\n<p><strong>Example</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string line;<br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;请输入一行文本：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);  <span class=\"hljs-comment\">// 读取整行，包括空格</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;你输入的是：&quot;</span> &lt;&lt; line &lt;&lt; endl;<br>    <br>    <span class=\"hljs-comment\">// 使用自定义分隔符</span><br>    string data;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;请输入内容（用,分隔）：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, data, <span class=\"hljs-string\">&#x27;,&#x27;</span>);  <span class=\"hljs-comment\">// 读取直到遇到逗号</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;读取到逗号前的内容：&quot;</span> &lt;&lt; data &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h3><p><strong>特点</strong>:</p>\n<ul>\n<li>以空白字符（空格、制表符、换行符）为分隔符;</li>\n<li><strong>忽略</strong>前导空白字符;</li>\n<li>遇到空白字符就停止读取.</li>\n</ul>\n<p>通常需要与<code>getchar()</code>方法配合来清除缓冲区当中的<code>\\n</code>字符:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> number;<br>    string line;<br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;输入一个数字：&quot;</span>;<br>    cin &gt;&gt; number;<br>    <br>    <span class=\"hljs-comment\">//清除输入缓冲区中的换行符</span><br>    <span class=\"hljs-built_in\">getchar</span>(); <span class=\"hljs-comment\">// or cin.ignore(); </span><br>   <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;输入一行文本：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);  <span class=\"hljs-comment\">// 现在可以正确读取整行</span><br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;数字：&quot;</span> &lt;&lt; number &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;文本：&quot;</span> &lt;&lt; line &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果输入<code>8 \\n</code>, 则<code>getchar()</code>读取空格, 文本为空.</p>\n</blockquote>\n<h3 id=\"Alter-String\"><a href=\"#Alter-String\" class=\"headerlink\" title=\"Alter String\"></a>Alter String</h3><p><strong>outline</strong> 常用的字符串方法(成员函数):<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">size_t</span> pos, <span class=\"hljs-type\">const</span> string&amp; s);<br><span class=\"hljs-built_in\">erase</span> (<span class=\"hljs-type\">size_t</span> pos = <span class=\"hljs-number\">0</span>, size_tlen = npos);<br><span class=\"hljs-built_in\">append</span> (<span class=\"hljs-type\">const</span> string&amp; str);<br><span class=\"hljs-built_in\">replace</span> (<span class=\"hljs-type\">size_t</span> pos,<span class=\"hljs-type\">size_t</span> len,<span class=\"hljs-type\">const</span> string&amp; str);<br></code></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>insert(int pos, string str)</code> 在指定位置插入字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-comment\">// 在位置5处插入字符串</span><br>str.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&quot; Beautiful&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello Beautiful World&quot;</span><br><br><span class=\"hljs-comment\">// 在字符串末尾插入内容</span><br>str.<span class=\"hljs-built_in\">insert</span>(str.<span class=\"hljs-built_in\">length</span>(), <span class=\"hljs-string\">&quot;!&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello Beautiful World!&quot;</span><br><br><span class=\"hljs-comment\">// 插入单个字符（使用string构造）</span><br>str.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;&gt;&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;&gt;Hello Beautiful World!&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>erase(int pos, int length)</code> 删除从指定位置开始的若干个字符<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello Beautiful World!&quot;</span>;<br><br><span class=\"hljs-comment\">// 删除从下标6开始的9个字符</span><br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>); <br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello World!&quot;</span><br><br><span class=\"hljs-comment\">// 删除从某个位置开始到末尾的所有字符</span><br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">5</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length</code>参数省略, 则删除从<code>pos</code>位置开始到字符串末尾的所有字符.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>replace (int pos, int length, string)</code> 替换指定位置的字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 从位置6开始，替换5个字符为&quot;C++&quot;</span><br>string str = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br>str.<span class=\"hljs-built_in\">replace</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&quot;C++&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello C++!&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>append (const string&amp; str);</code><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 添加整个字符串</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(string2);<br><br><span class=\"hljs-comment\">// 添加指定位置的字符(索引从开始)</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(string2, start, length);<br><br><span class=\"hljs-comment\">// 重复字符的添加</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(count, <span class=\"hljs-type\">char</span>);<br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>除此之外, 还存在着使用$\\underline{迭代器}$的用法: </p>\n<blockquote>\n<p>类似于指针, 指向容器(如字符串、数组等)的特定位置.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string source = <span class=\"hljs-string\">&quot;World!&quot;</span>;<br>    string target = <span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 添加source中的部分字符（从开始到结束）</span><br>    target.<span class=\"hljs-built_in\">append</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">end</span>());<br>    cout &lt;&lt; target &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello World!</span><br>    <br>    <span class=\"hljs-comment\">// 只添加部分字符</span><br>    string target2 = <span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>    target<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">append</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">5</span>);  <span class=\"hljs-comment\">// 只添加&quot;World&quot;，不包含&quot;!&quot;</span><br>    cout &lt;&lt; target2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello World</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><code>begin()</code>方法返回字符串的第一个字符的迭代器, <code>end()</code>方法返回字符串最后一个字符的<strong>下一个</strong>位置的迭代器;</li>\n<li>迭代器的范围是<strong>左闭右开</strong>.</li>\n</ol>\n<hr>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h4><ul>\n<li><code>find(string, int pos)</code> 寻找指定的字符串位置<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World Hello&quot;</span>;<br><span class=\"hljs-comment\">// 从位置0开始查找&quot;Hello&quot;</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; endl;     <span class=\"hljs-comment\">// 结果: 0</span><br><span class=\"hljs-comment\">// 从位置1开始查找&quot;Hello&quot;</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; endl;     <span class=\"hljs-comment\">// 结果: 12</span><br><span class=\"hljs-comment\">// 查找不存在的字符串</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Python&quot;</span>) &lt;&lt; endl;       <span class=\"hljs-comment\">// 结果: string::npos</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>string::npos</code>是<code>size_t</code>类型的最大值;</li>\n<li>可以使用<code>str.find(&quot;Python&quot;) == string::npos</code>作为判断条件, 检查是否找到字符串.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>compare(string)</code> 字符串比较<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str2 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str3 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br><br>cout &lt;&lt; str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">compare</span>(str2) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: 0  (相等)</span><br>cout &lt;&lt; str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">compare</span>(str3) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: -15 (str1 &lt; str3) </span><br>cout &lt;&lt; str<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">compare</span>(str1) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: 15  (str3 &gt; str1)</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>按照字典序比较得到结果</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>to_string(int)</code> 将数字转换成字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">123</span>;<br>string str = <span class=\"hljs-built_in\">to_string</span>(num);<br>cout &lt;&lt; str &lt;&lt; endl;          <span class=\"hljs-comment\">// 结果: &quot;123&quot;</span><br>cout &lt;&lt; str + <span class=\"hljs-string\">&quot;456&quot;</span> &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;123456&quot;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>字符串之间可以通过<code>+</code>直接拼接.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>stoi(string)</code> 将字符串转换成整数<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">stoi</span>(str);<br>cout &lt;&lt; num + <span class=\"hljs-number\">456</span> &lt;&lt; endl;    <span class=\"hljs-comment\">// 结果: 579</span><br><span class=\"hljs-comment\">// 注意：字符串必须是合法的数字格式</span><br><span class=\"hljs-comment\">// string str = &quot;abc&quot;; </span><br><span class=\"hljs-comment\">// int num = stoi(str);  // 这会抛出异常</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>字符串必须是合法的数字格式;</li>\n<li><code>int num = stoi(&quot;abc&quot;);</code>  将会抛出异常</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>Outline:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *cp, <span class=\"hljs-type\">int</span> len);<br><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> string&amp; s2, <span class=\"hljs-type\">int</span> pos);<br><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> string&amp; s2, <span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br></code></pre></td></tr></table></figure></p>\n<hr>\n<ul>\n<li><p><code>string(const char *cp, int len)</code> 字符数组创建字符串</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">str1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Hello World&quot;</span>, <span class=\"hljs-number\">5</span>)</span></span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: Hello</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(const string&amp; s2, int pos)</code> 从现有字符串创建新字符串，从指定位置到末尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s2 = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">str2</span><span class=\"hljs-params\">(s2, <span class=\"hljs-number\">6</span>)</span></span>;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: World</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(const string&amp; s2, int pos, int len)</code> 从现有字符串创建新字符串，指定起始位置和长度</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s3 = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">str3</span><span class=\"hljs-params\">(s3, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: Wor</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(int length, char c)</code> 用指定长度的字符c初始化字符串</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">str4</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>)</span></span>;<br>cout &lt;&lt; str4 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: *****</span><br><br><span class=\"hljs-comment\">// 实际应用示例</span><br><span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">432</span>;<br>string str = <span class=\"hljs-built_in\">to_string</span>(num);<br>cout &lt;&lt; <span class=\"hljs-built_in\">string</span>(<span class=\"hljs-number\">5</span> - str.<span class=\"hljs-built_in\">length</span>(), <span class=\"hljs-string\">&#x27;0&#x27;</span>) + str &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: 00432</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 提取子字符串</span><br><span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br>string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>string sub = str.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// 结果: &quot;Wor&quot;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 字符串赋值</span><br><span class=\"hljs-built_in\">assign</span>();<br>string str1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str2;<br>str<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">assign</span>(str1);  <span class=\"hljs-comment\">// str2现在是 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 在指定位置插入字符串</span><br>    string str1 = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>    string str2 = <span class=\"hljs-string\">&quot;world&quot;</span>;<br>    str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>, str2);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 结果: helworldlo </span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 删除指定位置的指定长度的字符</span><br><span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br>string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>);  <span class=\"hljs-comment\">// 结果: &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p><strong>Notice：</strong></p>\n<ol>\n<li>所有位置索引都是从0开始计数</li>\n<li>如果指定的长度超过字符串实际长度，会自动调整到实际可用长度</li>\n<li>使用这些函数时要注意检查参数的有效性，避免越界访问</li>\n</ol>\n<hr>\n<h3 id=\"Substr\"><a href=\"#Substr\" class=\"headerlink\" title=\"Substr\"></a>Substr</h3><p>在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. <code>substr()</code>方法可以精确地获取字符串片段.</p>\n<p><code>substr</code>即substring的缩写, 表示子字符串.</p>\n<p><strong>基本语法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">substr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len)</span> </span>;<br></code></pre></td></tr></table></figure><br>参数分别表示截取的起始下标以及要截取的长度(如果省略<code>len</code>将截取到字符串的末尾).</p>\n<p><strong>e.g.</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string email = <span class=\"hljs-string\">&quot;user.name@example.com&quot;</span>;<br><br><span class=\"hljs-comment\">// 获取用户名的部分</span><br><span class=\"hljs-type\">int</span> atPos = email.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&#x27;@&#x27;</span>);<br>string username = email.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>, atPos); <span class=\"hljs-comment\">// result: &quot;user.name&quot;</span><br><br><span class=\"hljs-comment\">// 获取域名部分</span><br>string domain =  email.<span class=\"hljs-built_in\">substr</span>(atPos + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// result: &quot;example.com&quot;</span><br><br><span class=\"hljs-comment\">// 获取顶级域名(最后一个.之后的部分)</span><br><span class=\"hljs-type\">int</span> lastDotPos = email.<span class=\"hljs-built_in\">rfind</span>(<span class=\"hljs-string\">&#x27;.&#x27;</span>);<br>string topLevelDomain = email.<span class=\"hljs-built_in\">substr</span>(lastDotPos + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// result: &quot;com&quot;</span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>rfind()</code>方法: 会从字符串的<strong>末尾向前</strong>搜索，从而返回要查找的字符或子字符串最后一次出现的位置。如果没有找到，则返回 string::npos。</li>\n</ul>\n<hr>\n<h1 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h1><p><strong>选择的标准:</strong></p>\n<ul>\n<li>一般情况 $\\Rightarrow$ <code>vector</code>;</li>\n<li>程序需要对元素进行<strong>随机访问</strong> $\\Rightarrow$ <code>vector</code> or <code>deque</code>;</li>\n<li>程序需要在容器<strong>中间插入</strong>元素 $\\Rightarrow$ <code>list</code> or <code>forward_list</code>;</li>\n<li>程序需要在容器的<strong>首尾插入</strong>元素 $\\Rightarrow$ <code>deque</code>;</li>\n<li>容器中的元素<strong>相对较小</strong>但是数量较多 $\\nRightarrow$ <code>list</code> nor <code>forward_list</code>.<ul>\n<li>否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>存储元素在<strong>连续的内存空间</strong>中, 支持<strong>随机访问</strong>.</p>\n<ul>\n<li>可以动态增长, 适合存储<strong>未知数量</strong>的元素;</li>\n<li>通过下标访问元素的时间复杂度为 O(1);</li>\n<li>在末尾插入和删除元素的时间复杂度为 O(1);</li>\n<li>在中间插入和删除元素的时间复杂度为 O(n);</li>\n<li><strong>使用场景</strong>: 需要随机访问、排序、内存连续存储的场景.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器:<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), value);  <span class=\"hljs-comment\">// 查找 value</span><br>  <span class=\"hljs-keyword\">if</span> (it != vec.<span class=\"hljs-built_in\">end</span>()) &#123;         <span class=\"hljs-comment\">// 如果找到了（即没有返回 end()）</span><br>      vec.<span class=\"hljs-built_in\">erase</span>(it);             <span class=\"hljs-comment\">// 则删除找到的元素</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用 <code>.push_back()</code>在末尾插入元素, 或者使用<code>.emplace_back()</code>在末尾原位构造元素(更加高效);<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">10</span>);<br>vec.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//更加高效</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace_back</code>方法<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象, 相比于<code>push_back</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">1</span>);       <span class=\"hljs-comment\">// 删除第二个元素</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 删除前三个元素</span><br>vec.<span class=\"hljs-built_in\">clear</span>();                      <span class=\"hljs-comment\">// 清空整个 vector</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>vec.clear();</code> 将会清空整个vector.</p>\n<p>和<code>insert</code>需要的参数一样, 都需要<strong>迭代器</strong>而非索引来定位.</p>\n</blockquote>\n</li>\n<li><code>vec[i]</code>的形式访问, 使用<code>vec.at(i)</code>的方式可以在越界时抛出异常;</li>\n<li><code>.begin()</code>和<code>.end()</code>获取迭代器, 使用范围for循环遍历元素;  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"> cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector elements:&quot;</span> &lt;&lt; endl;<br> <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : vec) &#123;<br>    cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br> &#125;<br> cout &lt;&lt; endl;<br><br><span class=\"hljs-comment\">//使用迭代器遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>(); it != vec.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>    cout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>\n<li><code>.size()</code>获取<code>vector</code>的大小, <code>.empty()</code>判断<code>vector</code>是否为空;<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><span class=\"hljs-keyword\">if</span> (vec.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector is empty.&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用<code>sort()</code>对<code>vector</code>进行排序, 使用<code>find()</code>查找元素;<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());   <span class=\"hljs-comment\">// 排序</span><br><span class=\"hljs-keyword\">auto</span> it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 查找 5</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Reserve\"><a href=\"#Reserve\" class=\"headerlink\" title=\"Reserve\"></a>Reserve</h3><p>为了避免频繁地扩展内存, 可以通过<code>reserve</code>预先分配合适的空间, 同时通过<code>.reszie()</code>调整大小;<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;string&gt; v2;<br>v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">1000</span>);  <span class=\"hljs-comment\">// 一次性分配 1000 个元素的空间</span><br><br>v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">resize</span>(v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>() + v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>()/<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 调整大小为原来的 1.5 倍</span><br></code></pre></td></tr></table></figure></p>\n<p><code>reserve</code>只分配空间而不创建元素,<code>resize</code>将同时分配元素(默认值):</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;string&gt; vec;<br><span class=\"hljs-comment\">// reserve: 只分配空间，不创建元素</span><br>vec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">10</span>);  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The capacity with reserve: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The size with reserve: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;    <br><br><span class=\"hljs-comment\">// resize: 分配空间并创建元素</span><br>vec.<span class=\"hljs-built_in\">resize</span>(<span class=\"hljs-number\">10</span>);   <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The capacity with resize: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The size with resize: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;   <br></code></pre></td></tr></table></figure>\n<p><strong>Output</strong>:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">The capacity with reserve: 10<br>The size with reserve: 0<br>The capacity with resize: 10<br>The size with resize: 10<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[!important]</p>\n<p><code>.push_back()</code>的实际作用是在容器索引的<code>size</code>处插入元素.</p>\n<p> 而<code>reserve</code>不会影响容器的<code>size</code>,  初始化和<code>resize</code>会影响并且填充默认值:</p>\n</blockquote>\n<p><strong>e.g.  验证:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br>    <br>    <span class=\"hljs-comment\">// 打印初始状态</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;初始状态：\\n&quot;</span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 预留5个空间</span><br>    vec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">15</span>);<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;reserve(15) 后：\\n&quot;</span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>    <br>    vec[<span class=\"hljs-number\">20</span>] =<span class=\"hljs-number\">20</span>;<br><br>    <span class=\"hljs-comment\">// 添加元素并观察</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;添加元素过程：\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">6</span>; i++) &#123;<br>        vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;添加 &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; 后 - &quot;</span>;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() <br>             &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>()<br>             &lt;&lt; <span class=\"hljs-string\">&quot;, 元素: &quot;</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p><strong>Output:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">初始状态：<br>size: 10, capacity: 10<br><br>reserve(15) 后：<br>size: 10, capacity: 15<br><br>添加元素过程：<br>添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 <br>添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 <br>添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 <br>添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 <br>添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 <br>添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 <br></code></pre></td></tr></table></figure>\n<ol>\n<li>此处的 <code>vector&lt;int&gt; vec(10);</code>初始化了10个默认值的<code>int</code>类型的元素;</li>\n<li><code>vec[20] = 20;</code>没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;<ol>\n<li>如果换成<code>vec.at(20) = 20</code>将会在编译时报错;</li>\n</ol>\n</li>\n<li>可以发现, <code>reserve</code>的作用就是避免了多次自动扩容.</li>\n</ol>\n<blockquote>\n<p><code>reserve</code>的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.</p>\n</blockquote>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><ul>\n<li>在<code>list</code>容器当中, 迭代器是双向迭代器;<ul>\n<li>双向迭代器不支持大小的比较, 只支持 <code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>;<br>因此, 注意实际的使用:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">list&lt;<span class=\"hljs-type\">int</span>&gt; lst1;<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator iter1 = lst<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">begin</span>();<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator iter2 = lst<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">end</span>();<br><br><span class=\"hljs-comment\">// 正确的写法</span><br><span class=\"hljs-keyword\">while</span> (iter1 != iter2) &#123;<br>    <span class=\"hljs-comment\">// 处理当前元素</span><br>    ++iter1;<br>&#125;<br><br><span class=\"hljs-comment\">// 错误的比较</span><br><span class=\"hljs-comment\">// while(iter1 &lt; iter2) </span><br>    <br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    list&lt;string&gt; s;<br>    string str;<br>    list&lt;string&gt; :: iterator p;<br>    <span class=\"hljs-type\">int</span> count ;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;enter the number of the strings:&quot;</span> &lt;&lt; endl;<br><br>    cin &gt;&gt; count; <br><br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++)&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;enter a string:&quot;</span> ;<br>        cin &gt;&gt;str;<br>        <br>        p = s.<span class=\"hljs-built_in\">begin</span>();<br>        <span class=\"hljs-keyword\">while</span>(p != s.<span class=\"hljs-built_in\">end</span>() &amp;&amp; *p &lt;str)<br>            p++;<br>        s.<span class=\"hljs-built_in\">insert</span>(p,str);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(p = s.<span class=\"hljs-built_in\">begin</span>(); p!=s.<span class=\"hljs-built_in\">end</span>(); p++)<br>        cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>分析:</strong></p>\n<ul>\n<li><code>while(p != s.end() &amp;&amp; *p &lt;str)</code> 每次输入<code>str</code>时, 令迭代器从<code>list</code>的开头开始, 进行字典序的比较;</li>\n<li>找到插入的位置, 利用<code>insert()</code>方法插入.</li>\n</ul>\n<h2 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h2><p><code>deque</code>即 double-ended queue, <strong>双端队列</strong>.</p>\n<p>支持:</p>\n<ul>\n<li>在两端快速的插入或删除;</li>\n<li>随机访问;</li>\n</ul>\n<p><strong>语法</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br>deque&lt;<span class=\"hljs-type\">int</span>&gt; dq;<br><br><span class=\"hljs-comment\">// 1. 插入操作</span><br>dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">1</span>);    <span class=\"hljs-comment\">// 在末尾插入</span><br>dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// 在开头插入</span><br>dq.<span class=\"hljs-built_in\">insert</span>(pos, val);<span class=\"hljs-comment\">// 在指定位置插入</span><br><br><span class=\"hljs-comment\">// 2. 删除操作</span><br>dq.<span class=\"hljs-built_in\">pop_back</span>();      <span class=\"hljs-comment\">// 删除末尾元素</span><br>dq.<span class=\"hljs-built_in\">pop_front</span>();     <span class=\"hljs-comment\">// 删除首部元素</span><br>dq.<span class=\"hljs-built_in\">erase</span>(pos);      <span class=\"hljs-comment\">// 删除指定位置元素</span><br><br><span class=\"hljs-comment\">// 3. 访问操作</span><br>dq[<span class=\"hljs-number\">0</span>];              <span class=\"hljs-comment\">// 随机访问</span><br>dq.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-number\">1</span>);           <span class=\"hljs-comment\">// 带边界检查的访问</span><br>dq.<span class=\"hljs-built_in\">front</span>();         <span class=\"hljs-comment\">// 访问第一个元素</span><br>dq.<span class=\"hljs-built_in\">back</span>();          <span class=\"hljs-comment\">// 访问最后一个元素</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>示例:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    deque&lt;<span class=\"hljs-type\">int</span>&gt; dq;<br>    <br>    <span class=\"hljs-comment\">// 在两端插入元素</span><br>    dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">3</span>);<br>    dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br>    dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br>    dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">8</span>);<br>    <br>    <span class=\"hljs-comment\">// dq ：&#123;8, 1, 3, 4&#125;</span><br>    <br>    <span class=\"hljs-comment\">// 使用随机访问</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; dq.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>        cout &lt;&lt; dq[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Forward-list\"><a href=\"#Forward-list\" class=\"headerlink\" title=\"Forward_list\"></a>Forward_list</h3><p><code>forward_list</code>即 单项链表.</p>\n<ul>\n<li>只能向前遍历, 即对应的迭代器不支持<code>--</code>而支持<code>++</code>.</li>\n<li>同时不支持下标访问以及随机访问.</li>\n<li>单项链表的设计, 使得内部的每个节点只需要<strong>一个</strong>指针来指向下一个节点, 从而比<code>list</code>双向链表更加节省内存.</li>\n</ul>\n<p><strong>语法</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;forward_list&gt;</span></span><br>forward_list&lt;<span class=\"hljs-type\">int</span>&gt; fl;<br><br><span class=\"hljs-comment\">// 1. 插入操作</span><br>fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);           <span class=\"hljs-comment\">// 在开头插入</span><br>fl.<span class=\"hljs-built_in\">insert_after</span>(pos, val);  <span class=\"hljs-comment\">// 在指定位置之后插入</span><br><br><span class=\"hljs-comment\">// 2. 删除操作</span><br>fl.<span class=\"hljs-built_in\">pop_front</span>();            <span class=\"hljs-comment\">// 删除第一个元素</span><br>fl.<span class=\"hljs-built_in\">erase_after</span>(pos);       <span class=\"hljs-comment\">// 删除指定位置之后的元素</span><br><br><span class=\"hljs-comment\">// 3. 访问操作</span><br>fl.<span class=\"hljs-built_in\">front</span>();               <span class=\"hljs-comment\">// 访问第一个元素</span><br><br><span class=\"hljs-comment\">// 4. 特殊操作</span><br>fl.<span class=\"hljs-built_in\">before_begin</span>();        <span class=\"hljs-comment\">// 返回第一个元素之前的迭代器</span><br>fl.<span class=\"hljs-built_in\">begin</span>();               <span class=\"hljs-comment\">// 返回第一个元素的迭代器</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>示例</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;forward_list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    forward_list&lt;<span class=\"hljs-type\">int</span>&gt; fl;<br>    <br>    <span class=\"hljs-comment\">// 插入元素</span><br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">3</span>);<br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">2</span>);<br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-comment\">// 在特定位置后插入</span><br>    <span class=\"hljs-keyword\">auto</span> it = fl.<span class=\"hljs-built_in\">begin</span>(); <span class=\"hljs-comment\">// 指向第一个元素</span><br>    fl.<span class=\"hljs-built_in\">insert_after</span>(it, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 在第一个元素后插入4</span><br>    <br>    <span class=\"hljs-comment\">// 遍历打印</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; val : fl) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 输出：1 4 2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"访问前一个元素\"><a href=\"#访问前一个元素\" class=\"headerlink\" title=\"访问前一个元素\"></a>访问前一个元素</h4><p>由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合<code>before_begin()</code>方法.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 如果需要访问某个元素的前一个元素，必须从头开始遍历</span><br><span class=\"hljs-keyword\">auto</span> prev = fl.<span class=\"hljs-built_in\">before_begin</span>();<br><span class=\"hljs-keyword\">auto</span> curr = fl.<span class=\"hljs-built_in\">begin</span>();<br><span class=\"hljs-keyword\">while</span>(curr != fl.<span class=\"hljs-built_in\">end</span>() &amp;&amp; *curr != target) &#123;<br>    ++prev;<br>    ++curr;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键<strong>自动排序</strong></p>\n<ul>\n<li>如果插入重复的key, 将会覆盖原有的value;</li>\n<li>通过键查找元素、插入和删除的时间复杂度均为O(log n);</li>\n<li><strong>使用场景</strong>: 字典、索引、统计等.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于<code>map</code>当中;<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = ages.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>);  <span class=\"hljs-comment\">// 查找 &quot;Charlie&quot;</span><br>  <span class=\"hljs-keyword\">if</span> (it != ages.<span class=\"hljs-built_in\">end</span>()) &#123;         <span class=\"hljs-comment\">// 如果找到了（即没有返回 end()）</span><br>      ages.<span class=\"hljs-built_in\">erase</span>(it);             <span class=\"hljs-comment\">// 则删除找到的元素</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用下标(键)直接插入,或者通过键值对插入<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ages[<span class=\"hljs-string\">&quot;Alice&quot;</span>] = <span class=\"hljs-number\">25</span>;<br>ages.<span class=\"hljs-built_in\">insert</span>(&#123;<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">30</span>&#125;);<br>ages.<span class=\"hljs-built_in\">emplace</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>, <span class=\"hljs-number\">28</span>); <span class=\"hljs-comment\">// 使用 emplace 插入 (更高效)</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace</code>方法指<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于<code>insert</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定key的元素, 也可以通过<code>.find()</code>找到key对应的迭代器<code>it</code>, 然后<code>erase(it)</code>.</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ages.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);           <span class=\"hljs-comment\">// 删除键为 &quot;Bob&quot; 的元素</span><br><br><span class=\"hljs-keyword\">auto</span> it = ages.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (it != ages.<span class=\"hljs-built_in\">end</span>()) &#123;<br>    ages.<span class=\"hljs-built_in\">erase</span>(it);         <span class=\"hljs-comment\">// 删除迭代器指向的元素</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ages.clear();</code> 将会清空整个map.</p>\n</blockquote>\n</li>\n<li><code>map[key]</code>的形式访问, 使用<code>map.at(key)</code>的方式可以在key不存在时抛出异常;</li>\n<li><code>.find(key)</code>查找对应键的元素( 返回<strong>迭代器</strong> ), <code>.count(key)</code>返回对应键的元素个数(0 or 1)</li>\n<li><code>.size()</code>获取map的大小.</li>\n<li>迭代器的<code>-&gt;first</code>和<code>-&gt;second</code>可以分别访问键和值.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cout &lt;&lt; <span class=\"hljs-string\">&quot;Map elements:&quot;</span> &lt;&lt; endl;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> mapIt = ages.<span class=\"hljs-built_in\">begin</span>(); mapIt != ages.<span class=\"hljs-built_in\">end</span>(); ++mapIt) &#123;<br>   cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; mapIt-&gt;second &lt;&lt; endl; <span class=\"hljs-comment\">// 访问键和值</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.</p>\n<ul>\n<li><strong>标记位置</strong>: <code>.begin()</code>和<code>.end()</code> 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;</li>\n</ul>\n<p>迭代器的分类:</p>\n<ul>\n<li>输入迭代器: 支持读取和递增操作;<ul>\n<li><code>istream_iterator</code>: 用于从输入流读取数据;</li>\n</ul>\n</li>\n<li>输出迭代器: 支持写入和递增操作;<ul>\n<li><code>ostream_iterator</code>: 用于向输出流写入数据;</li>\n</ul>\n</li>\n<li>前向迭代器: 具有输入、输出迭代器的<strong>所有</strong>功能, 并且可以多次遍历同一个序列;<ul>\n<li>比如<code>forwarf_list</code>的迭代器:<code>auto it = flist.begin()</code> or <code>forward_list&lt;int&gt;::iterator it = flist.begin()</code>;</li>\n</ul>\n</li>\n<li>双向迭代器: 在前向迭代器的原有功能上, 同时支持<strong>递减</strong>操作;<ul>\n<li>比如双向链表<code>list</code>的迭代器.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    list&lt;<span class=\"hljs-type\">int</span>&gt; myList = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 使用双向迭代器正向遍历</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Forward traversal: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> ( list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = myList.<span class=\"hljs-built_in\">begin</span>(); it != myList.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt;  endl;<br><br>    <span class=\"hljs-comment\">// 使用双向迭代器逆向遍历</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Reverse traversal: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> ( list&lt;<span class=\"hljs-type\">int</span>&gt;::reverse_iterator rit = myList.<span class=\"hljs-built_in\">rbegin</span>(); rit != myList.<span class=\"hljs-built_in\">rend</span>(); ++rit) &#123;<br>        cout &lt;&lt; *rit &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt;  endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">// Forward traversal: 10 20 30 40 50 </span><br>    <span class=\"hljs-comment\">// Reverse traversal: 50 40 30 20 10 </span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><code>reverse_iterator</code>用于声明逆向遍历的迭代器, 也可以使用<code>auto</code>直接声明.</li>\n<li><code>rbegin()</code>和<code>rend()</code>分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的<code>++</code>相当于正向遍历时的<code>--</code>操作.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>随机访问迭代器: 具有双向迭代器的所有功能, 同时支持<strong>随机访问</strong>, 如<code>it+n</code>,<code>it[n]</code>.<ul>\n<li>比如<code>vector</code>的迭代器.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector elements (random access): &quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; vec.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>    cout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 使用下标随机访问</span><br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>另外, 还有一种迭代器称为<strong>插入迭代器</strong>, 比如<code>back_inserter</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br><br><span class=\"hljs-comment\">//结合copy将容器的元素直接插入到另一个容器中</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; dest = &#123;<span class=\"hljs-number\">60</span>,<span class=\"hljs-number\">70</span>&#125;;<br><span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">back_inserter</span>(dest)); <span class=\"hljs-comment\">// 在 dest 末尾插入元素</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Copied vector: &quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : dest) &#123;<br>    cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class=\"hljs-comment\">// Copied vector: 60 70 10 20 30 40 50 </span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环的语法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (range_declaration : range_expression) &#123;<br>    loop_statement;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 <code>auto</code>关键字让编译器自动推导类型;</li>\n<li>range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或<strong>字符串</strong>;</li>\n<li>loop_statement： 循环体，包含要对每个元素执行的语句.</li>\n</ul>\n<p>e.g:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 使用 for-each 循环遍历 vector</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出每个元素</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 使用 auto 关键字自动推导类型</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 修改容器中的元素（需要使用引用）</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> &amp;num : numbers) &#123;<br>        num *= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 将每个元素乘以 2</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">// 输出修改后的元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>for (int &amp;num : numbers)</code>：使用引用 &amp;，可以直接修改容器中的元素.</li>\n</ul>\n<h3 id=\"Map的循环\"><a href=\"#Map的循环\" class=\"headerlink\" title=\"Map的循环\"></a>Map的循环</h3><p>当range_expression是<code>map</code>时, 可以使用<code>auto</code>自动推导range_declaration的类型.需要注意是:</p>\n<ul>\n<li>用迭代器的方式访问<code>map</code>中的键值对的性质是 <code>it-&gt;first</code>与<code>it-&gt;second</code>;</li>\n<li>在<code>for-each</code>循环当中, range_declaration是一个值, 因此使用<code>.first</code>与<code>.second</code>来访问键和值.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    map&lt;string, string&gt; m = &#123;&#123;<span class=\"hljs-string\">&quot;one&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>&#125;, &#123;<span class=\"hljs-string\">&quot;two&quot;</span>, <span class=\"hljs-string\">&quot;2&quot;</span>&#125;, &#123;<span class=\"hljs-string\">&quot;three&quot;</span>, <span class=\"hljs-string\">&quot;3&quot;</span>&#125;&#125;;<br>    vector&lt;string&gt; vec;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; entry : m)&#123;<br>        vec.<span class=\"hljs-built_in\">push_back</span>(entry.first + <span class=\"hljs-string\">&quot;:&quot;</span> + entry.second );<br>    &#125;<br>    <span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">ostream_iterator</span>&lt;string&gt;(cout, <span class=\"hljs-string\">&quot; &quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n  <strong>Output:</strong>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">one:1 three:3 two:2<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处由于<code>map</code>自动按照键的字典序进行排序, 因此输出时<code>three</code>的元素在<code>two</code>前;</p>\n</blockquote>\n</li>\n</ul>\n<p>在上述的示例中, 也可以使用下面的方式进行<code>vec</code>的输出:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; s : vec) &#123;<br>    cout &lt;&lt; s &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时<code>auto</code>会自动推导为<code>string</code>类型, 且<code>&amp;</code>对数组的元素进行了引用, 使得输出更加高效.</p>\n<h3 id=\"Pro-amp-Con\"><a href=\"#Pro-amp-Con\" class=\"headerlink\" title=\"Pro&amp;Con\"></a>Pro&amp;Con</h3><p><code>for-each</code>循环的优点:</p>\n<ul>\n<li>消除了访问数组等越界的风险;</li>\n<li>不需要事先初始化迭代器;</li>\n</ul>\n<p><code>for-each</code>循环的缺点:</p>\n<ul>\n<li>无法获取元素的索引;</li>\n<li>只能顺序地遍历.</li>\n</ul>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><p>我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.</p>\n<p>而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> old_type new_type;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"Notices\"><a href=\"#Notices\" class=\"headerlink\" title=\"Notices\"></a>Notices</h2><ol>\n<li>直接对数组、字符串和<code>vector</code>进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;</li>\n<li>对于<code>vector</code>, 可以通过<code>.at() =</code>的方式进行安全访问, 编译器会进行边界检查. 或者通过<code>.push_back()</code> or <code>.emplace_back</code>的方式在末尾赋值. 同时注意用<code>.reserve()</code>预先分配充分的内存空间.</li>\n<li>避免不经意地向<code>map</code>当中插入元素:<ol>\n<li>错误的示范:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span>(foo[<span class=\"hljs-string\">&quot;bob&quot;</span>] == <span class=\"hljs-number\">1</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用<code>.count()</code>方法正确检查元素是否存在:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span>( foo.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-string\">&quot;bob&quot;</span>) )&#123;...&#125;<br></code></pre></td></tr></table></figure></li>\n<li>也可以使用<code>find()</code>方法检查元素是否存在:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = m.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>   <br><span class=\"hljs-keyword\">if</span>(it  != m.<span class=\"hljs-built_in\">end</span>())&#123;<br>    cout &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-keyword\">else</span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Not found&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>使用<code>.empty()</code>方法来检查容器<strong>整体是否为空</strong>, 而非<code>.count() == 0</code>的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.</li>\n<li><p><code>erase()</code> 方法会返回<strong>指向</strong>被删除元素的<strong>下一个</strong>元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//Initialize a list</span><br>list&lt;<span class=\"hljs-type\">int</span>&gt; L;<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator li = L.<span class=\"hljs-built_in\">begin</span>();<br><br><span class=\"hljs-comment\">// Wrong:</span><br>L.<span class=\"hljs-built_in\">erase</span>(li);    <span class=\"hljs-comment\">// 删除元素后，li 变成了无效迭代器</span><br>++li;           <span class=\"hljs-comment\">// 错误, 不能对无效迭代器进行操作</span><br><br><span class=\"hljs-comment\">// Correct:</span><br>li = L.<span class=\"hljs-built_in\">erase</span>(li);  <span class=\"hljs-comment\">// 删除元素后，li 被更新为指向被删除元素的下一个元素</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><ul>\n<li><p>Pointers to Objects</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>string *p = &amp;str;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Oprators with Pointers</p>\n<ul>\n<li><code>&amp;</code>: 取地址;</li>\n<li><code>*</code>: 解引用;</li>\n<li><code>-&gt;</code>: 用于访问对象的成员.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">(*p).<span class=\"hljs-built_in\">length</span>();<br><span class=\"hljs-comment\">// 等价于</span><br>p-&gt;<span class=\"hljs-built_in\">length</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length()</code>即为<code>string</code>类的成员函数, 因此可以用<code>-&gt;</code>来访问.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><h2 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h2><blockquote>\n<p>以<code>char</code>为例.</p>\n</blockquote>\n<ul>\n<li>常量指针 <code>char * const p</code><ul>\n<li>地址是<code>const</code>类型, 无法赋予<code>p</code>新的地址;</li>\n<li>但是可以改变指针指向对象的值.</li>\n</ul>\n</li>\n<li>指针常量 <code>char const * p</code><ul>\n<li>指针指向的值无法改变;</li>\n<li>但是可以改变指针的值(指向的对象).<br>如果需要同时保证地址和值都无法改变, 则需要使用<code>const char * const p</code>.</li>\n</ul>\n</li>\n</ul>\n<p>e.g:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <span class=\"hljs-comment\">// 常量指针</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p = &amp;a;  <span class=\"hljs-comment\">// 指针常量</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> * <span class=\"hljs-type\">const</span> p = &amp;a;  <span class=\"hljs-comment\">// 常量指针常量</span><br><span class=\"hljs-comment\">// 错误示例</span><br><span class=\"hljs-comment\">// p = &amp;b;  // 常量指针的值无法改变</span><br><span class=\"hljs-comment\">// *p = 30;  // 指针指向的值无法改变</span><br><span class=\"hljs-comment\">// 正确示例</span><br><span class=\"hljs-type\">int</span> c = <span class=\"hljs-number\">30</span>;<br>p = &amp;c;  <span class=\"hljs-comment\">// 常量指针的值可以改变</span><br>*p = <span class=\"hljs-number\">40</span>;  <span class=\"hljs-comment\">// 指针指向的值可以改变</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>to be checked.</p>\n</blockquote>\n<p>如果<code>sp</code>是指向字符串的指针, 那么这两种的写法是等价的, 注意<code>.</code>的优先级高于<code>*</code>, 因此括号不可忽略.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">sp-&gt;<span class=\"hljs-built_in\">length</span>();<br>(*sp).<span class=\"hljs-built_in\">length</span>();<br></code></pre></td></tr></table></figure>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"::\"></a><code>::</code></h3><p><code>::</code> resolver: 作用域解析运算符</p>\n<ul>\n<li><p>作用: </p>\n<ul>\n<li><p>访问全局的作用域<br>当局部变量和全局变量同名时, 可以使用 <code>::</code> 来访问全局变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> value = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 全局变量</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> value = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// 局部变量</span><br>    cout &lt;&lt; value;    <span class=\"hljs-comment\">// 输出 20（局部变量）</span><br>    cout &lt;&lt; ::value;  <span class=\"hljs-comment\">// 输出 10（全局变量）</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>访问命名空间中的成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">namespace</span> Math &#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> PI = <span class=\"hljs-number\">3.14159</span>;<br>&#125;<br><br><span class=\"hljs-type\">double</span> circumference = <span class=\"hljs-number\">2</span> * Math::PI * radius; <span class=\"hljs-comment\">// 使用命名空间中的常量</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>语法:</p>\n<ul>\n<li><code>&lt;class_name&gt; :: &lt;function_name&gt;</code></li>\n<li><code>::&lt;function_name&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">S::f</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ::<span class=\"hljs-built_in\">f</span>();  <span class=\"hljs-comment\">// Would be recursive otherwise!</span><br>    ::a++;  <span class=\"hljs-comment\">// Select the global a</span><br>    a--;    <span class=\"hljs-comment\">// The a at class scope</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>S::f()</code>: 定义了属于类S的成员函数f;</p>\n<p><code>::f()</code>:表示调用全局作用域中的函数 <code>f()</code>, 默认为递归调用当前的成员函数;</p>\n<p><code>::a++</code>表示将全局作用域的 <code>a</code> 自增, <code>a--</code>则访问并递减类作用域中的成员变量 <code>a</code>.</p>\n</blockquote>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><code>this</code></h3><p><code>this</code>指针是成员函数的隐藏参数. 指向<strong>当前对象的实例</strong>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Point::move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span></span>;<br><span class=\"hljs-comment\">//等价于</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Point::move</span><span class=\"hljs-params\">(Point *<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>当调用成员函数时, 对象的地址会自动作为 <code>this</code>参数传递.</p>\n<p>在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 <code>this</code>:</p>\n<p>e.g</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> x, y;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 移动点的位置</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span> </span>&#123;<br>        x += dx;<br>        y += dy;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 打印点的坐标</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Point at (&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 组合以上两个功能的函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">move_and_print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span> </span>&#123;<br>        <span class=\"hljs-built_in\">move</span>(dx, dy);  <span class=\"hljs-comment\">// 等同于 this-&gt;move(dx, dy)</span><br>        <span class=\"hljs-built_in\">print</span>();       <span class=\"hljs-comment\">// 等同于 this-&gt;print()</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>但是也可以显式指定 <code>this-&gt;move</code>, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.</p>\n</blockquote>\n<h3 id=\"封装特性\"><a href=\"#封装特性\" class=\"headerlink\" title=\"封装特性\"></a>封装特性</h3><p>在OOP中, Object = Attributes + Services, 即数据和操作被<strong>封装</strong>在一起, 构成一个完整的对象.</p>\n<h3 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h3><p>我们应当在头文件中声明对象的成员及其 <code>public</code>,<code>private</code>和 <code>protected</code>等属性, 并且在 <code>cpp</code>文件中给出具体的定义:</p>\n<blockquote>\n<p>最好为每个类都建立如此对应的头文件和源文件 <code>cpp</code>.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// Student.h - 类的声明</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> STUDENT_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STUDENT_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;  <span class=\"hljs-comment\">// 在头文件中使用</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 数据成员</span><br>    string name;     <span class=\"hljs-comment\">// 不再需要 std:: 前缀</span><br>    <span class=\"hljs-type\">int</span> id;<br>    <span class=\"hljs-type\">float</span> gpa;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数原型</span><br>    <span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">const</span> string&amp; name, <span class=\"hljs-type\">int</span> id);<br>    <br>    <span class=\"hljs-comment\">// 成员函数原型</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> string&amp; newName)</span></span>;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">calculateGPA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEligibleForScholarship</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">// STUDENT_H</span></span><br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// Student.cpp - 成员函数的定义</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;Student.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;  <span class=\"hljs-comment\">// 在源文件中使用</span><br><br><span class=\"hljs-comment\">// 构造函数实现</span><br>Student::<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">const</span> string&amp; name, <span class=\"hljs-type\">int</span> id) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;name = name;<br>    <span class=\"hljs-keyword\">this</span>-&gt;id = id;<br>    <span class=\"hljs-keyword\">this</span>-&gt;gpa = <span class=\"hljs-number\">0.0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 成员函数实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Student::setName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> string&amp; newName)</span> </span>&#123;<br>    name = newName;<br>&#125;<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Student::getName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Student::calculateGPA</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 实现GPA计算逻辑</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Student::isEligibleForScholarship</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> gpa &gt;= <span class=\"hljs-number\">3.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Student::getName()</code>指的就是类 <code>Student</code>中的成员函数 <code>getName()</code>.</p>\n</blockquote>\n<p>具体来说, <code>.h</code>头文件当中应该有:</p>\n<ul>\n<li><p>外部变量的声明<br>e.g. <code>extern int globalCounter;  // 仅声明，不定义</code></p>\n</li>\n<li><p>函数原型<br>e.g. <code>int calculateSum(int a, int b);  // 函数声明，不包含实现</code></p>\n</li>\n<li><p>类/结构体的声明<br>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>;  <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-comment\">// 或完整类声明（不含成员函数定义）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> width;<br>    <span class=\"hljs-type\">double</span> height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">double</span> w, <span class=\"hljs-type\">double</span> h);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>回顾 <code>#include</code>: 将被引用的文件插入 <code>.cpp</code> 文件当中</p>\n<ul>\n<li><p><code>#include &quot;xx.h&quot;</code>: 首先在当前目录下寻找;</p>\n</li>\n<li><p><code>#include &lt;xx.h&gt;</code>: 直接在指定的目录中寻找</p>\n<blockquote>\n<p>等价于 <code>#include &lt;xx&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<p>为了避免在多个 <code>.cpp</code> 文件中重复引用相同的头文件, 可以通过 <code>#ifndef</code>等标记来判断是否需要引用当前的头文件:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> HEADER_FLAG</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> HEADER_FLAG</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> </span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>HEADER_FLAG</code>一般使用完全大写来方便标识, 但是也可以大小写混合.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 文件: vector.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> VECTOR_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> VECTOR_H</span><br><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">// VECTOR_H</span></span><br></code></pre></td></tr></table></figure>\n<h2 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h2><p>当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.</p>\n<p>为了确保这些工作不被遗忘, <code>cpp</code>的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.</p>\n<h3 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.</p>\n<ul>\n<li>语法: </li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassName</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>();<br>    <br>    <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>(参数列表);<br>    <br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>(<span class=\"hljs-type\">const</span> ClassName&amp; other);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><strong>默认构造函数</strong>：不带参数或所有参数都有默认值;</li>\n<li><strong>带参数的构造函数</strong>：接受一个或多个参数;</li>\n<li><strong>拷贝构造函数</strong>：从同类型的另一个对象创建新对象.</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>构造函数初始化列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">Point::<span class=\"hljs-built_in\">Point</span>(<span class=\"hljs-type\">int</span> xx, <span class=\"hljs-type\">int</span> yy) :<span class=\"hljs-built_in\">x</span>(xx), <span class=\"hljs-built_in\">y</span>(yy) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>构造函数时, 传递参数并直接赋值给内部的成员变量 <code>x</code> , <code>y</code>.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>结构体中的构造函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Y</span> &#123; <br>    <span class=\"hljs-type\">float</span> f;     <span class=\"hljs-comment\">// 浮点型成员变量</span><br>    <span class=\"hljs-type\">int</span> i;       <span class=\"hljs-comment\">// 整型成员变量</span><br>    <span class=\"hljs-built_in\">Y</span>(<span class=\"hljs-type\">int</span> a);    <span class=\"hljs-comment\">// 声明了一个接受int参数的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>此处只是声明了构造函数需要 <code>int a</code>作为参数, 但是没有给出具体的实现;</li>\n<li>声明结构体对象 e.g. <code>Y y1[] = &#123; Y(1), Y(2), Y(3) &#125;;</code></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p><code>auto</code> default constructor: 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数:</p>\n<ul>\n<li>对于成员变量: 不进行初始化;</li>\n</ul>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 <code>~</code>. 当对象超出作用域或被显式删除时，析构函数会自动被调用.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassName</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    ~<span class=\"hljs-built_in\">ClassName</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>运用的示例:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyString</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* data;<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>() : <span class=\"hljs-built_in\">data</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;默认构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str) &#123;<br>        <span class=\"hljs-keyword\">if</span> (str) &#123;<br>            data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-built_in\">strcpy</span>(data, str);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            data = <span class=\"hljs-literal\">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;参数构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">const</span> MyString&amp; other) &#123;<br>        <span class=\"hljs-keyword\">if</span> (other.data) &#123;<br>            data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(other.data) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-built_in\">strcpy</span>(data, other.data);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            data = <span class=\"hljs-literal\">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">MyString</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] data;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;析构函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 打印字符串</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        std::cout &lt;&lt; (data ? data : <span class=\"hljs-string\">&quot;空字符串&quot;</span>) &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 测试各种构造函数</span><br>    MyString s1;                  <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-function\">MyString <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Hello&quot;</span>)</span></span>;         <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    MyString s3 = s2;             <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <br>    s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">print</span>();<br>    s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">print</span>();<br>    s<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">print</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 所有对象在这里被销毁，调用析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li>使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.<ul>\n<li>另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Includes\"><a href=\"#Includes\" class=\"headerlink\" title=\"Includes\"></a>Includes</h2><h3 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h3><p><code>copy(first, last, result)</code>:</p>\n<ul>\n<li><code>fisrt</code>和<code>last</code>是输入迭代器, 表示要复制的范围, 左闭右开即<code>last</code>应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;</li>\n<li><code>result</code>是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作<ul>\n<li>e.g.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; source = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">destination</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>)</span></span>; <span class=\"hljs-comment\">// 确保目标容器有足够的空间</span><br><br>std::<span class=\"hljs-built_in\">copy</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">end</span>(), destination.<span class=\"hljs-built_in\">begin</span>());<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : destination) &#123;<br>    std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出：1 2 3 4 5</span><br>&#125;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><code>result</code>可以直接输出到<code>cout</code>中.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)&#123;<br>    vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>&#125;<br><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>()<span class=\"hljs-number\">+2</span>); <span class=\"hljs-comment\">//删除第三个元素</span><br><span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">ostream_iterator</span>&lt;<span class=\"hljs-type\">int</span>&gt;(cout, <span class=\"hljs-string\">&quot;,&quot;</span>));<br>cout &lt;&lt; endl;<br><span class=\"hljs-comment\">// 0,1,3,4,</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>数组之间<strong>不可以</strong>直接赋值, 但是字符串可以直接赋值<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">char</span> str1[] = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br><span class=\"hljs-type\">char</span> str2[] = <span class=\"hljs-string\">&quot;World&quot;</span>;<br>str1 = str2;  <span class=\"hljs-comment\">// 错误，数组之间不可以直接赋值</span><br><br>string s1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string s2 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br>s1 = s2;  <span class=\"hljs-comment\">// 正确，字符串可以直接赋值</span><br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string s2 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;初始状态：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：Hello</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br><br>s1 = s2;  <span class=\"hljs-comment\">// 赋值操作</span><br><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br><br><span class=\"hljs-comment\">// 修改 s2 不会影响 s1，因为是深拷贝</span><br>s2 = <span class=\"hljs-string\">&quot;Changed&quot;</span>;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;修改 s2 后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：Changed</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Temp\"><a href=\"#Temp\" class=\"headerlink\" title=\"Temp\"></a>Temp</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 迭代器</span><br>I.<span class=\"hljs-built_in\">begin</span>();<br>I.<span class=\"hljs-built_in\">end</span>();<br><br><span class=\"hljs-comment\">// Item Access</span><br>V.<span class=\"hljs-built_in\">front</span>();;<br>V.<span class=\"hljs-built_in\">back</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h2><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find</code>是字符串类的一种方法, 同时也是标准库<code>algorithm</code>中的一个函数.</p>\n<ul>\n<li><code>find</code>方法: 用于在字符串中查找子字符串的位置。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-type\">size_t</span> pos = str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;World&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (pos != string::npos) &#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Found &#x27;World&#x27; at position &quot;</span> &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><code>algorithm</code>中的<code>find</code>函数: 用于在容器（如数组、向量等）中查找元素。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">3</span>);<br>    <span class=\"hljs-keyword\">if</span> (it != vec.<span class=\"hljs-built_in\">end</span>()) &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Found 3 at position &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">distance</span>(vec.<span class=\"hljs-built_in\">begin</span>(), it) &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// Found 3 at position 2</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>编译: <code>g++ -std=c++11 test.cpp -o test</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase\"></a>erase</h3><ul>\n<li>对于字符串的方法: <code>str.erase(pos, len)</code><ul>\n<li>删除从指定位置开始的指定个数字符<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>对于容器的方法: <code>erase(pos1, pos2)</code><ul>\n<li>左闭右开式删除容器当中的元素.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>&#125;;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Original vector: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素</span><br>    vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">1</span>, vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 删除 vec[1], vec[2], vec[3]</span><br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Modified vector: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 &quot;1 5 6&quot;</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"不知道放在哪里的代码块\"><a href=\"#不知道放在哪里的代码块\" class=\"headerlink\" title=\"不知道放在哪里的代码块\"></a>不知道放在哪里的代码块</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// 1. 创建并填充链表</span><br>list&lt;<span class=\"hljs-type\">int</span>&gt; L;                      <span class=\"hljs-comment\">// 创建一个空的整数链表</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=<span class=\"hljs-number\">5</span>; ++i)          <span class=\"hljs-comment\">// 循环5次</span><br>    L.<span class=\"hljs-built_in\">push_back</span>(i);              <span class=\"hljs-comment\">// 依次在链表尾部添加数字1,2,3,4,5</span><br>                                 <span class=\"hljs-comment\">// 此时链表内容为：1,2,3,4,5</span><br><br><span class=\"hljs-comment\">// 2. 删除第二个元素</span><br>L.<span class=\"hljs-built_in\">erase</span>( ++L.<span class=\"hljs-built_in\">begin</span>() );          <span class=\"hljs-comment\">// L.begin()指向第一个元素</span><br>                                 <span class=\"hljs-comment\">// ++L.begin()指向第二个元素</span><br>                                 <span class=\"hljs-comment\">// erase删除迭代器指向的元素</span><br>                                 <span class=\"hljs-comment\">// 此时链表内容为：1,3,4,5</span><br><br><span class=\"hljs-comment\">// 3. 打印链表内容</span><br><span class=\"hljs-built_in\">copy</span>(                            <span class=\"hljs-comment\">// 标准库算法，用于复制序列</span><br>    L.<span class=\"hljs-built_in\">begin</span>(),                   <span class=\"hljs-comment\">// 源序列的起始位置</span><br>    L.<span class=\"hljs-built_in\">end</span>(),                     <span class=\"hljs-comment\">// 源序列的结束位置</span><br>    <span class=\"hljs-built_in\">ostream_iterator</span>&lt;<span class=\"hljs-type\">int</span>&gt;(       <span class=\"hljs-comment\">// 输出流迭代器</span><br>        cout,                    <span class=\"hljs-comment\">// 指定输出到标准输出</span><br>        <span class=\"hljs-string\">&quot;,&quot;</span>                      <span class=\"hljs-comment\">// 每个元素后面追加的分隔符</span><br>    )<br>);<br>cout &lt;&lt; endl;                    <span class=\"hljs-comment\">// 换行</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"课堂缓冲区\"><a href=\"#课堂缓冲区\" class=\"headerlink\" title=\"课堂缓冲区\"></a>课堂缓冲区</h1><h1 id=\"题目梳理\"><a href=\"#题目梳理\" class=\"headerlink\" title=\"题目梳理\"></a>题目梳理</h1><h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><p><img src=\"cpp学习记录.assets/image-20250225160042809.png\" alt=\"image-20250225160042809\"></p>\n<ul>\n<li>ANS:  B</li>\n<li>由于此处的<code>map</code>以<code>char *</code>作为key, 同时初始化<code>str</code>的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.</li>\n</ul>\n<hr>\n<p><img src=\"cpp学习记录.assets/image-20250225160652522.png\" alt=\"image-20250225160652522\"></p>\n<ul>\n<li>逗号表达式, 结果为1. </li>\n</ul>\n","more":"<p>编译时, 从<code>c</code>的<code>gcc</code>转变为了<code>g++</code>.</p>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>在C语言中,我们主要使用<code>malloc()</code>和<code>free()</code>来进行动态内存管理。但这种方式存在一些问题:</p>\n<ul>\n<li>它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;</li>\n<li>容易发生内存泄漏.</li>\n</ul>\n<p>为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了<code>new</code>和`delete.</p>\n<p>new的基本语法十分直观:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">Type* pointer = <span class=\"hljs-keyword\">new</span> Type;           <span class=\"hljs-comment\">// 分配单个对象</span><br>Type* pointer = <span class=\"hljs-keyword\">new</span> Type[size];     <span class=\"hljs-comment\">// 分配对象数组</span><br></code></pre></td></tr></table></figure></p>\n<p>可以在创建时进行初始化:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span>* p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">5</span>);              <span class=\"hljs-comment\">// 初始化为5</span><br>string* p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">string</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);   <span class=\"hljs-comment\">// 初始化为&quot;hello&quot;</span><br></code></pre></td></tr></table></figure></p>\n<p>也可以根据变量进行动态的内存分配:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> size;<br>cin &gt;&gt; size;<br><span class=\"hljs-type\">int</span>* arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size];  <span class=\"hljs-comment\">// 根据输入分配内存</span><br></code></pre></td></tr></table></figure></p>\n<h1 id=\"输入输出流\"><a href=\"#输入输出流\" class=\"headerlink\" title=\"输入输出流\"></a>输入输出流</h1><p>通过包含头文件 — <code>#include &lt;iostream&gt;</code> 来使用输入输出流 <code>cin</code> 和 <code>cout</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> age; <br>    cin &gt;&gt; age;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;You are &quot;</span> &lt;&lt; age &lt;&lt; <span class=\"hljs-string\">&quot; years old&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-comment\">// endl 是换行符</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>cin</code>读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str=<span class=\"hljs-string\">&quot;Hello world!&quot;</span>;<br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">fout</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;out.txt&quot;</span>)</span></span>;<br>fout&lt;&lt;str&lt;&lt;endl;<br><br><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">fin</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;out.txt&quot;</span>)</span></span>;<br>string str1,str2;<br><br><span class=\"hljs-comment\">// 读取文件中的两个字符串</span><br>fin&gt;&gt;str1&gt;&gt;str2; <br><br>cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出:</span><br><span class=\"hljs-comment\">// Hello</span><br><span class=\"hljs-comment\">// world!</span><br><br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><h3 id=\"输入输出流基础\"><a href=\"#输入输出流基础\" class=\"headerlink\" title=\"输入输出流基础\"></a>输入输出流基础</h3><ul>\n<li>头文件: <code>#include &lt;fstream&gt;</code></li>\n<li>类: <code>ifstream</code>(输入流), <code>ofstream</code>(输出流)<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span>  <span class=\"hljs-comment\">// 需要包含这个头文件</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 文件输出（写入文件）</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;output.txt&quot;</span>)</span></span>;<br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br><br><span class=\"hljs-comment\">// 文件输入（读取文件）</span><br><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;input.txt&quot;</span>)</span></span>;<br>string line;<br><span class=\"hljs-built_in\">getline</span>(inFile, line);<br>inFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>写入文件时, 如果没有文件, 会自动创建.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用操作示例\"><a href=\"#常用操作示例\" class=\"headerlink\" title=\"常用操作示例\"></a>常用操作示例</h3><ol>\n<li><p><strong>写入文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ofstream outFile;<br>outFile.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&quot;test.txt&quot;</span>);  <span class=\"hljs-comment\">// 打开文件</span><br><span class=\"hljs-keyword\">if</span> (outFile.<span class=\"hljs-built_in\">is_open</span>()) &#123;   <span class=\"hljs-comment\">// 检查是否成功打开</span><br>    outFile &lt;&lt; <span class=\"hljs-string\">&quot;第一行&quot;</span> &lt;&lt; endl;<br>    outFile &lt;&lt; <span class=\"hljs-string\">&quot;第二行&quot;</span> &lt;&lt; endl;<br>    outFile.<span class=\"hljs-built_in\">close</span>();       <span class=\"hljs-comment\">// 完成后关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>读取文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>)</span></span>;<br>string line;<br><span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">getline</span>(inFile, line)) &#123;  <span class=\"hljs-comment\">// 逐行读取</span><br>    cout &lt;&lt; line &lt;&lt; endl;<br>&#125;<br>inFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>以追加模式打开文件</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::app)</span></span>;  <span class=\"hljs-comment\">// app 表示追加模式</span><br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;这行会被添加到文件末尾&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"文件打开模式\"><a href=\"#文件打开模式\" class=\"headerlink\" title=\"文件打开模式\"></a>文件打开模式</h3><ul>\n<li><code>ios::in</code> - 读取模式</li>\n<li><code>ios::out</code> - 写入模式</li>\n<li><code>ios::app</code> - 追加模式</li>\n<li><code>ios::ate</code> - 打开文件后立即定位到文件末尾</li>\n<li><code>ios::binary</code> - 二进制模式</li>\n<li><code>ios::trunc</code> - 如果文件存在则<strong>截断</strong>文件<ul>\n<li>如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 假设 test.txt 原本内容是:</span><br><span class=\"hljs-comment\">// Hello World</span><br><span class=\"hljs-comment\">// This is a test</span><br><br><span class=\"hljs-comment\">// 使用 trunc 模式打开</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::out | ios::trunc)</span></span>;  <br>outFile &lt;&lt; <span class=\"hljs-string\">&quot;新的内容&quot;</span> &lt;&lt; endl;<br>outFile.<span class=\"hljs-built_in\">close</span>();<br><br><span class=\"hljs-comment\">// 现在 test.txt 的内容只有:</span><br><span class=\"hljs-comment\">// 新的内容</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> 或直接用 <code>ios::out</code>，因为out默认包含trunc</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>使用位或运算符<code>|</code>来同时指定多个模式:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 组合使用打开模式</span><br><span class=\"hljs-function\">ofstream <span class=\"hljs-title\">outFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;test.txt&quot;</span>, ios::out | ios::app)</span></span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ifstream <span class=\"hljs-title\">inFile</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;nonexistent.txt&quot;</span>)</span></span>;<br><span class=\"hljs-keyword\">if</span> (!inFile) &#123;<br>    cerr &lt;&lt; <span class=\"hljs-string\">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 或者使用is_open()</span><br><span class=\"hljs-keyword\">if</span> (!inFile.<span class=\"hljs-built_in\">is_open</span>()) &#123;<br>    cerr &lt;&lt; <span class=\"hljs-string\">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>需要先引入指定的头文件:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>定义时可以使用等号或者用括号包裹字符串:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string name = <span class=\"hljs-string\">&quot;John&quot;</span>; <br><span class=\"hljs-comment\">// string name(&quot;John&quot;);</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"stringstream\"><a href=\"#stringstream\" class=\"headerlink\" title=\"stringstream\"></a>stringstream</h3><p><code>stringstream</code> 表示<strong>双向</strong>字符串流:</p>\n<ul>\n<li>需要导入头文件<code>#include &lt;sstream&gt;</code>;</li>\n<li><code>istringstream</code> 表示<strong>输入</strong>字符串流<ul>\n<li>作用: 将字符串转换成一个类似于输入流的对象;</li>\n<li>内部维护了一个字符串和一个位置指针;</li>\n<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>\n</ul>\n</li>\n<li><code>ostringstream</code> 表示<strong>输出</strong>字符串流.</li>\n</ul>\n<h4 id=\"字符串分词\"><a href=\"#字符串分词\" class=\"headerlink\" title=\"字符串分词\"></a>字符串分词</h4><p>自动以<strong>空白字符</strong>(空格、制表符\\t、换行符\\n等)分割字符串;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span> <span class=\"hljs-params\">( <span class=\"hljs-string\">&quot;Xiao Ming&quot;</span>)</span></span>;<br><br>    <span class=\"hljs-comment\">// 使用括号包字符串</span><br>    <span class=\"hljs-function\">istringstream <span class=\"hljs-title\">is</span> <span class=\"hljs-params\">(name)</span></span>; <br>    string s;<br>    <span class=\"hljs-keyword\">while</span> (is&gt;&gt;s)&#123;<br>        cout &lt;&lt; s &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&gt;&gt;</code> 表示从输入流中读取数据;</p>\n<p>注意字符串流也是一种类型, 作用的对象是字符串.</p>\n</blockquote>\n<p>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Xiao Ming<br>Xiao<br>Ming<br></code></pre></td></tr></table></figure></p>\n<p>包含更多分词的字符串:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    string words = <span class=\"hljs-string\">&quot;hello \\n world! \\t I am \\n here!&quot;</span>;<br>    <span class=\"hljs-function\">stringstream <span class=\"hljs-title\">is</span> <span class=\"hljs-params\">(words)</span></span>;<br>    <br>    string word;<br>    <span class=\"hljs-type\">int</span> count  = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span>(is &gt;&gt; word)&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Word &quot;</span> &lt;&lt; count &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; word &lt;&lt; endl;<br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Word 1: hello<br>Word 2: world!<br>Word 3: I<br>Word 4: am<br>Word 5: here!<br></code></pre></td></tr></table></figure></p>\n<h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ostringstream oss;<br>    string name = <span class=\"hljs-string\">&quot;Alice&quot;</span>;<br>    <span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>    <br>    oss &lt;&lt; <span class=\"hljs-string\">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;, Age: &quot;</span> &lt;&lt; age;<br>    string result = oss.<span class=\"hljs-built_in\">str</span>();<br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Name: Alice, Age: 25<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>通过<code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>\n</blockquote>\n<p><br></p>\n<p><code>.str(&quot;&quot;)</code>方法可以<strong>清空</strong>字符串流:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ostringstream oss;<br>    string name = <span class=\"hljs-string\">&quot;Alice&quot;</span>;<br>    <span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">25</span>;<br>    <br>    oss &lt;&lt; <span class=\"hljs-string\">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;, Age: &quot;</span> &lt;&lt; age;<br>    oss.<span class=\"hljs-built_in\">str</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>    string result = oss.<span class=\"hljs-built_in\">str</span>();<br>    cout &lt;&lt; result &lt;&lt; <span class=\"hljs-string\">&quot;Nothing&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><br>Output:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Nothing<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Getline\"><a href=\"#Getline\" class=\"headerlink\" title=\"Getline\"></a>Getline</h3><p><strong>基本语法:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">getline</span>(istream&amp; is, string&amp; str, <span class=\"hljs-type\">char</span> delim = <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>is</code>: 输入流（通常是cin;</li>\n<li><code>str</code>: 存储结果的字符串;</li>\n<li><code>delim</code>: 分隔符, 默认为换行符<code>\\n</code>.</li>\n</ul>\n<p><strong>Example</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string line;<br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;请输入一行文本：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);  <span class=\"hljs-comment\">// 读取整行，包括空格</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;你输入的是：&quot;</span> &lt;&lt; line &lt;&lt; endl;<br>    <br>    <span class=\"hljs-comment\">// 使用自定义分隔符</span><br>    string data;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;请输入内容（用,分隔）：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, data, <span class=\"hljs-string\">&#x27;,&#x27;</span>);  <span class=\"hljs-comment\">// 读取直到遇到逗号</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;读取到逗号前的内容：&quot;</span> &lt;&lt; data &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h3><p><strong>特点</strong>:</p>\n<ul>\n<li>以空白字符（空格、制表符、换行符）为分隔符;</li>\n<li><strong>忽略</strong>前导空白字符;</li>\n<li>遇到空白字符就停止读取.</li>\n</ul>\n<p>通常需要与<code>getchar()</code>方法配合来清除缓冲区当中的<code>\\n</code>字符:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> number;<br>    string line;<br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;输入一个数字：&quot;</span>;<br>    cin &gt;&gt; number;<br>    <br>    <span class=\"hljs-comment\">//清除输入缓冲区中的换行符</span><br>    <span class=\"hljs-built_in\">getchar</span>(); <span class=\"hljs-comment\">// or cin.ignore(); </span><br>   <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;输入一行文本：&quot;</span>;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);  <span class=\"hljs-comment\">// 现在可以正确读取整行</span><br>    <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;数字：&quot;</span> &lt;&lt; number &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;文本：&quot;</span> &lt;&lt; line &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果输入<code>8 \\n</code>, 则<code>getchar()</code>读取空格, 文本为空.</p>\n</blockquote>\n<h3 id=\"Alter-String\"><a href=\"#Alter-String\" class=\"headerlink\" title=\"Alter String\"></a>Alter String</h3><p><strong>outline</strong> 常用的字符串方法(成员函数):<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-type\">size_t</span> pos, <span class=\"hljs-type\">const</span> string&amp; s);<br><span class=\"hljs-built_in\">erase</span> (<span class=\"hljs-type\">size_t</span> pos = <span class=\"hljs-number\">0</span>, size_tlen = npos);<br><span class=\"hljs-built_in\">append</span> (<span class=\"hljs-type\">const</span> string&amp; str);<br><span class=\"hljs-built_in\">replace</span> (<span class=\"hljs-type\">size_t</span> pos,<span class=\"hljs-type\">size_t</span> len,<span class=\"hljs-type\">const</span> string&amp; str);<br></code></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>insert(int pos, string str)</code> 在指定位置插入字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-comment\">// 在位置5处插入字符串</span><br>str.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&quot; Beautiful&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello Beautiful World&quot;</span><br><br><span class=\"hljs-comment\">// 在字符串末尾插入内容</span><br>str.<span class=\"hljs-built_in\">insert</span>(str.<span class=\"hljs-built_in\">length</span>(), <span class=\"hljs-string\">&quot;!&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello Beautiful World!&quot;</span><br><br><span class=\"hljs-comment\">// 插入单个字符（使用string构造）</span><br>str.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;&gt;&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;&gt;Hello Beautiful World!&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>erase(int pos, int length)</code> 删除从指定位置开始的若干个字符<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello Beautiful World!&quot;</span>;<br><br><span class=\"hljs-comment\">// 删除从下标6开始的9个字符</span><br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>); <br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello World!&quot;</span><br><br><span class=\"hljs-comment\">// 删除从某个位置开始到末尾的所有字符</span><br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">5</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length</code>参数省略, 则删除从<code>pos</code>位置开始到字符串末尾的所有字符.</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>replace (int pos, int length, string)</code> 替换指定位置的字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 从位置6开始，替换5个字符为&quot;C++&quot;</span><br>string str = <span class=\"hljs-string\">&quot;Hello World!&quot;</span>;<br>str.<span class=\"hljs-built_in\">replace</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&quot;C++&quot;</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;Hello C++!&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>append (const string&amp; str);</code><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 添加整个字符串</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(string2);<br><br><span class=\"hljs-comment\">// 添加指定位置的字符(索引从开始)</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(string2, start, length);<br><br><span class=\"hljs-comment\">// 重复字符的添加</span><br>string<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">append</span>(count, <span class=\"hljs-type\">char</span>);<br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>除此之外, 还存在着使用$\\underline{迭代器}$的用法: </p>\n<blockquote>\n<p>类似于指针, 指向容器(如字符串、数组等)的特定位置.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string source = <span class=\"hljs-string\">&quot;World!&quot;</span>;<br>    string target = <span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 添加source中的部分字符（从开始到结束）</span><br>    target.<span class=\"hljs-built_in\">append</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">end</span>());<br>    cout &lt;&lt; target &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello World!</span><br>    <br>    <span class=\"hljs-comment\">// 只添加部分字符</span><br>    string target2 = <span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>    target<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">append</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">5</span>);  <span class=\"hljs-comment\">// 只添加&quot;World&quot;，不包含&quot;!&quot;</span><br>    cout &lt;&lt; target2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello World</span><br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><code>begin()</code>方法返回字符串的第一个字符的迭代器, <code>end()</code>方法返回字符串最后一个字符的<strong>下一个</strong>位置的迭代器;</li>\n<li>迭代器的范围是<strong>左闭右开</strong>.</li>\n</ol>\n<hr>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h4><ul>\n<li><code>find(string, int pos)</code> 寻找指定的字符串位置<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World Hello&quot;</span>;<br><span class=\"hljs-comment\">// 从位置0开始查找&quot;Hello&quot;</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">0</span>) &lt;&lt; endl;     <span class=\"hljs-comment\">// 结果: 0</span><br><span class=\"hljs-comment\">// 从位置1开始查找&quot;Hello&quot;</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; endl;     <span class=\"hljs-comment\">// 结果: 12</span><br><span class=\"hljs-comment\">// 查找不存在的字符串</span><br>cout &lt;&lt; str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Python&quot;</span>) &lt;&lt; endl;       <span class=\"hljs-comment\">// 结果: string::npos</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>string::npos</code>是<code>size_t</code>类型的最大值;</li>\n<li>可以使用<code>str.find(&quot;Python&quot;) == string::npos</code>作为判断条件, 检查是否找到字符串.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>compare(string)</code> 字符串比较<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str2 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str3 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br><br>cout &lt;&lt; str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">compare</span>(str2) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: 0  (相等)</span><br>cout &lt;&lt; str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">compare</span>(str3) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: -15 (str1 &lt; str3) </span><br>cout &lt;&lt; str<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">compare</span>(str1) &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: 15  (str3 &gt; str1)</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>按照字典序比较得到结果</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>to_string(int)</code> 将数字转换成字符串<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">123</span>;<br>string str = <span class=\"hljs-built_in\">to_string</span>(num);<br>cout &lt;&lt; str &lt;&lt; endl;          <span class=\"hljs-comment\">// 结果: &quot;123&quot;</span><br>cout &lt;&lt; str + <span class=\"hljs-string\">&quot;456&quot;</span> &lt;&lt; endl;  <span class=\"hljs-comment\">// 结果: &quot;123456&quot;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>字符串之间可以通过<code>+</code>直接拼接.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li><code>stoi(string)</code> 将字符串转换成整数<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;123&quot;</span>;<br><span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">stoi</span>(str);<br>cout &lt;&lt; num + <span class=\"hljs-number\">456</span> &lt;&lt; endl;    <span class=\"hljs-comment\">// 结果: 579</span><br><span class=\"hljs-comment\">// 注意：字符串必须是合法的数字格式</span><br><span class=\"hljs-comment\">// string str = &quot;abc&quot;; </span><br><span class=\"hljs-comment\">// int num = stoi(str);  // 这会抛出异常</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>字符串必须是合法的数字格式;</li>\n<li><code>int num = stoi(&quot;abc&quot;);</code>  将会抛出异常</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>Outline:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *cp, <span class=\"hljs-type\">int</span> len);<br><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> string&amp; s2, <span class=\"hljs-type\">int</span> pos);<br><span class=\"hljs-built_in\">string</span>(<span class=\"hljs-type\">const</span> string&amp; s2, <span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br></code></pre></td></tr></table></figure></p>\n<hr>\n<ul>\n<li><p><code>string(const char *cp, int len)</code> 字符数组创建字符串</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">str1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Hello World&quot;</span>, <span class=\"hljs-number\">5</span>)</span></span>;<br>cout &lt;&lt; str1 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: Hello</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(const string&amp; s2, int pos)</code> 从现有字符串创建新字符串，从指定位置到末尾</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s2 = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">str2</span><span class=\"hljs-params\">(s2, <span class=\"hljs-number\">6</span>)</span></span>;<br>cout &lt;&lt; str2 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: World</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(const string&amp; s2, int pos, int len)</code> 从现有字符串创建新字符串，指定起始位置和长度</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s3 = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-function\">string <span class=\"hljs-title\">str3</span><span class=\"hljs-params\">(s3, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>cout &lt;&lt; str3 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: Wor</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><code>string(int length, char c)</code> 用指定长度的字符c初始化字符串</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">str4</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>)</span></span>;<br>cout &lt;&lt; str4 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: *****</span><br><br><span class=\"hljs-comment\">// 实际应用示例</span><br><span class=\"hljs-type\">int</span> num = <span class=\"hljs-number\">432</span>;<br>string str = <span class=\"hljs-built_in\">to_string</span>(num);<br>cout &lt;&lt; <span class=\"hljs-built_in\">string</span>(<span class=\"hljs-number\">5</span> - str.<span class=\"hljs-built_in\">length</span>(), <span class=\"hljs-string\">&#x27;0&#x27;</span>) + str &lt;&lt; endl;<br><span class=\"hljs-comment\">// 输出: 00432</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 提取子字符串</span><br><span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br>string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>string sub = str.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// 结果: &quot;Wor&quot;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 字符串赋值</span><br><span class=\"hljs-built_in\">assign</span>();<br>string str1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string str2;<br>str<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">assign</span>(str1);  <span class=\"hljs-comment\">// str2现在是 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 在指定位置插入字符串</span><br>    string str1 = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>    string str2 = <span class=\"hljs-string\">&quot;world&quot;</span>;<br>    str<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">3</span>, str2);<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><span class=\"hljs-comment\">// 结果: helworldlo </span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 删除指定位置的指定长度的字符</span><br><span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len);<br>string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>);  <span class=\"hljs-comment\">// 结果: &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>\n<p><strong>Notice：</strong></p>\n<ol>\n<li>所有位置索引都是从0开始计数</li>\n<li>如果指定的长度超过字符串实际长度，会自动调整到实际可用长度</li>\n<li>使用这些函数时要注意检查参数的有效性，避免越界访问</li>\n</ol>\n<hr>\n<h3 id=\"Substr\"><a href=\"#Substr\" class=\"headerlink\" title=\"Substr\"></a>Substr</h3><p>在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. <code>substr()</code>方法可以精确地获取字符串片段.</p>\n<p><code>substr</code>即substring的缩写, 表示子字符串.</p>\n<p><strong>基本语法</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">substr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> pos, <span class=\"hljs-type\">int</span> len)</span> </span>;<br></code></pre></td></tr></table></figure><br>参数分别表示截取的起始下标以及要截取的长度(如果省略<code>len</code>将截取到字符串的末尾).</p>\n<p><strong>e.g.</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string email = <span class=\"hljs-string\">&quot;user.name@example.com&quot;</span>;<br><br><span class=\"hljs-comment\">// 获取用户名的部分</span><br><span class=\"hljs-type\">int</span> atPos = email.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&#x27;@&#x27;</span>);<br>string username = email.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>, atPos); <span class=\"hljs-comment\">// result: &quot;user.name&quot;</span><br><br><span class=\"hljs-comment\">// 获取域名部分</span><br>string domain =  email.<span class=\"hljs-built_in\">substr</span>(atPos + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// result: &quot;example.com&quot;</span><br><br><span class=\"hljs-comment\">// 获取顶级域名(最后一个.之后的部分)</span><br><span class=\"hljs-type\">int</span> lastDotPos = email.<span class=\"hljs-built_in\">rfind</span>(<span class=\"hljs-string\">&#x27;.&#x27;</span>);<br>string topLevelDomain = email.<span class=\"hljs-built_in\">substr</span>(lastDotPos + <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// result: &quot;com&quot;</span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>rfind()</code>方法: 会从字符串的<strong>末尾向前</strong>搜索，从而返回要查找的字符或子字符串最后一次出现的位置。如果没有找到，则返回 string::npos。</li>\n</ul>\n<hr>\n<h1 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h1><p><strong>选择的标准:</strong></p>\n<ul>\n<li>一般情况 $\\Rightarrow$ <code>vector</code>;</li>\n<li>程序需要对元素进行<strong>随机访问</strong> $\\Rightarrow$ <code>vector</code> or <code>deque</code>;</li>\n<li>程序需要在容器<strong>中间插入</strong>元素 $\\Rightarrow$ <code>list</code> or <code>forward_list</code>;</li>\n<li>程序需要在容器的<strong>首尾插入</strong>元素 $\\Rightarrow$ <code>deque</code>;</li>\n<li>容器中的元素<strong>相对较小</strong>但是数量较多 $\\nRightarrow$ <code>list</code> nor <code>forward_list</code>.<ul>\n<li>否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>存储元素在<strong>连续的内存空间</strong>中, 支持<strong>随机访问</strong>.</p>\n<ul>\n<li>可以动态增长, 适合存储<strong>未知数量</strong>的元素;</li>\n<li>通过下标访问元素的时间复杂度为 O(1);</li>\n<li>在末尾插入和删除元素的时间复杂度为 O(1);</li>\n<li>在中间插入和删除元素的时间复杂度为 O(n);</li>\n<li><strong>使用场景</strong>: 需要随机访问、排序、内存连续存储的场景.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器:<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), value);  <span class=\"hljs-comment\">// 查找 value</span><br>  <span class=\"hljs-keyword\">if</span> (it != vec.<span class=\"hljs-built_in\">end</span>()) &#123;         <span class=\"hljs-comment\">// 如果找到了（即没有返回 end()）</span><br>      vec.<span class=\"hljs-built_in\">erase</span>(it);             <span class=\"hljs-comment\">// 则删除找到的元素</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用 <code>.push_back()</code>在末尾插入元素, 或者使用<code>.emplace_back()</code>在末尾原位构造元素(更加高效);<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">10</span>);<br>vec.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-number\">20</span>); <span class=\"hljs-comment\">//更加高效</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace_back</code>方法<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象, 相比于<code>push_back</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">1</span>);       <span class=\"hljs-comment\">// 删除第二个元素</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 删除前三个元素</span><br>vec.<span class=\"hljs-built_in\">clear</span>();                      <span class=\"hljs-comment\">// 清空整个 vector</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>vec.clear();</code> 将会清空整个vector.</p>\n<p>和<code>insert</code>需要的参数一样, 都需要<strong>迭代器</strong>而非索引来定位.</p>\n</blockquote>\n</li>\n<li><code>vec[i]</code>的形式访问, 使用<code>vec.at(i)</code>的方式可以在越界时抛出异常;</li>\n<li><code>.begin()</code>和<code>.end()</code>获取迭代器, 使用范围for循环遍历元素;  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"> cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector elements:&quot;</span> &lt;&lt; endl;<br> <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : vec) &#123;<br>    cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br> &#125;<br> cout &lt;&lt; endl;<br><br><span class=\"hljs-comment\">//使用迭代器遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>(); it != vec.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>    cout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li>\n<li><code>.size()</code>获取<code>vector</code>的大小, <code>.empty()</code>判断<code>vector</code>是否为空;<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><span class=\"hljs-keyword\">if</span> (vec.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector is empty.&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用<code>sort()</code>对<code>vector</code>进行排序, 使用<code>find()</code>查找元素;<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());   <span class=\"hljs-comment\">// 排序</span><br><span class=\"hljs-keyword\">auto</span> it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 查找 5</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Reserve\"><a href=\"#Reserve\" class=\"headerlink\" title=\"Reserve\"></a>Reserve</h3><p>为了避免频繁地扩展内存, 可以通过<code>reserve</code>预先分配合适的空间, 同时通过<code>.reszie()</code>调整大小;<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;string&gt; v2;<br>v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">1000</span>);  <span class=\"hljs-comment\">// 一次性分配 1000 个元素的空间</span><br><br>v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">resize</span>(v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>() + v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>()/<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 调整大小为原来的 1.5 倍</span><br></code></pre></td></tr></table></figure></p>\n<p><code>reserve</code>只分配空间而不创建元素,<code>resize</code>将同时分配元素(默认值):</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;string&gt; vec;<br><span class=\"hljs-comment\">// reserve: 只分配空间，不创建元素</span><br>vec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">10</span>);  <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The capacity with reserve: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The size with reserve: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;    <br><br><span class=\"hljs-comment\">// resize: 分配空间并创建元素</span><br>vec.<span class=\"hljs-built_in\">resize</span>(<span class=\"hljs-number\">10</span>);   <br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The capacity with resize: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;The size with resize: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;   <br></code></pre></td></tr></table></figure>\n<p><strong>Output</strong>:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">The capacity with reserve: 10<br>The size with reserve: 0<br>The capacity with resize: 10<br>The size with resize: 10<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>[!important]</p>\n<p><code>.push_back()</code>的实际作用是在容器索引的<code>size</code>处插入元素.</p>\n<p> 而<code>reserve</code>不会影响容器的<code>size</code>,  初始化和<code>resize</code>会影响并且填充默认值:</p>\n</blockquote>\n<p><strong>e.g.  验证:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br>    <br>    <span class=\"hljs-comment\">// 打印初始状态</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;初始状态：\\n&quot;</span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>    <br>    <span class=\"hljs-comment\">// 预留5个空间</span><br>    vec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">15</span>);<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;reserve(15) 后：\\n&quot;</span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; <span class=\"hljs-string\">&quot;\\n\\n&quot;</span>;<br>    <br>    vec[<span class=\"hljs-number\">20</span>] =<span class=\"hljs-number\">20</span>;<br><br>    <span class=\"hljs-comment\">// 添加元素并观察</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;添加元素过程：\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">6</span>; i++) &#123;<br>        vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;添加 &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; 后 - &quot;</span>;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() <br>             &lt;&lt; <span class=\"hljs-string\">&quot;, capacity: &quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>()<br>             &lt;&lt; <span class=\"hljs-string\">&quot;, 元素: &quot;</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p><strong>Output:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">初始状态：<br>size: 10, capacity: 10<br><br>reserve(15) 后：<br>size: 10, capacity: 15<br><br>添加元素过程：<br>添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 <br>添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 <br>添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 <br>添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 <br>添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 <br>添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 <br></code></pre></td></tr></table></figure>\n<ol>\n<li>此处的 <code>vector&lt;int&gt; vec(10);</code>初始化了10个默认值的<code>int</code>类型的元素;</li>\n<li><code>vec[20] = 20;</code>没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;<ol>\n<li>如果换成<code>vec.at(20) = 20</code>将会在编译时报错;</li>\n</ol>\n</li>\n<li>可以发现, <code>reserve</code>的作用就是避免了多次自动扩容.</li>\n</ol>\n<blockquote>\n<p><code>reserve</code>的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.</p>\n</blockquote>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><ul>\n<li>在<code>list</code>容器当中, 迭代器是双向迭代器;<ul>\n<li>双向迭代器不支持大小的比较, 只支持 <code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>;<br>因此, 注意实际的使用:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">list&lt;<span class=\"hljs-type\">int</span>&gt; lst1;<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator iter1 = lst<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">begin</span>();<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator iter2 = lst<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">end</span>();<br><br><span class=\"hljs-comment\">// 正确的写法</span><br><span class=\"hljs-keyword\">while</span> (iter1 != iter2) &#123;<br>    <span class=\"hljs-comment\">// 处理当前元素</span><br>    ++iter1;<br>&#125;<br><br><span class=\"hljs-comment\">// 错误的比较</span><br><span class=\"hljs-comment\">// while(iter1 &lt; iter2) </span><br>    <br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    list&lt;string&gt; s;<br>    string str;<br>    list&lt;string&gt; :: iterator p;<br>    <span class=\"hljs-type\">int</span> count ;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;enter the number of the strings:&quot;</span> &lt;&lt; endl;<br><br>    cin &gt;&gt; count; <br><br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++)&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;enter a string:&quot;</span> ;<br>        cin &gt;&gt;str;<br>        <br>        p = s.<span class=\"hljs-built_in\">begin</span>();<br>        <span class=\"hljs-keyword\">while</span>(p != s.<span class=\"hljs-built_in\">end</span>() &amp;&amp; *p &lt;str)<br>            p++;<br>        s.<span class=\"hljs-built_in\">insert</span>(p,str);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(p = s.<span class=\"hljs-built_in\">begin</span>(); p!=s.<span class=\"hljs-built_in\">end</span>(); p++)<br>        cout &lt;&lt; *p &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>分析:</strong></p>\n<ul>\n<li><code>while(p != s.end() &amp;&amp; *p &lt;str)</code> 每次输入<code>str</code>时, 令迭代器从<code>list</code>的开头开始, 进行字典序的比较;</li>\n<li>找到插入的位置, 利用<code>insert()</code>方法插入.</li>\n</ul>\n<h2 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h2><p><code>deque</code>即 double-ended queue, <strong>双端队列</strong>.</p>\n<p>支持:</p>\n<ul>\n<li>在两端快速的插入或删除;</li>\n<li>随机访问;</li>\n</ul>\n<p><strong>语法</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br>deque&lt;<span class=\"hljs-type\">int</span>&gt; dq;<br><br><span class=\"hljs-comment\">// 1. 插入操作</span><br>dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">1</span>);    <span class=\"hljs-comment\">// 在末尾插入</span><br>dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// 在开头插入</span><br>dq.<span class=\"hljs-built_in\">insert</span>(pos, val);<span class=\"hljs-comment\">// 在指定位置插入</span><br><br><span class=\"hljs-comment\">// 2. 删除操作</span><br>dq.<span class=\"hljs-built_in\">pop_back</span>();      <span class=\"hljs-comment\">// 删除末尾元素</span><br>dq.<span class=\"hljs-built_in\">pop_front</span>();     <span class=\"hljs-comment\">// 删除首部元素</span><br>dq.<span class=\"hljs-built_in\">erase</span>(pos);      <span class=\"hljs-comment\">// 删除指定位置元素</span><br><br><span class=\"hljs-comment\">// 3. 访问操作</span><br>dq[<span class=\"hljs-number\">0</span>];              <span class=\"hljs-comment\">// 随机访问</span><br>dq.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-number\">1</span>);           <span class=\"hljs-comment\">// 带边界检查的访问</span><br>dq.<span class=\"hljs-built_in\">front</span>();         <span class=\"hljs-comment\">// 访问第一个元素</span><br>dq.<span class=\"hljs-built_in\">back</span>();          <span class=\"hljs-comment\">// 访问最后一个元素</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>示例:</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    deque&lt;<span class=\"hljs-type\">int</span>&gt; dq;<br>    <br>    <span class=\"hljs-comment\">// 在两端插入元素</span><br>    dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">3</span>);<br>    dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br>    dq.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br>    dq.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">8</span>);<br>    <br>    <span class=\"hljs-comment\">// dq ：&#123;8, 1, 3, 4&#125;</span><br>    <br>    <span class=\"hljs-comment\">// 使用随机访问</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; dq.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>        cout &lt;&lt; dq[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Forward-list\"><a href=\"#Forward-list\" class=\"headerlink\" title=\"Forward_list\"></a>Forward_list</h3><p><code>forward_list</code>即 单项链表.</p>\n<ul>\n<li>只能向前遍历, 即对应的迭代器不支持<code>--</code>而支持<code>++</code>.</li>\n<li>同时不支持下标访问以及随机访问.</li>\n<li>单项链表的设计, 使得内部的每个节点只需要<strong>一个</strong>指针来指向下一个节点, 从而比<code>list</code>双向链表更加节省内存.</li>\n</ul>\n<p><strong>语法</strong>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;forward_list&gt;</span></span><br>forward_list&lt;<span class=\"hljs-type\">int</span>&gt; fl;<br><br><span class=\"hljs-comment\">// 1. 插入操作</span><br>fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);           <span class=\"hljs-comment\">// 在开头插入</span><br>fl.<span class=\"hljs-built_in\">insert_after</span>(pos, val);  <span class=\"hljs-comment\">// 在指定位置之后插入</span><br><br><span class=\"hljs-comment\">// 2. 删除操作</span><br>fl.<span class=\"hljs-built_in\">pop_front</span>();            <span class=\"hljs-comment\">// 删除第一个元素</span><br>fl.<span class=\"hljs-built_in\">erase_after</span>(pos);       <span class=\"hljs-comment\">// 删除指定位置之后的元素</span><br><br><span class=\"hljs-comment\">// 3. 访问操作</span><br>fl.<span class=\"hljs-built_in\">front</span>();               <span class=\"hljs-comment\">// 访问第一个元素</span><br><br><span class=\"hljs-comment\">// 4. 特殊操作</span><br>fl.<span class=\"hljs-built_in\">before_begin</span>();        <span class=\"hljs-comment\">// 返回第一个元素之前的迭代器</span><br>fl.<span class=\"hljs-built_in\">begin</span>();               <span class=\"hljs-comment\">// 返回第一个元素的迭代器</span><br></code></pre></td></tr></table></figure></p>\n<p><strong>示例</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;forward_list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    forward_list&lt;<span class=\"hljs-type\">int</span>&gt; fl;<br>    <br>    <span class=\"hljs-comment\">// 插入元素</span><br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">3</span>);<br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">2</span>);<br>    fl.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-comment\">// 在特定位置后插入</span><br>    <span class=\"hljs-keyword\">auto</span> it = fl.<span class=\"hljs-built_in\">begin</span>(); <span class=\"hljs-comment\">// 指向第一个元素</span><br>    fl.<span class=\"hljs-built_in\">insert_after</span>(it, <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 在第一个元素后插入4</span><br>    <br>    <span class=\"hljs-comment\">// 遍历打印</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; val : fl) &#123;<br>        cout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 输出：1 4 2 3</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"访问前一个元素\"><a href=\"#访问前一个元素\" class=\"headerlink\" title=\"访问前一个元素\"></a>访问前一个元素</h4><p>由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合<code>before_begin()</code>方法.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 如果需要访问某个元素的前一个元素，必须从头开始遍历</span><br><span class=\"hljs-keyword\">auto</span> prev = fl.<span class=\"hljs-built_in\">before_begin</span>();<br><span class=\"hljs-keyword\">auto</span> curr = fl.<span class=\"hljs-built_in\">begin</span>();<br><span class=\"hljs-keyword\">while</span>(curr != fl.<span class=\"hljs-built_in\">end</span>() &amp;&amp; *curr != target) &#123;<br>    ++prev;<br>    ++curr;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键<strong>自动排序</strong></p>\n<ul>\n<li>如果插入重复的key, 将会覆盖原有的value;</li>\n<li>通过键查找元素、插入和删除的时间复杂度均为O(log n);</li>\n<li><strong>使用场景</strong>: 字典、索引、统计等.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于<code>map</code>当中;<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = ages.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>);  <span class=\"hljs-comment\">// 查找 &quot;Charlie&quot;</span><br>  <span class=\"hljs-keyword\">if</span> (it != ages.<span class=\"hljs-built_in\">end</span>()) &#123;         <span class=\"hljs-comment\">// 如果找到了（即没有返回 end()）</span><br>      ages.<span class=\"hljs-built_in\">erase</span>(it);             <span class=\"hljs-comment\">// 则删除找到的元素</span><br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用下标(键)直接插入,或者通过键值对插入<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ages[<span class=\"hljs-string\">&quot;Alice&quot;</span>] = <span class=\"hljs-number\">25</span>;<br>ages.<span class=\"hljs-built_in\">insert</span>(&#123;<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">30</span>&#125;);<br>ages.<span class=\"hljs-built_in\">emplace</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>, <span class=\"hljs-number\">28</span>); <span class=\"hljs-comment\">// 使用 emplace 插入 (更高效)</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace</code>方法指<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于<code>insert</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定key的元素, 也可以通过<code>.find()</code>找到key对应的迭代器<code>it</code>, 然后<code>erase(it)</code>.</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ages.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);           <span class=\"hljs-comment\">// 删除键为 &quot;Bob&quot; 的元素</span><br><br><span class=\"hljs-keyword\">auto</span> it = ages.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (it != ages.<span class=\"hljs-built_in\">end</span>()) &#123;<br>    ages.<span class=\"hljs-built_in\">erase</span>(it);         <span class=\"hljs-comment\">// 删除迭代器指向的元素</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ages.clear();</code> 将会清空整个map.</p>\n</blockquote>\n</li>\n<li><code>map[key]</code>的形式访问, 使用<code>map.at(key)</code>的方式可以在key不存在时抛出异常;</li>\n<li><code>.find(key)</code>查找对应键的元素( 返回<strong>迭代器</strong> ), <code>.count(key)</code>返回对应键的元素个数(0 or 1)</li>\n<li><code>.size()</code>获取map的大小.</li>\n<li>迭代器的<code>-&gt;first</code>和<code>-&gt;second</code>可以分别访问键和值.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cout &lt;&lt; <span class=\"hljs-string\">&quot;Map elements:&quot;</span> &lt;&lt; endl;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> mapIt = ages.<span class=\"hljs-built_in\">begin</span>(); mapIt != ages.<span class=\"hljs-built_in\">end</span>(); ++mapIt) &#123;<br>   cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; mapIt-&gt;second &lt;&lt; endl; <span class=\"hljs-comment\">// 访问键和值</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.</p>\n<ul>\n<li><strong>标记位置</strong>: <code>.begin()</code>和<code>.end()</code> 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;</li>\n</ul>\n<p>迭代器的分类:</p>\n<ul>\n<li>输入迭代器: 支持读取和递增操作;<ul>\n<li><code>istream_iterator</code>: 用于从输入流读取数据;</li>\n</ul>\n</li>\n<li>输出迭代器: 支持写入和递增操作;<ul>\n<li><code>ostream_iterator</code>: 用于向输出流写入数据;</li>\n</ul>\n</li>\n<li>前向迭代器: 具有输入、输出迭代器的<strong>所有</strong>功能, 并且可以多次遍历同一个序列;<ul>\n<li>比如<code>forwarf_list</code>的迭代器:<code>auto it = flist.begin()</code> or <code>forward_list&lt;int&gt;::iterator it = flist.begin()</code>;</li>\n</ul>\n</li>\n<li>双向迭代器: 在前向迭代器的原有功能上, 同时支持<strong>递减</strong>操作;<ul>\n<li>比如双向链表<code>list</code>的迭代器.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    list&lt;<span class=\"hljs-type\">int</span>&gt; myList = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 使用双向迭代器正向遍历</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Forward traversal: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> ( list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = myList.<span class=\"hljs-built_in\">begin</span>(); it != myList.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt;  endl;<br><br>    <span class=\"hljs-comment\">// 使用双向迭代器逆向遍历</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Reverse traversal: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> ( list&lt;<span class=\"hljs-type\">int</span>&gt;::reverse_iterator rit = myList.<span class=\"hljs-built_in\">rbegin</span>(); rit != myList.<span class=\"hljs-built_in\">rend</span>(); ++rit) &#123;<br>        cout &lt;&lt; *rit &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt;  endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-comment\">// Forward traversal: 10 20 30 40 50 </span><br>    <span class=\"hljs-comment\">// Reverse traversal: 50 40 30 20 10 </span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><code>reverse_iterator</code>用于声明逆向遍历的迭代器, 也可以使用<code>auto</code>直接声明.</li>\n<li><code>rbegin()</code>和<code>rend()</code>分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的<code>++</code>相当于正向遍历时的<code>--</code>操作.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>随机访问迭代器: 具有双向迭代器的所有功能, 同时支持<strong>随机访问</strong>, 如<code>it+n</code>,<code>it[n]</code>.<ul>\n<li>比如<code>vector</code>的迭代器.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Vector elements (random access): &quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; vec.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>    cout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 使用下标随机访问</span><br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>另外, 还有一种迭代器称为<strong>插入迭代器</strong>, 比如<code>back_inserter</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br><br><span class=\"hljs-comment\">//结合copy将容器的元素直接插入到另一个容器中</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; dest = &#123;<span class=\"hljs-number\">60</span>,<span class=\"hljs-number\">70</span>&#125;;<br><span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">back_inserter</span>(dest)); <span class=\"hljs-comment\">// 在 dest 末尾插入元素</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;Copied vector: &quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : dest) &#123;<br>    cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class=\"hljs-comment\">// Copied vector: 60 70 10 20 30 40 50 </span><br></code></pre></td></tr></table></figure></p>\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环的语法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (range_declaration : range_expression) &#123;<br>    loop_statement;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 <code>auto</code>关键字让编译器自动推导类型;</li>\n<li>range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或<strong>字符串</strong>;</li>\n<li>loop_statement： 循环体，包含要对每个元素执行的语句.</li>\n</ul>\n<p>e.g:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><br>    <span class=\"hljs-comment\">// 使用 for-each 循环遍历 vector</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出每个元素</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 使用 auto 关键字自动推导类型</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 修改容器中的元素（需要使用引用）</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> &amp;num : numbers) &#123;<br>        num *= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 将每个元素乘以 2</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">// 输出修改后的元素</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> num : numbers) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li><code>for (int &amp;num : numbers)</code>：使用引用 &amp;，可以直接修改容器中的元素.</li>\n</ul>\n<h3 id=\"Map的循环\"><a href=\"#Map的循环\" class=\"headerlink\" title=\"Map的循环\"></a>Map的循环</h3><p>当range_expression是<code>map</code>时, 可以使用<code>auto</code>自动推导range_declaration的类型.需要注意是:</p>\n<ul>\n<li>用迭代器的方式访问<code>map</code>中的键值对的性质是 <code>it-&gt;first</code>与<code>it-&gt;second</code>;</li>\n<li>在<code>for-each</code>循环当中, range_declaration是一个值, 因此使用<code>.first</code>与<code>.second</code>来访问键和值.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    map&lt;string, string&gt; m = &#123;&#123;<span class=\"hljs-string\">&quot;one&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>&#125;, &#123;<span class=\"hljs-string\">&quot;two&quot;</span>, <span class=\"hljs-string\">&quot;2&quot;</span>&#125;, &#123;<span class=\"hljs-string\">&quot;three&quot;</span>, <span class=\"hljs-string\">&quot;3&quot;</span>&#125;&#125;;<br>    vector&lt;string&gt; vec;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; entry : m)&#123;<br>        vec.<span class=\"hljs-built_in\">push_back</span>(entry.first + <span class=\"hljs-string\">&quot;:&quot;</span> + entry.second );<br>    &#125;<br>    <span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">ostream_iterator</span>&lt;string&gt;(cout, <span class=\"hljs-string\">&quot; &quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n  <strong>Output:</strong>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">one:1 three:3 two:2<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>此处由于<code>map</code>自动按照键的字典序进行排序, 因此输出时<code>three</code>的元素在<code>two</code>前;</p>\n</blockquote>\n</li>\n</ul>\n<p>在上述的示例中, 也可以使用下面的方式进行<code>vec</code>的输出:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; s : vec) &#123;<br>    cout &lt;&lt; s &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>此时<code>auto</code>会自动推导为<code>string</code>类型, 且<code>&amp;</code>对数组的元素进行了引用, 使得输出更加高效.</p>\n<h3 id=\"Pro-amp-Con\"><a href=\"#Pro-amp-Con\" class=\"headerlink\" title=\"Pro&amp;Con\"></a>Pro&amp;Con</h3><p><code>for-each</code>循环的优点:</p>\n<ul>\n<li>消除了访问数组等越界的风险;</li>\n<li>不需要事先初始化迭代器;</li>\n</ul>\n<p><code>for-each</code>循环的缺点:</p>\n<ul>\n<li>无法获取元素的索引;</li>\n<li>只能顺序地遍历.</li>\n</ul>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><p>我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.</p>\n<p>而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> old_type new_type;<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"Notices\"><a href=\"#Notices\" class=\"headerlink\" title=\"Notices\"></a>Notices</h2><ol>\n<li>直接对数组、字符串和<code>vector</code>进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;</li>\n<li>对于<code>vector</code>, 可以通过<code>.at() =</code>的方式进行安全访问, 编译器会进行边界检查. 或者通过<code>.push_back()</code> or <code>.emplace_back</code>的方式在末尾赋值. 同时注意用<code>.reserve()</code>预先分配充分的内存空间.</li>\n<li>避免不经意地向<code>map</code>当中插入元素:<ol>\n<li>错误的示范:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span>(foo[<span class=\"hljs-string\">&quot;bob&quot;</span>] == <span class=\"hljs-number\">1</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure></li>\n<li>使用<code>.count()</code>方法正确检查元素是否存在:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">if</span>( foo.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-string\">&quot;bob&quot;</span>) )&#123;...&#125;<br></code></pre></td></tr></table></figure></li>\n<li>也可以使用<code>find()</code>方法检查元素是否存在:<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = m.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;four&quot;</span>);<br>   <br><span class=\"hljs-keyword\">if</span>(it  != m.<span class=\"hljs-built_in\">end</span>())&#123;<br>    cout &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-keyword\">else</span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Not found&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>使用<code>.empty()</code>方法来检查容器<strong>整体是否为空</strong>, 而非<code>.count() == 0</code>的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.</li>\n<li><p><code>erase()</code> 方法会返回<strong>指向</strong>被删除元素的<strong>下一个</strong>元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//Initialize a list</span><br>list&lt;<span class=\"hljs-type\">int</span>&gt; L;<br>list&lt;<span class=\"hljs-type\">int</span>&gt;::iterator li = L.<span class=\"hljs-built_in\">begin</span>();<br><br><span class=\"hljs-comment\">// Wrong:</span><br>L.<span class=\"hljs-built_in\">erase</span>(li);    <span class=\"hljs-comment\">// 删除元素后，li 变成了无效迭代器</span><br>++li;           <span class=\"hljs-comment\">// 错误, 不能对无效迭代器进行操作</span><br><br><span class=\"hljs-comment\">// Correct:</span><br>li = L.<span class=\"hljs-built_in\">erase</span>(li);  <span class=\"hljs-comment\">// 删除元素后，li 被更新为指向被删除元素的下一个元素</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><ul>\n<li><p>Pointers to Objects</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>string *p = &amp;str;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Oprators with Pointers</p>\n<ul>\n<li><code>&amp;</code>: 取地址;</li>\n<li><code>*</code>: 解引用;</li>\n<li><code>-&gt;</code>: 用于访问对象的成员.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">(*p).<span class=\"hljs-built_in\">length</span>();<br><span class=\"hljs-comment\">// 等价于</span><br>p-&gt;<span class=\"hljs-built_in\">length</span>();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length()</code>即为<code>string</code>类的成员函数, 因此可以用<code>-&gt;</code>来访问.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><h2 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h2><blockquote>\n<p>以<code>char</code>为例.</p>\n</blockquote>\n<ul>\n<li>常量指针 <code>char * const p</code><ul>\n<li>地址是<code>const</code>类型, 无法赋予<code>p</code>新的地址;</li>\n<li>但是可以改变指针指向对象的值.</li>\n</ul>\n</li>\n<li>指针常量 <code>char const * p</code><ul>\n<li>指针指向的值无法改变;</li>\n<li>但是可以改变指针的值(指向的对象).<br>如果需要同时保证地址和值都无法改变, 则需要使用<code>const char * const p</code>.</li>\n</ul>\n</li>\n</ul>\n<p>e.g:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = &amp;a;  <span class=\"hljs-comment\">// 常量指针</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> *p = &amp;a;  <span class=\"hljs-comment\">// 指针常量</span><br><span class=\"hljs-type\">int</span> <span class=\"hljs-type\">const</span> * <span class=\"hljs-type\">const</span> p = &amp;a;  <span class=\"hljs-comment\">// 常量指针常量</span><br><span class=\"hljs-comment\">// 错误示例</span><br><span class=\"hljs-comment\">// p = &amp;b;  // 常量指针的值无法改变</span><br><span class=\"hljs-comment\">// *p = 30;  // 指针指向的值无法改变</span><br><span class=\"hljs-comment\">// 正确示例</span><br><span class=\"hljs-type\">int</span> c = <span class=\"hljs-number\">30</span>;<br>p = &amp;c;  <span class=\"hljs-comment\">// 常量指针的值可以改变</span><br>*p = <span class=\"hljs-number\">40</span>;  <span class=\"hljs-comment\">// 指针指向的值可以改变</span><br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>to be checked.</p>\n</blockquote>\n<p>如果<code>sp</code>是指向字符串的指针, 那么这两种的写法是等价的, 注意<code>.</code>的优先级高于<code>*</code>, 因此括号不可忽略.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">sp-&gt;<span class=\"hljs-built_in\">length</span>();<br>(*sp).<span class=\"hljs-built_in\">length</span>();<br></code></pre></td></tr></table></figure>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"::\"></a><code>::</code></h3><p><code>::</code> resolver: 作用域解析运算符</p>\n<ul>\n<li><p>作用: </p>\n<ul>\n<li><p>访问全局的作用域<br>当局部变量和全局变量同名时, 可以使用 <code>::</code> 来访问全局变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> value = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 全局变量</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> value = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// 局部变量</span><br>    cout &lt;&lt; value;    <span class=\"hljs-comment\">// 输出 20（局部变量）</span><br>    cout &lt;&lt; ::value;  <span class=\"hljs-comment\">// 输出 10（全局变量）</span><br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>访问命名空间中的成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">namespace</span> Math &#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> PI = <span class=\"hljs-number\">3.14159</span>;<br>&#125;<br><br><span class=\"hljs-type\">double</span> circumference = <span class=\"hljs-number\">2</span> * Math::PI * radius; <span class=\"hljs-comment\">// 使用命名空间中的常量</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>语法:</p>\n<ul>\n<li><code>&lt;class_name&gt; :: &lt;function_name&gt;</code></li>\n<li><code>::&lt;function_name&gt;</code></li>\n</ul>\n</li>\n</ul>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">S::f</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ::<span class=\"hljs-built_in\">f</span>();  <span class=\"hljs-comment\">// Would be recursive otherwise!</span><br>    ::a++;  <span class=\"hljs-comment\">// Select the global a</span><br>    a--;    <span class=\"hljs-comment\">// The a at class scope</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>S::f()</code>: 定义了属于类S的成员函数f;</p>\n<p><code>::f()</code>:表示调用全局作用域中的函数 <code>f()</code>, 默认为递归调用当前的成员函数;</p>\n<p><code>::a++</code>表示将全局作用域的 <code>a</code> 自增, <code>a--</code>则访问并递减类作用域中的成员变量 <code>a</code>.</p>\n</blockquote>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><code>this</code></h3><p><code>this</code>指针是成员函数的隐藏参数. 指向<strong>当前对象的实例</strong>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Point::move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span></span>;<br><span class=\"hljs-comment\">//等价于</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Point::move</span><span class=\"hljs-params\">(Point *<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>当调用成员函数时, 对象的地址会自动作为 <code>this</code>参数传递.</p>\n<p>在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 <code>this</code>:</p>\n<p>e.g</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> x, y;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 移动点的位置</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span> </span>&#123;<br>        x += dx;<br>        y += dy;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 打印点的坐标</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Point at (&quot;</span> &lt;&lt; x &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 组合以上两个功能的函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">move_and_print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dx, <span class=\"hljs-type\">int</span> dy)</span> </span>&#123;<br>        <span class=\"hljs-built_in\">move</span>(dx, dy);  <span class=\"hljs-comment\">// 等同于 this-&gt;move(dx, dy)</span><br>        <span class=\"hljs-built_in\">print</span>();       <span class=\"hljs-comment\">// 等同于 this-&gt;print()</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>但是也可以显式指定 <code>this-&gt;move</code>, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.</p>\n</blockquote>\n<h3 id=\"封装特性\"><a href=\"#封装特性\" class=\"headerlink\" title=\"封装特性\"></a>封装特性</h3><p>在OOP中, Object = Attributes + Services, 即数据和操作被<strong>封装</strong>在一起, 构成一个完整的对象.</p>\n<h3 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h3><p>我们应当在头文件中声明对象的成员及其 <code>public</code>,<code>private</code>和 <code>protected</code>等属性, 并且在 <code>cpp</code>文件中给出具体的定义:</p>\n<blockquote>\n<p>最好为每个类都建立如此对应的头文件和源文件 <code>cpp</code>.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// Student.h - 类的声明</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> STUDENT_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STUDENT_H</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;  <span class=\"hljs-comment\">// 在头文件中使用</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">// 数据成员</span><br>    string name;     <span class=\"hljs-comment\">// 不再需要 std:: 前缀</span><br>    <span class=\"hljs-type\">int</span> id;<br>    <span class=\"hljs-type\">float</span> gpa;<br>    <br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数原型</span><br>    <span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">const</span> string&amp; name, <span class=\"hljs-type\">int</span> id);<br>    <br>    <span class=\"hljs-comment\">// 成员函数原型</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> string&amp; newName)</span></span>;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">calculateGPA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEligibleForScholarship</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">// STUDENT_H</span></span><br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// Student.cpp - 成员函数的定义</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;Student.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;  <span class=\"hljs-comment\">// 在源文件中使用</span><br><br><span class=\"hljs-comment\">// 构造函数实现</span><br>Student::<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">const</span> string&amp; name, <span class=\"hljs-type\">int</span> id) &#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;name = name;<br>    <span class=\"hljs-keyword\">this</span>-&gt;id = id;<br>    <span class=\"hljs-keyword\">this</span>-&gt;gpa = <span class=\"hljs-number\">0.0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 成员函数实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Student::setName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> string&amp; newName)</span> </span>&#123;<br>    name = newName;<br>&#125;<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Student::getName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Student::calculateGPA</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 实现GPA计算逻辑</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Student::isEligibleForScholarship</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> gpa &gt;= <span class=\"hljs-number\">3.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>Student::getName()</code>指的就是类 <code>Student</code>中的成员函数 <code>getName()</code>.</p>\n</blockquote>\n<p>具体来说, <code>.h</code>头文件当中应该有:</p>\n<ul>\n<li><p>外部变量的声明<br>e.g. <code>extern int globalCounter;  // 仅声明，不定义</code></p>\n</li>\n<li><p>函数原型<br>e.g. <code>int calculateSum(int a, int b);  // 函数声明，不包含实现</code></p>\n</li>\n<li><p>类/结构体的声明<br>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span>;  <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-comment\">// 或完整类声明（不含成员函数定义）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> width;<br>    <span class=\"hljs-type\">double</span> height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">double</span> w, <span class=\"hljs-type\">double</span> h);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>回顾 <code>#include</code>: 将被引用的文件插入 <code>.cpp</code> 文件当中</p>\n<ul>\n<li><p><code>#include &quot;xx.h&quot;</code>: 首先在当前目录下寻找;</p>\n</li>\n<li><p><code>#include &lt;xx.h&gt;</code>: 直接在指定的目录中寻找</p>\n<blockquote>\n<p>等价于 <code>#include &lt;xx&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<p>为了避免在多个 <code>.cpp</code> 文件中重复引用相同的头文件, 可以通过 <code>#ifndef</code>等标记来判断是否需要引用当前的头文件:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> HEADER_FLAG</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> HEADER_FLAG</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> </span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>HEADER_FLAG</code>一般使用完全大写来方便标识, 但是也可以大小写混合.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 文件: vector.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> VECTOR_H</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> VECTOR_H</span><br><span class=\"hljs-comment\">// ...</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span> <span class=\"hljs-comment\">// VECTOR_H</span></span><br></code></pre></td></tr></table></figure>\n<h2 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h2><p>当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.</p>\n<p>为了确保这些工作不被遗忘, <code>cpp</code>的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.</p>\n<h3 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.</p>\n<ul>\n<li>语法: </li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassName</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>();<br>    <br>    <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>(参数列表);<br>    <br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">ClassName</span>(<span class=\"hljs-type\">const</span> ClassName&amp; other);<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><strong>默认构造函数</strong>：不带参数或所有参数都有默认值;</li>\n<li><strong>带参数的构造函数</strong>：接受一个或多个参数;</li>\n<li><strong>拷贝构造函数</strong>：从同类型的另一个对象创建新对象.</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>构造函数初始化列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">Point::<span class=\"hljs-built_in\">Point</span>(<span class=\"hljs-type\">int</span> xx, <span class=\"hljs-type\">int</span> yy) :<span class=\"hljs-built_in\">x</span>(xx), <span class=\"hljs-built_in\">y</span>(yy) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>构造函数时, 传递参数并直接赋值给内部的成员变量 <code>x</code> , <code>y</code>.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>结构体中的构造函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Y</span> &#123; <br>    <span class=\"hljs-type\">float</span> f;     <span class=\"hljs-comment\">// 浮点型成员变量</span><br>    <span class=\"hljs-type\">int</span> i;       <span class=\"hljs-comment\">// 整型成员变量</span><br>    <span class=\"hljs-built_in\">Y</span>(<span class=\"hljs-type\">int</span> a);    <span class=\"hljs-comment\">// 声明了一个接受int参数的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>此处只是声明了构造函数需要 <code>int a</code>作为参数, 但是没有给出具体的实现;</li>\n<li>声明结构体对象 e.g. <code>Y y1[] = &#123; Y(1), Y(2), Y(3) &#125;;</code></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p><code>auto</code> default constructor: 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数:</p>\n<ul>\n<li>对于成员变量: 不进行初始化;</li>\n</ul>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 <code>~</code>. 当对象超出作用域或被显式删除时，析构函数会自动被调用.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassName</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    ~<span class=\"hljs-built_in\">ClassName</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>运用的示例:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyString</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* data;<br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>() : <span class=\"hljs-built_in\">data</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;默认构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str) &#123;<br>        <span class=\"hljs-keyword\">if</span> (str) &#123;<br>            data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-built_in\">strcpy</span>(data, str);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            data = <span class=\"hljs-literal\">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;参数构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-type\">const</span> MyString&amp; other) &#123;<br>        <span class=\"hljs-keyword\">if</span> (other.data) &#123;<br>            data = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(other.data) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-built_in\">strcpy</span>(data, other.data);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            data = <span class=\"hljs-literal\">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">MyString</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] data;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;析构函数调用&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 打印字符串</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        std::cout &lt;&lt; (data ? data : <span class=\"hljs-string\">&quot;空字符串&quot;</span>) &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 测试各种构造函数</span><br>    MyString s1;                  <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-function\">MyString <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Hello&quot;</span>)</span></span>;         <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    MyString s3 = s2;             <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <br>    s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">print</span>();<br>    s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">print</span>();<br>    s<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">print</span>();<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 所有对象在这里被销毁，调用析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li>使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.<ul>\n<li>另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Includes\"><a href=\"#Includes\" class=\"headerlink\" title=\"Includes\"></a>Includes</h2><h3 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h3><p><code>copy(first, last, result)</code>:</p>\n<ul>\n<li><code>fisrt</code>和<code>last</code>是输入迭代器, 表示要复制的范围, 左闭右开即<code>last</code>应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;</li>\n<li><code>result</code>是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作<ul>\n<li>e.g.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; source = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">destination</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>)</span></span>; <span class=\"hljs-comment\">// 确保目标容器有足够的空间</span><br><br>std::<span class=\"hljs-built_in\">copy</span>(source.<span class=\"hljs-built_in\">begin</span>(), source.<span class=\"hljs-built_in\">end</span>(), destination.<span class=\"hljs-built_in\">begin</span>());<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> num : destination) &#123;<br>    std::cout &lt;&lt; num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>; <span class=\"hljs-comment\">// 输出：1 2 3 4 5</span><br>&#125;<br>std::cout &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><code>result</code>可以直接输出到<code>cout</code>中.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++)&#123;<br>    vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>&#125;<br><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>()<span class=\"hljs-number\">+2</span>); <span class=\"hljs-comment\">//删除第三个元素</span><br><span class=\"hljs-built_in\">copy</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">ostream_iterator</span>&lt;<span class=\"hljs-type\">int</span>&gt;(cout, <span class=\"hljs-string\">&quot;,&quot;</span>));<br>cout &lt;&lt; endl;<br><span class=\"hljs-comment\">// 0,1,3,4,</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<ul>\n<li>数组之间<strong>不可以</strong>直接赋值, 但是字符串可以直接赋值<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">char</span> str1[] = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br><span class=\"hljs-type\">char</span> str2[] = <span class=\"hljs-string\">&quot;World&quot;</span>;<br>str1 = str2;  <span class=\"hljs-comment\">// 错误，数组之间不可以直接赋值</span><br><br>string s1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string s2 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br>s1 = s2;  <span class=\"hljs-comment\">// 正确，字符串可以直接赋值</span><br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string s1 = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>string s2 = <span class=\"hljs-string\">&quot;World&quot;</span>;<br><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;初始状态：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：Hello</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br><br>s1 = s2;  <span class=\"hljs-comment\">// 赋值操作</span><br><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;赋值后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br><br><span class=\"hljs-comment\">// 修改 s2 不会影响 s1，因为是深拷贝</span><br>s2 = <span class=\"hljs-string\">&quot;Changed&quot;</span>;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;修改 s2 后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：World</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出：Changed</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Temp\"><a href=\"#Temp\" class=\"headerlink\" title=\"Temp\"></a>Temp</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 迭代器</span><br>I.<span class=\"hljs-built_in\">begin</span>();<br>I.<span class=\"hljs-built_in\">end</span>();<br><br><span class=\"hljs-comment\">// Item Access</span><br>V.<span class=\"hljs-built_in\">front</span>();;<br>V.<span class=\"hljs-built_in\">back</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h2><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find</code>是字符串类的一种方法, 同时也是标准库<code>algorithm</code>中的一个函数.</p>\n<ul>\n<li><code>find</code>方法: 用于在字符串中查找子字符串的位置。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br><span class=\"hljs-type\">size_t</span> pos = str.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;World&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (pos != string::npos) &#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Found &#x27;World&#x27; at position &quot;</span> &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><code>algorithm</code>中的<code>find</code>函数: 用于在容器（如数组、向量等）中查找元素。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = <span class=\"hljs-built_in\">find</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">3</span>);<br>    <span class=\"hljs-keyword\">if</span> (it != vec.<span class=\"hljs-built_in\">end</span>()) &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Found 3 at position &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">distance</span>(vec.<span class=\"hljs-built_in\">begin</span>(), it) &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// Found 3 at position 2</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>编译: <code>g++ -std=c++11 test.cpp -o test</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase\"></a>erase</h3><ul>\n<li>对于字符串的方法: <code>str.erase(pos, len)</code><ul>\n<li>删除从指定位置开始的指定个数字符<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string str = <span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>str.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>);<br>cout &lt;&lt; str &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出: Hello</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>对于容器的方法: <code>erase(pos1, pos2)</code><ul>\n<li>左闭右开式删除容器当中的元素.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; vec = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>&#125;;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Original vector: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class=\"hljs-comment\">// 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素</span><br>    vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">1</span>, vec.<span class=\"hljs-built_in\">begin</span>() + <span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 删除 vec[1], vec[2], vec[3]</span><br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Modified vector: &quot;</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : vec) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl; <span class=\"hljs-comment\">// 输出 &quot;1 5 6&quot;</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"不知道放在哪里的代码块\"><a href=\"#不知道放在哪里的代码块\" class=\"headerlink\" title=\"不知道放在哪里的代码块\"></a>不知道放在哪里的代码块</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// 1. 创建并填充链表</span><br>list&lt;<span class=\"hljs-type\">int</span>&gt; L;                      <span class=\"hljs-comment\">// 创建一个空的整数链表</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>; i&lt;=<span class=\"hljs-number\">5</span>; ++i)          <span class=\"hljs-comment\">// 循环5次</span><br>    L.<span class=\"hljs-built_in\">push_back</span>(i);              <span class=\"hljs-comment\">// 依次在链表尾部添加数字1,2,3,4,5</span><br>                                 <span class=\"hljs-comment\">// 此时链表内容为：1,2,3,4,5</span><br><br><span class=\"hljs-comment\">// 2. 删除第二个元素</span><br>L.<span class=\"hljs-built_in\">erase</span>( ++L.<span class=\"hljs-built_in\">begin</span>() );          <span class=\"hljs-comment\">// L.begin()指向第一个元素</span><br>                                 <span class=\"hljs-comment\">// ++L.begin()指向第二个元素</span><br>                                 <span class=\"hljs-comment\">// erase删除迭代器指向的元素</span><br>                                 <span class=\"hljs-comment\">// 此时链表内容为：1,3,4,5</span><br><br><span class=\"hljs-comment\">// 3. 打印链表内容</span><br><span class=\"hljs-built_in\">copy</span>(                            <span class=\"hljs-comment\">// 标准库算法，用于复制序列</span><br>    L.<span class=\"hljs-built_in\">begin</span>(),                   <span class=\"hljs-comment\">// 源序列的起始位置</span><br>    L.<span class=\"hljs-built_in\">end</span>(),                     <span class=\"hljs-comment\">// 源序列的结束位置</span><br>    <span class=\"hljs-built_in\">ostream_iterator</span>&lt;<span class=\"hljs-type\">int</span>&gt;(       <span class=\"hljs-comment\">// 输出流迭代器</span><br>        cout,                    <span class=\"hljs-comment\">// 指定输出到标准输出</span><br>        <span class=\"hljs-string\">&quot;,&quot;</span>                      <span class=\"hljs-comment\">// 每个元素后面追加的分隔符</span><br>    )<br>);<br>cout &lt;&lt; endl;                    <span class=\"hljs-comment\">// 换行</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"课堂缓冲区\"><a href=\"#课堂缓冲区\" class=\"headerlink\" title=\"课堂缓冲区\"></a>课堂缓冲区</h1><h1 id=\"题目梳理\"><a href=\"#题目梳理\" class=\"headerlink\" title=\"题目梳理\"></a>题目梳理</h1><h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><p><img src=\"cpp学习记录.assets/image-20250225160042809.png\" alt=\"image-20250225160042809\"></p>\n<ul>\n<li>ANS:  B</li>\n<li>由于此处的<code>map</code>以<code>char *</code>作为key, 同时初始化<code>str</code>的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.</li>\n</ul>\n<hr>\n<p><img src=\"cpp学习记录.assets/image-20250225160652522.png\" alt=\"image-20250225160652522\"></p>\n<ul>\n<li>逗号表达式, 结果为1. </li>\n</ul>\n"},{"title":"css笔记","date":"2025-01-08T10:33:32.000Z","index_img":"/img/Aniya.png","excerpt":"css属性好多好复杂😶‍🌫️","_content":"> [在线编辑平台](https://jsfiddle.net/?locale=zh_CN)\n\n\n### 伪元素\n使用伪元素`before`和`after`可以为元素添加内容.\n```html\n<div class=\"author\">待抉</div>\n\n<style>\n.author:before {\n  content: \"Author: \";\n  font-weight: bold; /* 加粗字体 */\n  color: blue; /* 文本颜色为蓝色 */\n}\n.author:after {\n  content: \" ✍️\";\n  font-size: 1.2em; /* 调整图标大小 */\n  margin-left: 5px; /* 添加左边距 */\n}\n</style>\n```\n\n\n`:nth-child`可用于对序列中不同的元素进行有序的样式设计:\n```html\n<div class=\"index-card\">内容1</div>\n<div class=\"index-card\">内容2</div>\n<div class=\"index-card\">内容3</div>\n<div class=\"index-card\">内容4</div>\n\n<style>\n.index-card:nth-child(odd) {\n  flex-direction: row-reverse;\n}\n</style>\n```\n- 选择所有类名为 \"index-card\" 的元素;\n- `row-reverse` 会让 flex 容器中的项目从右到左排列;\n> 同理, `even`选择偶数位置的元素; `3n+1`等函数表达式也可以起作用.\n\n### 基本的元素属性\n#### 布局属性\n- `margin`: 控制元素的外边距;\n- `padding`: 控制元素的内边距;\n\n#### 文本属性\n- `font-size`: 控制字体大小;\n- `font-weight`: 控制字体粗细;\n- `text-align`: 控制文本的对齐方式;\n- `text-decoration`: 控制文本的装饰;\n- `line-height`: 控制行高;\n- `letter-spacing`: 控制字符间距;\n- `text-transform`: 控制文本的大小写;\n\n#### 边框属性\n- `border`: e.g. `border: 1px solid red;` 简写属性;\n- `border-radius`: 控制元素的圆角;\n- `border-style`: solid, dashed, dotted...\n\n#### 其他\n- `overflow`: visible, hidden, scroll, auto;\n- `opacity`: 控制元素的透明度;\n- `cursor`: pointer, default, move, not-allowed...\n\n### 动感魔法\n#### hover效果\n通过为class设置`:hover`伪类，可以为元素添加鼠标悬停时的效果。\n```css\n.my-element:hover {\n  background-color: green;\n  color: red;\n  transform: scale(1.1);\n  font-size:20px;\n}\n```\n> 空格将不会被忽略, 需要确保类名与`:hover`之间不存在空格;\n\n其他的一些常用的伪类:\n```css\na:hover {\n      color: red;\n    }\n    button:active {\n      background-color: green;\n    }\n    input:focus {\n      border-color: blue;\n    }\n    a:visited {\n      color: purple;\n    }\n    p:first-child {\n      font-weight: bold;\n    }\n    p:last-child {\n      font-style: italic;\n    }\n    li:nth-child(2) {\n      color: red;\n    }\n    p:only-child {\n      color: green;\n    }\n    div:empty {\n      background-color: yellow;\n    }\n```\n\n### Flex\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    /* 定义Flex容器 */\n    .container {\n      display: flex; /* 将容器设置为Flexbox容器 */\n      \n      /* flex-direction: 定义主轴方向 */\n      /* row: 水平从左到右（默认） */\n      /* row-reverse: 水平从右到左 */\n      /* column: 垂直从上到下 */\n      /* column-reverse: 垂直从下到上 */\n      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */\n\n      /* flex-wrap: 定义是否换行 */\n      /* nowrap: 不换行（默认） */\n      /* wrap: 换行 */\n      /* wrap-reverse: 反向换行 */\n      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */\n\n      /* flex-flow: flex-direction 和 flex-wrap 的简写 */\n      /* flex-flow: <flex-direction> <flex-wrap>; */\n      flex-flow: row wrap; /* 可以改为column nowrap等组合 */\n\n      /* justify-content: 定义在主轴上的对齐方式 */\n      /* flex-start: 起始对齐（默认） */\n      /* flex-end: 末端对齐 */\n      /* center: 居中对齐 */\n      /* space-between: 两端对齐，项目之间间隔相等 */\n      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */\n      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */\n      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */\n\n      /* align-items: 定义在交叉轴上的对齐方式 */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* baseline: 项目基线对齐 */\n      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */\n\n      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* space-between: 多行两端对齐，行之间间隔相等 */\n      /* space-around: 多行之间间隔相等，行两边有半个间隔 */\n      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */\n      \n      height: 100vh; /* 设置容器高度 */\n      background-color: #f0f0f0; /* 设置容器背景颜色 */\n    }\n    \n    /* 定义Flex项目 */\n    .item {\n      flex: 1; /* 设置项目的flex属性，项目平分空间 */\n      padding: 20px; /* 设置项目内边距 */\n      background-color: lightblue; /* 设置项目背景颜色 */\n      margin: 10px; /* 设置项目外边距 */\n      text-align: center; /* 设置项目文本居中 */\n      flex-grow: 1;/*尝试向flex容器扩展空间*/\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item\">Item 1</div>\n    <div class=\"item\">Item 2</div>\n    <div class=\"item\">Item 3</div>\n  </div>\n</body>\n</html>\n```\n\n","source":"_posts/编程语言/css笔记.md","raw":"---\ntitle: css笔记\ndate: 2025-01-08 18:33:32\ntags:\n- 前端\n- CSS\nindex_img: /img/Aniya.png\ncategories: 学习笔记\nexcerpt: css属性好多好复杂😶‍🌫️\n---\n> [在线编辑平台](https://jsfiddle.net/?locale=zh_CN)\n\n\n### 伪元素\n使用伪元素`before`和`after`可以为元素添加内容.\n```html\n<div class=\"author\">待抉</div>\n\n<style>\n.author:before {\n  content: \"Author: \";\n  font-weight: bold; /* 加粗字体 */\n  color: blue; /* 文本颜色为蓝色 */\n}\n.author:after {\n  content: \" ✍️\";\n  font-size: 1.2em; /* 调整图标大小 */\n  margin-left: 5px; /* 添加左边距 */\n}\n</style>\n```\n\n\n`:nth-child`可用于对序列中不同的元素进行有序的样式设计:\n```html\n<div class=\"index-card\">内容1</div>\n<div class=\"index-card\">内容2</div>\n<div class=\"index-card\">内容3</div>\n<div class=\"index-card\">内容4</div>\n\n<style>\n.index-card:nth-child(odd) {\n  flex-direction: row-reverse;\n}\n</style>\n```\n- 选择所有类名为 \"index-card\" 的元素;\n- `row-reverse` 会让 flex 容器中的项目从右到左排列;\n> 同理, `even`选择偶数位置的元素; `3n+1`等函数表达式也可以起作用.\n\n### 基本的元素属性\n#### 布局属性\n- `margin`: 控制元素的外边距;\n- `padding`: 控制元素的内边距;\n\n#### 文本属性\n- `font-size`: 控制字体大小;\n- `font-weight`: 控制字体粗细;\n- `text-align`: 控制文本的对齐方式;\n- `text-decoration`: 控制文本的装饰;\n- `line-height`: 控制行高;\n- `letter-spacing`: 控制字符间距;\n- `text-transform`: 控制文本的大小写;\n\n#### 边框属性\n- `border`: e.g. `border: 1px solid red;` 简写属性;\n- `border-radius`: 控制元素的圆角;\n- `border-style`: solid, dashed, dotted...\n\n#### 其他\n- `overflow`: visible, hidden, scroll, auto;\n- `opacity`: 控制元素的透明度;\n- `cursor`: pointer, default, move, not-allowed...\n\n### 动感魔法\n#### hover效果\n通过为class设置`:hover`伪类，可以为元素添加鼠标悬停时的效果。\n```css\n.my-element:hover {\n  background-color: green;\n  color: red;\n  transform: scale(1.1);\n  font-size:20px;\n}\n```\n> 空格将不会被忽略, 需要确保类名与`:hover`之间不存在空格;\n\n其他的一些常用的伪类:\n```css\na:hover {\n      color: red;\n    }\n    button:active {\n      background-color: green;\n    }\n    input:focus {\n      border-color: blue;\n    }\n    a:visited {\n      color: purple;\n    }\n    p:first-child {\n      font-weight: bold;\n    }\n    p:last-child {\n      font-style: italic;\n    }\n    li:nth-child(2) {\n      color: red;\n    }\n    p:only-child {\n      color: green;\n    }\n    div:empty {\n      background-color: yellow;\n    }\n```\n\n### Flex\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    /* 定义Flex容器 */\n    .container {\n      display: flex; /* 将容器设置为Flexbox容器 */\n      \n      /* flex-direction: 定义主轴方向 */\n      /* row: 水平从左到右（默认） */\n      /* row-reverse: 水平从右到左 */\n      /* column: 垂直从上到下 */\n      /* column-reverse: 垂直从下到上 */\n      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */\n\n      /* flex-wrap: 定义是否换行 */\n      /* nowrap: 不换行（默认） */\n      /* wrap: 换行 */\n      /* wrap-reverse: 反向换行 */\n      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */\n\n      /* flex-flow: flex-direction 和 flex-wrap 的简写 */\n      /* flex-flow: <flex-direction> <flex-wrap>; */\n      flex-flow: row wrap; /* 可以改为column nowrap等组合 */\n\n      /* justify-content: 定义在主轴上的对齐方式 */\n      /* flex-start: 起始对齐（默认） */\n      /* flex-end: 末端对齐 */\n      /* center: 居中对齐 */\n      /* space-between: 两端对齐，项目之间间隔相等 */\n      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */\n      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */\n      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */\n\n      /* align-items: 定义在交叉轴上的对齐方式 */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* baseline: 项目基线对齐 */\n      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */\n\n      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* space-between: 多行两端对齐，行之间间隔相等 */\n      /* space-around: 多行之间间隔相等，行两边有半个间隔 */\n      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */\n      \n      height: 100vh; /* 设置容器高度 */\n      background-color: #f0f0f0; /* 设置容器背景颜色 */\n    }\n    \n    /* 定义Flex项目 */\n    .item {\n      flex: 1; /* 设置项目的flex属性，项目平分空间 */\n      padding: 20px; /* 设置项目内边距 */\n      background-color: lightblue; /* 设置项目背景颜色 */\n      margin: 10px; /* 设置项目外边距 */\n      text-align: center; /* 设置项目文本居中 */\n      flex-grow: 1;/*尝试向flex容器扩展空间*/\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item\">Item 1</div>\n    <div class=\"item\">Item 2</div>\n    <div class=\"item\">Item 3</div>\n  </div>\n</body>\n</html>\n```\n\n","slug":"编程语言/css笔记","published":1,"updated":"2025-01-19T11:46:34.124Z","comments":1,"layout":"post","photos":[],"_id":"cm79tw4w00026dwqg4y6afm9z","content":"<blockquote>\n<p><a href=\"https://jsfiddle.net/?locale=zh_CN\">在线编辑平台</a></p>\n</blockquote>\n<h3 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h3><p>使用伪元素<code>before</code>和<code>after</code>可以为元素添加内容.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;author&quot;</span>&gt;</span>待抉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.author</span><span class=\"hljs-selector-pseudo\">:before</span> &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;Author: &quot;</span>;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">font-weight</span>: bold; <span class=\"hljs-comment\">/* 加粗字体 */</span></span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">color</span>: blue; <span class=\"hljs-comment\">/* 文本颜色为蓝色 */</span></span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.author</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot; ✍️&quot;</span>;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.2em</span>; <span class=\"hljs-comment\">/* 调整图标大小 */</span></span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">5px</span>; <span class=\"hljs-comment\">/* 添加左边距 */</span></span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><code>:nth-child</code>可用于对序列中不同的元素进行有序的样式设计:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.index-card</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(odd) &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">flex-direction</span>: row-reverse;</span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>选择所有类名为 “index-card” 的元素;</li>\n<li><code>row-reverse</code> 会让 flex 容器中的项目从右到左排列;<blockquote>\n<p>同理, <code>even</code>选择偶数位置的元素; <code>3n+1</code>等函数表达式也可以起作用.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"基本的元素属性\"><a href=\"#基本的元素属性\" class=\"headerlink\" title=\"基本的元素属性\"></a>基本的元素属性</h3><h4 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h4><ul>\n<li><code>margin</code>: 控制元素的外边距;</li>\n<li><code>padding</code>: 控制元素的内边距;</li>\n</ul>\n<h4 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h4><ul>\n<li><code>font-size</code>: 控制字体大小;</li>\n<li><code>font-weight</code>: 控制字体粗细;</li>\n<li><code>text-align</code>: 控制文本的对齐方式;</li>\n<li><code>text-decoration</code>: 控制文本的装饰;</li>\n<li><code>line-height</code>: 控制行高;</li>\n<li><code>letter-spacing</code>: 控制字符间距;</li>\n<li><code>text-transform</code>: 控制文本的大小写;</li>\n</ul>\n<h4 id=\"边框属性\"><a href=\"#边框属性\" class=\"headerlink\" title=\"边框属性\"></a>边框属性</h4><ul>\n<li><code>border</code>: e.g. <code>border: 1px solid red;</code> 简写属性;</li>\n<li><code>border-radius</code>: 控制元素的圆角;</li>\n<li><code>border-style</code>: solid, dashed, dotted…</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><code>overflow</code>: visible, hidden, scroll, auto;</li>\n<li><code>opacity</code>: 控制元素的透明度;</li>\n<li><code>cursor</code>: pointer, default, move, not-allowed…</li>\n</ul>\n<h3 id=\"动感魔法\"><a href=\"#动感魔法\" class=\"headerlink\" title=\"动感魔法\"></a>动感魔法</h3><h4 id=\"hover效果\"><a href=\"#hover效果\" class=\"headerlink\" title=\"hover效果\"></a>hover效果</h4><p>通过为class设置<code>:hover</code>伪类，可以为元素添加鼠标悬停时的效果。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.my-element</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: green;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-number\">1.1</span>);<br>  <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>空格将不会被忽略, 需要确保类名与<code>:hover</code>之间不存在空格;</p>\n</blockquote>\n<p>其他的一些常用的伪类:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-pseudo\">:active</span> &#123;<br>      <span class=\"hljs-attribute\">background-color</span>: green;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-pseudo\">:focus</span> &#123;<br>      <span class=\"hljs-attribute\">border-color</span>: blue;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:visited</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: purple;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:first-child</span> &#123;<br>      <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:last-child</span> &#123;<br>      <span class=\"hljs-attribute\">font-style</span>: italic;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>) &#123;<br>      <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:only-child</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:empty</span> &#123;<br>      <span class=\"hljs-attribute\">background-color</span>: yellow;<br>    &#125;<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">    <span class=\"hljs-comment\">/* 定义Flex容器 */</span></span><br><span class=\"language-css\">    <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">display</span>: flex; <span class=\"hljs-comment\">/* 将容器设置为Flexbox容器 */</span></span><br><span class=\"language-css\">      </span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-direction: 定义主轴方向 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* row: 水平从左到右（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* row-reverse: 水平从右到左 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* column: 垂直从上到下 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* column-reverse: 垂直从下到上 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-direction</span>: row; <span class=\"hljs-comment\">/* 可以改为row-reverse, column, column-reverse */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-wrap: 定义是否换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* nowrap: 不换行（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* wrap: 换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* wrap-reverse: 反向换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-wrap</span>: wrap; <span class=\"hljs-comment\">/* 可以改为nowrap, wrap-reverse */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-flow: flex-direction 和 flex-wrap 的简写 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-flow</span>: row wrap; <span class=\"hljs-comment\">/* 可以改为column nowrap等组合 */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* justify-content: 定义在主轴上的对齐方式 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 起始对齐（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-between: 两端对齐，项目之间间隔相等 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-around: 项目之间间隔相等，项目两边有半个间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">justify-content</span>: space-between; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, center, space-around, space-evenly */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* align-items: 定义在交叉轴上的对齐方式 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 交叉轴居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* baseline: 项目基线对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">align-items</span>: center; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, stretch, baseline */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 交叉轴居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-between: 多行两端对齐，行之间间隔相等 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-around: 多行之间间隔相等，行两边有半个间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">align-content</span>: space-between; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, center, space-around */</span></span><br><span class=\"language-css\">      </span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>; <span class=\"hljs-comment\">/* 设置容器高度 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f0f0f0</span>; <span class=\"hljs-comment\">/* 设置容器背景颜色 */</span></span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">    </span><br><span class=\"language-css\">    <span class=\"hljs-comment\">/* 定义Flex项目 */</span></span><br><span class=\"language-css\">    <span class=\"hljs-selector-class\">.item</span> &#123;</span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* 设置项目的flex属性，项目平分空间 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>; <span class=\"hljs-comment\">/* 设置项目内边距 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">background-color</span>: lightblue; <span class=\"hljs-comment\">/* 设置项目背景颜色 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>; <span class=\"hljs-comment\">/* 设置项目外边距 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">text-align</span>: center; <span class=\"hljs-comment\">/* 设置项目文本居中 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-grow</span>: <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">/*尝试向flex容器扩展空间*/</span></span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n","more":"<blockquote>\n<p><a href=\"https://jsfiddle.net/?locale=zh_CN\">在线编辑平台</a></p>\n</blockquote>\n<h3 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h3><p>使用伪元素<code>before</code>和<code>after</code>可以为元素添加内容.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;author&quot;</span>&gt;</span>待抉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.author</span><span class=\"hljs-selector-pseudo\">:before</span> &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot;Author: &quot;</span>;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">font-weight</span>: bold; <span class=\"hljs-comment\">/* 加粗字体 */</span></span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">color</span>: blue; <span class=\"hljs-comment\">/* 文本颜色为蓝色 */</span></span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.author</span><span class=\"hljs-selector-pseudo\">:after</span> &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&quot; ✍️&quot;</span>;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">1.2em</span>; <span class=\"hljs-comment\">/* 调整图标大小 */</span></span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">5px</span>; <span class=\"hljs-comment\">/* 添加左边距 */</span></span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<p><code>:nth-child</code>可用于对序列中不同的元素进行有序的样式设计:<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;index-card&quot;</span>&gt;</span>内容4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\"><span class=\"hljs-selector-class\">.index-card</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(odd) &#123;</span><br><span class=\"language-css\">  <span class=\"hljs-attribute\">flex-direction</span>: row-reverse;</span><br><span class=\"language-css\">&#125;</span><br><span class=\"language-css\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>选择所有类名为 “index-card” 的元素;</li>\n<li><code>row-reverse</code> 会让 flex 容器中的项目从右到左排列;<blockquote>\n<p>同理, <code>even</code>选择偶数位置的元素; <code>3n+1</code>等函数表达式也可以起作用.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"基本的元素属性\"><a href=\"#基本的元素属性\" class=\"headerlink\" title=\"基本的元素属性\"></a>基本的元素属性</h3><h4 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h4><ul>\n<li><code>margin</code>: 控制元素的外边距;</li>\n<li><code>padding</code>: 控制元素的内边距;</li>\n</ul>\n<h4 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h4><ul>\n<li><code>font-size</code>: 控制字体大小;</li>\n<li><code>font-weight</code>: 控制字体粗细;</li>\n<li><code>text-align</code>: 控制文本的对齐方式;</li>\n<li><code>text-decoration</code>: 控制文本的装饰;</li>\n<li><code>line-height</code>: 控制行高;</li>\n<li><code>letter-spacing</code>: 控制字符间距;</li>\n<li><code>text-transform</code>: 控制文本的大小写;</li>\n</ul>\n<h4 id=\"边框属性\"><a href=\"#边框属性\" class=\"headerlink\" title=\"边框属性\"></a>边框属性</h4><ul>\n<li><code>border</code>: e.g. <code>border: 1px solid red;</code> 简写属性;</li>\n<li><code>border-radius</code>: 控制元素的圆角;</li>\n<li><code>border-style</code>: solid, dashed, dotted…</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><code>overflow</code>: visible, hidden, scroll, auto;</li>\n<li><code>opacity</code>: 控制元素的透明度;</li>\n<li><code>cursor</code>: pointer, default, move, not-allowed…</li>\n</ul>\n<h3 id=\"动感魔法\"><a href=\"#动感魔法\" class=\"headerlink\" title=\"动感魔法\"></a>动感魔法</h3><h4 id=\"hover效果\"><a href=\"#hover效果\" class=\"headerlink\" title=\"hover效果\"></a>hover效果</h4><p>通过为class设置<code>:hover</code>伪类，可以为元素添加鼠标悬停时的效果。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.my-element</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">background-color</span>: green;<br>  <span class=\"hljs-attribute\">color</span>: red;<br>  <span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-number\">1.1</span>);<br>  <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<blockquote>\n<p>空格将不会被忽略, 需要确保类名与<code>:hover</code>之间不存在空格;</p>\n</blockquote>\n<p>其他的一些常用的伪类:<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">button</span><span class=\"hljs-selector-pseudo\">:active</span> &#123;<br>      <span class=\"hljs-attribute\">background-color</span>: green;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">input</span><span class=\"hljs-selector-pseudo\">:focus</span> &#123;<br>      <span class=\"hljs-attribute\">border-color</span>: blue;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:visited</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: purple;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:first-child</span> &#123;<br>      <span class=\"hljs-attribute\">font-weight</span>: bold;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:last-child</span> &#123;<br>      <span class=\"hljs-attribute\">font-style</span>: italic;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">li</span><span class=\"hljs-selector-pseudo\">:nth-child</span>(<span class=\"hljs-number\">2</span>) &#123;<br>      <span class=\"hljs-attribute\">color</span>: red;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">p</span><span class=\"hljs-selector-pseudo\">:only-child</span> &#123;<br>      <span class=\"hljs-attribute\">color</span>: green;<br>    &#125;<br>    <span class=\"hljs-selector-tag\">div</span><span class=\"hljs-selector-pseudo\">:empty</span> &#123;<br>      <span class=\"hljs-attribute\">background-color</span>: yellow;<br>    &#125;<br></code></pre></td></tr></table></figure></p>\n<h3 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">    <span class=\"hljs-comment\">/* 定义Flex容器 */</span></span><br><span class=\"language-css\">    <span class=\"hljs-selector-class\">.container</span> &#123;</span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">display</span>: flex; <span class=\"hljs-comment\">/* 将容器设置为Flexbox容器 */</span></span><br><span class=\"language-css\">      </span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-direction: 定义主轴方向 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* row: 水平从左到右（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* row-reverse: 水平从右到左 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* column: 垂直从上到下 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* column-reverse: 垂直从下到上 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-direction</span>: row; <span class=\"hljs-comment\">/* 可以改为row-reverse, column, column-reverse */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-wrap: 定义是否换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* nowrap: 不换行（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* wrap: 换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* wrap-reverse: 反向换行 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-wrap</span>: wrap; <span class=\"hljs-comment\">/* 可以改为nowrap, wrap-reverse */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-flow: flex-direction 和 flex-wrap 的简写 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-flow</span>: row wrap; <span class=\"hljs-comment\">/* 可以改为column nowrap等组合 */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* justify-content: 定义在主轴上的对齐方式 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 起始对齐（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-between: 两端对齐，项目之间间隔相等 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-around: 项目之间间隔相等，项目两边有半个间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">justify-content</span>: space-between; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, center, space-around, space-evenly */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* align-items: 定义在交叉轴上的对齐方式 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 交叉轴居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* baseline: 项目基线对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">align-items</span>: center; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, stretch, baseline */</span></span><br><span class=\"language-css\"></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* center: 交叉轴居中对齐 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-between: 多行两端对齐，行之间间隔相等 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-comment\">/* space-around: 多行之间间隔相等，行两边有半个间隔 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">align-content</span>: space-between; <span class=\"hljs-comment\">/* 可以改为flex-start, flex-end, center, space-around */</span></span><br><span class=\"language-css\">      </span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100vh</span>; <span class=\"hljs-comment\">/* 设置容器高度 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f0f0f0</span>; <span class=\"hljs-comment\">/* 设置容器背景颜色 */</span></span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">    </span><br><span class=\"language-css\">    <span class=\"hljs-comment\">/* 定义Flex项目 */</span></span><br><span class=\"language-css\">    <span class=\"hljs-selector-class\">.item</span> &#123;</span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">/* 设置项目的flex属性，项目平分空间 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>; <span class=\"hljs-comment\">/* 设置项目内边距 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">background-color</span>: lightblue; <span class=\"hljs-comment\">/* 设置项目背景颜色 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">10px</span>; <span class=\"hljs-comment\">/* 设置项目外边距 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">text-align</span>: center; <span class=\"hljs-comment\">/* 设置项目文本居中 */</span></span><br><span class=\"language-css\">      <span class=\"hljs-attribute\">flex-grow</span>: <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">/*尝试向flex容器扩展空间*/</span></span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>Item 3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"Latex","date":"2025-02-19T07:43:53.000Z","excerpt":"课程笔记","math":true,"_content":"\n| 类别 | 说明 | LaTeX语法 | 显示效果 |\n|------|------|-----------|-----------|\n| **基础符号** ||||\n| 上标 | 次方 | `x^2` | $ x^2 $ |\n| 下标 | 下标 | `x_i` | $ x_i $ |\n| 分数 | 分数 | `\\frac{a}{b}` | $ \\frac{a}{b} $ |\n| 与运算 | and | `\\wedge` | $ \\wedge $ |\n| 或运算 | or | `\\vee` | $ \\vee $ |\n| 非运算 | not | `\\neg` | $ \\neg $ |\n| 集合 | 集合 | `\\{a, b, c\\}` | $ \\{a, b, c\\} $ |\n| **希腊字母** ||||\n| alpha | α | `\\alpha` | $ \\alpha $ |\n| beta | β | `\\beta` | $ \\beta $ |\n| gamma | γ | `\\gamma` | $ \\gamma $ |\n| theta | θ | `\\theta` | $ \\theta $ |\n| pi | π | `\\pi` | $ \\pi $ |\n| sigma | σ | `\\sigma` | $ \\sigma $ |\n| omega | ω | `\\omega` | $ \\omega $ |\n| **运算符号** ||||\n| 求和 | 求和符号 | `\\sum_{i=1}^n` | $ \\sum_{i=1}^n $ |\n| 积分 | 积分符号 | `\\int_{a}^b` | $ \\int_{a}^b $ |\n| 乘积 | 连乘符号 | `\\prod_{i=1}^n` | $ \\prod_{i=1}^n $ |\n| 极限 | 极限 | `\\lim_{x \\to \\infty}` | $ \\lim_{x \\to \\infty} $ |\n| **关系符号** ||||\n| 不等号 | 大于等于 | `\\geq` | $ \\geq $ |\n| 不等号 | 小于等于 | `\\leq` | $ \\leq $ |\n| 约等于 | 约等于 | `\\approx` | $ \\approx $ |\n| 属于 | 属于 | `\\in` | $ \\in $ |\n| 基本同余符号 |  |` a \\equiv b ` | $ a \\equiv b $\n| **其他常用** ||||\n| 根号 | 开方 | `\\sqrt{x}` | $ \\sqrt{x} $ |\n| n次方根 | n次方根 | `\\sqrt[n]{x}` | $ \\sqrt[n]{x} $ |\n| 向量 | 向量符号 | `\\vec{a}` | $ \\vec{a} $ |\n| 无穷 | 无穷符号 | `\\infty` | $ \\infty $ |\n| 偏导 | 偏导符号 | `\\partial` | $ \\partial $ |\n","source":"_posts/latex.md","raw":"---\ntitle: Latex\ndate: 2025-02-19 15:43:53\ntags: latex\ncategories: 备忘录\nexcerpt: 课程笔记\nmath: true\n---\n\n| 类别 | 说明 | LaTeX语法 | 显示效果 |\n|------|------|-----------|-----------|\n| **基础符号** ||||\n| 上标 | 次方 | `x^2` | $ x^2 $ |\n| 下标 | 下标 | `x_i` | $ x_i $ |\n| 分数 | 分数 | `\\frac{a}{b}` | $ \\frac{a}{b} $ |\n| 与运算 | and | `\\wedge` | $ \\wedge $ |\n| 或运算 | or | `\\vee` | $ \\vee $ |\n| 非运算 | not | `\\neg` | $ \\neg $ |\n| 集合 | 集合 | `\\{a, b, c\\}` | $ \\{a, b, c\\} $ |\n| **希腊字母** ||||\n| alpha | α | `\\alpha` | $ \\alpha $ |\n| beta | β | `\\beta` | $ \\beta $ |\n| gamma | γ | `\\gamma` | $ \\gamma $ |\n| theta | θ | `\\theta` | $ \\theta $ |\n| pi | π | `\\pi` | $ \\pi $ |\n| sigma | σ | `\\sigma` | $ \\sigma $ |\n| omega | ω | `\\omega` | $ \\omega $ |\n| **运算符号** ||||\n| 求和 | 求和符号 | `\\sum_{i=1}^n` | $ \\sum_{i=1}^n $ |\n| 积分 | 积分符号 | `\\int_{a}^b` | $ \\int_{a}^b $ |\n| 乘积 | 连乘符号 | `\\prod_{i=1}^n` | $ \\prod_{i=1}^n $ |\n| 极限 | 极限 | `\\lim_{x \\to \\infty}` | $ \\lim_{x \\to \\infty} $ |\n| **关系符号** ||||\n| 不等号 | 大于等于 | `\\geq` | $ \\geq $ |\n| 不等号 | 小于等于 | `\\leq` | $ \\leq $ |\n| 约等于 | 约等于 | `\\approx` | $ \\approx $ |\n| 属于 | 属于 | `\\in` | $ \\in $ |\n| 基本同余符号 |  |` a \\equiv b ` | $ a \\equiv b $\n| **其他常用** ||||\n| 根号 | 开方 | `\\sqrt{x}` | $ \\sqrt{x} $ |\n| n次方根 | n次方根 | `\\sqrt[n]{x}` | $ \\sqrt[n]{x} $ |\n| 向量 | 向量符号 | `\\vec{a}` | $ \\vec{a} $ |\n| 无穷 | 无穷符号 | `\\infty` | $ \\infty $ |\n| 偏导 | 偏导符号 | `\\partial` | $ \\partial $ |\n","slug":"latex","published":1,"updated":"2025-02-22T06:55:35.810Z","_id":"cm7ct9xz70000cpqg8i450sb5","comments":1,"layout":"post","photos":[],"content":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>说明</th>\n<th>LaTeX语法</th>\n<th>显示效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>基础符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>上标</td>\n<td>次方</td>\n<td><code>x^2</code></td>\n<td>$ x^2 $</td>\n</tr>\n<tr>\n<td>下标</td>\n<td>下标</td>\n<td><code>x_i</code></td>\n<td>$ x_i $</td>\n</tr>\n<tr>\n<td>分数</td>\n<td>分数</td>\n<td><code>\\frac&#123;a&#125;&#123;b&#125;</code></td>\n<td>$ \\frac{a}{b} $</td>\n</tr>\n<tr>\n<td>与运算</td>\n<td>and</td>\n<td><code>\\wedge</code></td>\n<td>$ \\wedge $</td>\n</tr>\n<tr>\n<td>或运算</td>\n<td>or</td>\n<td><code>\\vee</code></td>\n<td>$ \\vee $</td>\n</tr>\n<tr>\n<td>非运算</td>\n<td>not</td>\n<td><code>\\neg</code></td>\n<td>$ \\neg $</td>\n</tr>\n<tr>\n<td>集合</td>\n<td>集合</td>\n<td><code>\\&#123;a, b, c\\&#125;</code></td>\n<td>$ {a, b, c} $</td>\n</tr>\n<tr>\n<td><strong>希腊字母</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>alpha</td>\n<td>α</td>\n<td><code>\\alpha</code></td>\n<td>$ \\alpha $</td>\n</tr>\n<tr>\n<td>beta</td>\n<td>β</td>\n<td><code>\\beta</code></td>\n<td>$ \\beta $</td>\n</tr>\n<tr>\n<td>gamma</td>\n<td>γ</td>\n<td><code>\\gamma</code></td>\n<td>$ \\gamma $</td>\n</tr>\n<tr>\n<td>theta</td>\n<td>θ</td>\n<td><code>\\theta</code></td>\n<td>$ \\theta $</td>\n</tr>\n<tr>\n<td>pi</td>\n<td>π</td>\n<td><code>\\pi</code></td>\n<td>$ \\pi $</td>\n</tr>\n<tr>\n<td>sigma</td>\n<td>σ</td>\n<td><code>\\sigma</code></td>\n<td>$ \\sigma $</td>\n</tr>\n<tr>\n<td>omega</td>\n<td>ω</td>\n<td><code>\\omega</code></td>\n<td>$ \\omega $</td>\n</tr>\n<tr>\n<td><strong>运算符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>求和</td>\n<td>求和符号</td>\n<td><code>\\sum_&#123;i=1&#125;^n</code></td>\n<td>$ \\sum_{i=1}^n $</td>\n</tr>\n<tr>\n<td>积分</td>\n<td>积分符号</td>\n<td><code>\\int_&#123;a&#125;^b</code></td>\n<td>$ \\int_{a}^b $</td>\n</tr>\n<tr>\n<td>乘积</td>\n<td>连乘符号</td>\n<td><code>\\prod_&#123;i=1&#125;^n</code></td>\n<td>$ \\prod_{i=1}^n $</td>\n</tr>\n<tr>\n<td>极限</td>\n<td>极限</td>\n<td><code>\\lim_&#123;x \\to \\infty&#125;</code></td>\n<td>$ \\lim_{x \\to \\infty} $</td>\n</tr>\n<tr>\n<td><strong>关系符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>不等号</td>\n<td>大于等于</td>\n<td><code>\\geq</code></td>\n<td>$ \\geq $</td>\n</tr>\n<tr>\n<td>不等号</td>\n<td>小于等于</td>\n<td><code>\\leq</code></td>\n<td>$ \\leq $</td>\n</tr>\n<tr>\n<td>约等于</td>\n<td>约等于</td>\n<td><code>\\approx</code></td>\n<td>$ \\approx $</td>\n</tr>\n<tr>\n<td>属于</td>\n<td>属于</td>\n<td><code>\\in</code></td>\n<td>$ \\in $</td>\n</tr>\n<tr>\n<td>基本同余符号</td>\n<td></td>\n<td><code>a \\equiv b</code></td>\n<td>$ a \\equiv b $</td>\n</tr>\n<tr>\n<td><strong>其他常用</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>根号</td>\n<td>开方</td>\n<td><code>\\sqrt&#123;x&#125;</code></td>\n<td>$ \\sqrt{x} $</td>\n</tr>\n<tr>\n<td>n次方根</td>\n<td>n次方根</td>\n<td><code>\\sqrt[n]&#123;x&#125;</code></td>\n<td>$ \\sqrt[n]{x} $</td>\n</tr>\n<tr>\n<td>向量</td>\n<td>向量符号</td>\n<td><code>\\vec&#123;a&#125;</code></td>\n<td>$ \\vec{a} $</td>\n</tr>\n<tr>\n<td>无穷</td>\n<td>无穷符号</td>\n<td><code>\\infty</code></td>\n<td>$ \\infty $</td>\n</tr>\n<tr>\n<td>偏导</td>\n<td>偏导符号</td>\n<td><code>\\partial</code></td>\n<td>$ \\partial $</td>\n</tr>\n</tbody>\n</table>\n</div>\n","more":"<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>说明</th>\n<th>LaTeX语法</th>\n<th>显示效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>基础符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>上标</td>\n<td>次方</td>\n<td><code>x^2</code></td>\n<td>$ x^2 $</td>\n</tr>\n<tr>\n<td>下标</td>\n<td>下标</td>\n<td><code>x_i</code></td>\n<td>$ x_i $</td>\n</tr>\n<tr>\n<td>分数</td>\n<td>分数</td>\n<td><code>\\frac&#123;a&#125;&#123;b&#125;</code></td>\n<td>$ \\frac{a}{b} $</td>\n</tr>\n<tr>\n<td>与运算</td>\n<td>and</td>\n<td><code>\\wedge</code></td>\n<td>$ \\wedge $</td>\n</tr>\n<tr>\n<td>或运算</td>\n<td>or</td>\n<td><code>\\vee</code></td>\n<td>$ \\vee $</td>\n</tr>\n<tr>\n<td>非运算</td>\n<td>not</td>\n<td><code>\\neg</code></td>\n<td>$ \\neg $</td>\n</tr>\n<tr>\n<td>集合</td>\n<td>集合</td>\n<td><code>\\&#123;a, b, c\\&#125;</code></td>\n<td>$ {a, b, c} $</td>\n</tr>\n<tr>\n<td><strong>希腊字母</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>alpha</td>\n<td>α</td>\n<td><code>\\alpha</code></td>\n<td>$ \\alpha $</td>\n</tr>\n<tr>\n<td>beta</td>\n<td>β</td>\n<td><code>\\beta</code></td>\n<td>$ \\beta $</td>\n</tr>\n<tr>\n<td>gamma</td>\n<td>γ</td>\n<td><code>\\gamma</code></td>\n<td>$ \\gamma $</td>\n</tr>\n<tr>\n<td>theta</td>\n<td>θ</td>\n<td><code>\\theta</code></td>\n<td>$ \\theta $</td>\n</tr>\n<tr>\n<td>pi</td>\n<td>π</td>\n<td><code>\\pi</code></td>\n<td>$ \\pi $</td>\n</tr>\n<tr>\n<td>sigma</td>\n<td>σ</td>\n<td><code>\\sigma</code></td>\n<td>$ \\sigma $</td>\n</tr>\n<tr>\n<td>omega</td>\n<td>ω</td>\n<td><code>\\omega</code></td>\n<td>$ \\omega $</td>\n</tr>\n<tr>\n<td><strong>运算符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>求和</td>\n<td>求和符号</td>\n<td><code>\\sum_&#123;i=1&#125;^n</code></td>\n<td>$ \\sum_{i=1}^n $</td>\n</tr>\n<tr>\n<td>积分</td>\n<td>积分符号</td>\n<td><code>\\int_&#123;a&#125;^b</code></td>\n<td>$ \\int_{a}^b $</td>\n</tr>\n<tr>\n<td>乘积</td>\n<td>连乘符号</td>\n<td><code>\\prod_&#123;i=1&#125;^n</code></td>\n<td>$ \\prod_{i=1}^n $</td>\n</tr>\n<tr>\n<td>极限</td>\n<td>极限</td>\n<td><code>\\lim_&#123;x \\to \\infty&#125;</code></td>\n<td>$ \\lim_{x \\to \\infty} $</td>\n</tr>\n<tr>\n<td><strong>关系符号</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>不等号</td>\n<td>大于等于</td>\n<td><code>\\geq</code></td>\n<td>$ \\geq $</td>\n</tr>\n<tr>\n<td>不等号</td>\n<td>小于等于</td>\n<td><code>\\leq</code></td>\n<td>$ \\leq $</td>\n</tr>\n<tr>\n<td>约等于</td>\n<td>约等于</td>\n<td><code>\\approx</code></td>\n<td>$ \\approx $</td>\n</tr>\n<tr>\n<td>属于</td>\n<td>属于</td>\n<td><code>\\in</code></td>\n<td>$ \\in $</td>\n</tr>\n<tr>\n<td>基本同余符号</td>\n<td></td>\n<td><code>a \\equiv b</code></td>\n<td>$ a \\equiv b $</td>\n</tr>\n<tr>\n<td><strong>其他常用</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>根号</td>\n<td>开方</td>\n<td><code>\\sqrt&#123;x&#125;</code></td>\n<td>$ \\sqrt{x} $</td>\n</tr>\n<tr>\n<td>n次方根</td>\n<td>n次方根</td>\n<td><code>\\sqrt[n]&#123;x&#125;</code></td>\n<td>$ \\sqrt[n]{x} $</td>\n</tr>\n<tr>\n<td>向量</td>\n<td>向量符号</td>\n<td><code>\\vec&#123;a&#125;</code></td>\n<td>$ \\vec{a} $</td>\n</tr>\n<tr>\n<td>无穷</td>\n<td>无穷符号</td>\n<td><code>\\infty</code></td>\n<td>$ \\infty $</td>\n</tr>\n<tr>\n<td>偏导</td>\n<td>偏导符号</td>\n<td><code>\\partial</code></td>\n<td>$ \\partial $</td>\n</tr>\n</tbody>\n</table>\n</div>\n"},{"title":"cryptography","date":"2025-02-19T12:11:12.000Z","excerpt":"密码学相关","math":true,"index_img":"/img/crypt_index.png","_content":"\n# 数学基础\n概念回顾:\n- **素数相关定理** :任何正整数都能分解为素数的乘积.\n\n\n- **互素** 若a,b的最大公因数为1, 则称a,b互素.\n- 最大公约数 gcd\n- 整除\n  - a 整除 b记做 `a | b` \n\n\n若`gcd(a,b) = d`, 且a,b至少1个不为0, 则:\n- 内容: `a*x + b*y = gcd(a,b) = d`;\n- 证明: 利用欧几里得法辅助证明\n\t- 欧几里得法求解gcd: 每次将除数作为被除数, 余数作为除数, 最后得到的除数(余数为0时)就是gcd;\n\t- a,b都可以分解为 对应的分解形式(初始的`x`,`y`分别设为`0`);\n\t- 之后的除数都可以通过减法得到, 所以最后的除数也符合条件\n- 推广:\n\t- 当`gcd(a,b) = 1`时, `a*x + b*y = 1`.\n\n\n## 模运算和同余\n回顾基本的模运算:\n**1. 加法规则:**\n\t`(a+b) mod n = (a mod n + b mod n) mod n`\n**2. 减法规则:**\n\t`(a-b) mod n = (a mod n - b mod n + n) mod n`\n\n> `+n`以避免得到负数的结果.\n\n**3. 乘法规则:**\n\t`(a*b) mod n = (a mod n * b mod n) mod n`\n\na,b,n均为整数且 $n \\neq 0$, 下面几种说法等价:\n- $a = b + n \\cdot k$, 其中 k 为整数;\n- a,b对于模n同余;\n- $a \\equiv b \\pmod n$, 即 $a \\% n = b \\% n$.\n\n---\n\n**相关性质:**\n- 当且仅当`n | a`时有 $a \\equiv 0 \\pmod n$\n- 当且仅当 $b \\equiv a \\pmod n$ 时有 $a \\equiv b \\pmod n$\n- 模同余的**传递性**: 若$a \\equiv b \\pmod n$ 且 $b \\equiv c \\pmod n$, 则 $a \\equiv c \\pmod n$\n- 如果a,b与c,d分别对于模n同余, 则 \n  - $a + c \\equiv b + d \\pmod n$\n  - $a - c \\equiv b - d \\pmod n$\n  - $a \\cdot c \\equiv b \\cdot d \\pmod n$\n\n## 逆元\n### 加法模逆元\n如果 $a+b \\equiv 0 \\pmod n$ , 则称a为b的加法模n逆元, b也为a的加法模n逆元.\n\ne.g: 恺撒加密中 `+3`与`+23`互为加法模26的逆元. 在解密时, 由于`-3`与`+23`等价, 所以采用`+23`的方式解密.\n\n\n### 乘法模逆元\n如果 $a \\cdot b \\equiv 1 \\pmod n$, 则称a为b的乘法模n逆元, b也为a的乘法模n逆元.\n\n此时存在整数k满足: $a\\cdot b  = 1+n\\cdot k$.\n\n\ne.g: 利用扩展欧几里得法求解乘法逆元\n> TODO\n\n**Notice:** \n$\\gcd (a,b)$ = 1 $\\Longleftrightarrow$ a在模b下存在乘法逆元, 即 $a \\cdot k \\equiv 1 \\pmod b$\n\n- **充分性**证明: \n  - 前者推出 $\\exist \\ x,y$ 满足 $a\\cdot x + b\\cdot y = 1$;\n  - 移项得到 $a\\cdot x = 1 - b\\cdot y$, 即满足后者的形式;\n- **必要性**证明: \n  - 后者由上述乘法模逆元的定义可知 $\\exist \\ n$, 使得$a\\cdot k - 1 = n\\cdot b$ 成立;\n  - 变换得到: $a\\cdot k - n\\cdot b = 1$, 根据裴蜀定理得到 $\\gcd (a,b) = 1$.\n\n# 古典密码\nencryption(加密)\ndecryption(解密)\n## 单表密码\n- 加法密码\n  - 密钥量: n;\n- 乘法密码\n  - 加密: y = x*k mod n;\n  - 解密: x = y*$k^{-1}$ mod n, 其中 $k^{-1}$ 为 $k$ 的乘法模n逆元.\n  - 密钥量: 欧拉函数$\\phi(n)$ := **小于n且与n互素**的非负整数的个数.\n- 仿射密码\n  - 加密: y = x*k + b mod n;\n  - 解密: x = (y - b) * $k^{-1}$ mod n.\n  - 密钥量: $n \\cdot \\phi(n)$\n> 加法密码和乘法密码是仿射密码的**特例**.\n\n## 多表密码\n**定义**: 对相同的明文字母采取不同的单表代换, 得到多个密文字母.\n\n多表古典密码中的基本加密计算:\n- 简单加法密码: \n  - 对m个明文采取m种单表加法加密, 且加法为模n的加法.\n  - 密钥量: $n^m$, 这是因为模n的情况下密钥有n种不同的密钥, 一共有m个明文字符.\n- 简单乘法密码:\n  - 对m个明文采取m种单表乘法加密, 且乘法为模n的乘法.\n  - 密钥量: $\\phi(n)^m$.\n- 简单仿射密码: \n  - 同理, 对m个明文使用m对的仿射密码.\n  - 密钥量: $n^m \\cdot \\phi(n)^m$.\n\n\n\n典型的古典密码:\n\n### Playfair\n利用字母表转换成的矩阵, 对两两分组的明文字母进行加密.\n\n具体流程:\n- **构造矩阵**: 将`j`视为`i`, 取剩下的25个字母填入矩阵$P$, 此处的矩阵视为四方循环;\n- **明文的处理**: 为了确保能够两两分组, 在明文字符串的特定位置插入特定的字母, 并将`j`视为`i`;\n- **加密策略**:\n  - 明文同行 $\\Rightarrow$ 将其**右方**的字母作为密文;\n  - 明文同列 $\\Rightarrow$ 将其**下方**的字母作为密文;\n  - 明文不同行不同列 $\\Rightarrow$ 找到这两个字母所在的**矩形**的对角线的两个字母作为密文, 且分别为**同行**的字母.\n\n\n### Vigenere\nVigenere是一种多表简单加法密码.\n- 明文为 m1,m2...mp; 密钥为 k1,k2...kq\n- 当q小于p时, 重复使用密钥;\n- 加密: $c_i = (m_i + k_i) mod \\ n$\n- 解密: $m_i = (c_i - k_i) mod \\ n$\n\n### Beaufort\n使用$k_i$对$m_i$进行加密时, 密文为Beaufort方阵的第$k_i$行$m_i$列的字母.\n\n### Vernam\n\n将明文编码为0,1字符串, 且密钥也属于0,1的区域. 那么密文为:\n$$\nc_i =m_i \\oplus k_i \\\\\n同时\\  k_i = m_i \\oplus c_i\n$$\n\n###  Hill体制\n\nHill的思想是对于`n`位的明文字符串, 使用`nxn`的可逆矩阵$K$进行加密.\n$$\nc = m\\cdot K \\ mod \\ 26 \\\\\nm = c \\cdot K^{-1} \\ mod \\ 26\n$$\ne.g. :\n\n| <img src=\"cryptography.assets/image-20250224195809124.png\" alt=\"image-20250224195809124\" style=\"zoom:50%;\" /> | <img src=\"cryptography.assets/image-20250224195821189.png\" alt=\"image-20250224195821189\" style=\"zoom:50%;\" /> |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n\n> 从0开始.\n\n### Enigma\n\nTODO\n\n## 课堂摘记缓冲区\n\n- 异或相当于加法取模运算\n\n\n\n\n\n## 加密算法\n### ase\n- 将明文`p`作为输入, 得到一个检验值`crc`, 同时将`p`在某种加密算法下加密得到`p'`.\n- 将`p’`与`crc`保存在加密之后的文件当中.\n- 解密时, 将给出的密码作为输入, 由给定的解密函数得到`p''`, 然后由`p''`得到对应的检验值`crc’`;\n- 判断前后的检验值是否相同, 如果相同, 说明输入的密码正确, 解密得到的`p''`就是`p’. 否则说明密码错误.\n\n### ecc\n椭圆曲线加密算法\n\n### rsa\n\n","source":"_drafts/temp_notes/cryptography.md","raw":"---\ntitle: cryptography\ndate: 2025-02-19 20:11:12\ntags:\ncategories:\nexcerpt: 密码学相关\nmath: true\nindex_img: /img/crypt_index.png\n---\n\n# 数学基础\n概念回顾:\n- **素数相关定理** :任何正整数都能分解为素数的乘积.\n\n\n- **互素** 若a,b的最大公因数为1, 则称a,b互素.\n- 最大公约数 gcd\n- 整除\n  - a 整除 b记做 `a | b` \n\n\n若`gcd(a,b) = d`, 且a,b至少1个不为0, 则:\n- 内容: `a*x + b*y = gcd(a,b) = d`;\n- 证明: 利用欧几里得法辅助证明\n\t- 欧几里得法求解gcd: 每次将除数作为被除数, 余数作为除数, 最后得到的除数(余数为0时)就是gcd;\n\t- a,b都可以分解为 对应的分解形式(初始的`x`,`y`分别设为`0`);\n\t- 之后的除数都可以通过减法得到, 所以最后的除数也符合条件\n- 推广:\n\t- 当`gcd(a,b) = 1`时, `a*x + b*y = 1`.\n\n\n## 模运算和同余\n回顾基本的模运算:\n**1. 加法规则:**\n\t`(a+b) mod n = (a mod n + b mod n) mod n`\n**2. 减法规则:**\n\t`(a-b) mod n = (a mod n - b mod n + n) mod n`\n\n> `+n`以避免得到负数的结果.\n\n**3. 乘法规则:**\n\t`(a*b) mod n = (a mod n * b mod n) mod n`\n\na,b,n均为整数且 $n \\neq 0$, 下面几种说法等价:\n- $a = b + n \\cdot k$, 其中 k 为整数;\n- a,b对于模n同余;\n- $a \\equiv b \\pmod n$, 即 $a \\% n = b \\% n$.\n\n---\n\n**相关性质:**\n- 当且仅当`n | a`时有 $a \\equiv 0 \\pmod n$\n- 当且仅当 $b \\equiv a \\pmod n$ 时有 $a \\equiv b \\pmod n$\n- 模同余的**传递性**: 若$a \\equiv b \\pmod n$ 且 $b \\equiv c \\pmod n$, 则 $a \\equiv c \\pmod n$\n- 如果a,b与c,d分别对于模n同余, 则 \n  - $a + c \\equiv b + d \\pmod n$\n  - $a - c \\equiv b - d \\pmod n$\n  - $a \\cdot c \\equiv b \\cdot d \\pmod n$\n\n## 逆元\n### 加法模逆元\n如果 $a+b \\equiv 0 \\pmod n$ , 则称a为b的加法模n逆元, b也为a的加法模n逆元.\n\ne.g: 恺撒加密中 `+3`与`+23`互为加法模26的逆元. 在解密时, 由于`-3`与`+23`等价, 所以采用`+23`的方式解密.\n\n\n### 乘法模逆元\n如果 $a \\cdot b \\equiv 1 \\pmod n$, 则称a为b的乘法模n逆元, b也为a的乘法模n逆元.\n\n此时存在整数k满足: $a\\cdot b  = 1+n\\cdot k$.\n\n\ne.g: 利用扩展欧几里得法求解乘法逆元\n> TODO\n\n**Notice:** \n$\\gcd (a,b)$ = 1 $\\Longleftrightarrow$ a在模b下存在乘法逆元, 即 $a \\cdot k \\equiv 1 \\pmod b$\n\n- **充分性**证明: \n  - 前者推出 $\\exist \\ x,y$ 满足 $a\\cdot x + b\\cdot y = 1$;\n  - 移项得到 $a\\cdot x = 1 - b\\cdot y$, 即满足后者的形式;\n- **必要性**证明: \n  - 后者由上述乘法模逆元的定义可知 $\\exist \\ n$, 使得$a\\cdot k - 1 = n\\cdot b$ 成立;\n  - 变换得到: $a\\cdot k - n\\cdot b = 1$, 根据裴蜀定理得到 $\\gcd (a,b) = 1$.\n\n# 古典密码\nencryption(加密)\ndecryption(解密)\n## 单表密码\n- 加法密码\n  - 密钥量: n;\n- 乘法密码\n  - 加密: y = x*k mod n;\n  - 解密: x = y*$k^{-1}$ mod n, 其中 $k^{-1}$ 为 $k$ 的乘法模n逆元.\n  - 密钥量: 欧拉函数$\\phi(n)$ := **小于n且与n互素**的非负整数的个数.\n- 仿射密码\n  - 加密: y = x*k + b mod n;\n  - 解密: x = (y - b) * $k^{-1}$ mod n.\n  - 密钥量: $n \\cdot \\phi(n)$\n> 加法密码和乘法密码是仿射密码的**特例**.\n\n## 多表密码\n**定义**: 对相同的明文字母采取不同的单表代换, 得到多个密文字母.\n\n多表古典密码中的基本加密计算:\n- 简单加法密码: \n  - 对m个明文采取m种单表加法加密, 且加法为模n的加法.\n  - 密钥量: $n^m$, 这是因为模n的情况下密钥有n种不同的密钥, 一共有m个明文字符.\n- 简单乘法密码:\n  - 对m个明文采取m种单表乘法加密, 且乘法为模n的乘法.\n  - 密钥量: $\\phi(n)^m$.\n- 简单仿射密码: \n  - 同理, 对m个明文使用m对的仿射密码.\n  - 密钥量: $n^m \\cdot \\phi(n)^m$.\n\n\n\n典型的古典密码:\n\n### Playfair\n利用字母表转换成的矩阵, 对两两分组的明文字母进行加密.\n\n具体流程:\n- **构造矩阵**: 将`j`视为`i`, 取剩下的25个字母填入矩阵$P$, 此处的矩阵视为四方循环;\n- **明文的处理**: 为了确保能够两两分组, 在明文字符串的特定位置插入特定的字母, 并将`j`视为`i`;\n- **加密策略**:\n  - 明文同行 $\\Rightarrow$ 将其**右方**的字母作为密文;\n  - 明文同列 $\\Rightarrow$ 将其**下方**的字母作为密文;\n  - 明文不同行不同列 $\\Rightarrow$ 找到这两个字母所在的**矩形**的对角线的两个字母作为密文, 且分别为**同行**的字母.\n\n\n### Vigenere\nVigenere是一种多表简单加法密码.\n- 明文为 m1,m2...mp; 密钥为 k1,k2...kq\n- 当q小于p时, 重复使用密钥;\n- 加密: $c_i = (m_i + k_i) mod \\ n$\n- 解密: $m_i = (c_i - k_i) mod \\ n$\n\n### Beaufort\n使用$k_i$对$m_i$进行加密时, 密文为Beaufort方阵的第$k_i$行$m_i$列的字母.\n\n### Vernam\n\n将明文编码为0,1字符串, 且密钥也属于0,1的区域. 那么密文为:\n$$\nc_i =m_i \\oplus k_i \\\\\n同时\\  k_i = m_i \\oplus c_i\n$$\n\n###  Hill体制\n\nHill的思想是对于`n`位的明文字符串, 使用`nxn`的可逆矩阵$K$进行加密.\n$$\nc = m\\cdot K \\ mod \\ 26 \\\\\nm = c \\cdot K^{-1} \\ mod \\ 26\n$$\ne.g. :\n\n| <img src=\"cryptography.assets/image-20250224195809124.png\" alt=\"image-20250224195809124\" style=\"zoom:50%;\" /> | <img src=\"cryptography.assets/image-20250224195821189.png\" alt=\"image-20250224195821189\" style=\"zoom:50%;\" /> |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n\n> 从0开始.\n\n### Enigma\n\nTODO\n\n## 课堂摘记缓冲区\n\n- 异或相当于加法取模运算\n\n\n\n\n\n## 加密算法\n### ase\n- 将明文`p`作为输入, 得到一个检验值`crc`, 同时将`p`在某种加密算法下加密得到`p'`.\n- 将`p’`与`crc`保存在加密之后的文件当中.\n- 解密时, 将给出的密码作为输入, 由给定的解密函数得到`p''`, 然后由`p''`得到对应的检验值`crc’`;\n- 判断前后的检验值是否相同, 如果相同, 说明输入的密码正确, 解密得到的`p''`就是`p’. 否则说明密码错误.\n\n### ecc\n椭圆曲线加密算法\n\n### rsa\n\n","slug":"temp_notes/cryptography","published":0,"updated":"2025-02-24T12:09:00.664Z","comments":1,"layout":"post","photos":[],"_id":"cm7kndg8p0005dmqgdgqk84dv","content":"<h1 id=\"数学基础\"><a href=\"#数学基础\" class=\"headerlink\" title=\"数学基础\"></a>数学基础</h1><p>概念回顾:</p>\n<ul>\n<li><strong>素数相关定理</strong> :任何正整数都能分解为素数的乘积.</li>\n</ul>\n<ul>\n<li><strong>互素</strong> 若a,b的最大公因数为1, 则称a,b互素.</li>\n<li>最大公约数 gcd</li>\n<li>整除<ul>\n<li>a 整除 b记做 <code>a | b</code> </li>\n</ul>\n</li>\n</ul>\n<p>若<code>gcd(a,b) = d</code>, 且a,b至少1个不为0, 则:</p>\n<ul>\n<li>内容: <code>a*x + b*y = gcd(a,b) = d</code>;</li>\n<li>证明: 利用欧几里得法辅助证明<ul>\n<li>欧几里得法求解gcd: 每次将除数作为被除数, 余数作为除数, 最后得到的除数(余数为0时)就是gcd;</li>\n<li>a,b都可以分解为 对应的分解形式(初始的<code>x</code>,<code>y</code>分别设为<code>0</code>);</li>\n<li>之后的除数都可以通过减法得到, 所以最后的除数也符合条件</li>\n</ul>\n</li>\n<li>推广:<ul>\n<li>当<code>gcd(a,b) = 1</code>时, <code>a*x + b*y = 1</code>.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模运算和同余\"><a href=\"#模运算和同余\" class=\"headerlink\" title=\"模运算和同余\"></a>模运算和同余</h2><p>回顾基本的模运算:<br><strong>1. 加法规则:</strong><br>    <code>(a+b) mod n = (a mod n + b mod n) mod n</code><br><strong>2. 减法规则:</strong><br>    <code>(a-b) mod n = (a mod n - b mod n + n) mod n</code></p>\n<blockquote>\n<p><code>+n</code>以避免得到负数的结果.</p>\n</blockquote>\n<p><strong>3. 乘法规则:</strong><br>    <code>(a*b) mod n = (a mod n * b mod n) mod n</code></p>\n<p>a,b,n均为整数且 $n \\neq 0$, 下面几种说法等价:</p>\n<ul>\n<li>$a = b + n \\cdot k$, 其中 k 为整数;</li>\n<li>a,b对于模n同余;</li>\n<li>$a \\equiv b \\pmod n$, 即 $a \\% n = b \\% n$.</li>\n</ul>\n<hr>\n<p><strong>相关性质:</strong></p>\n<ul>\n<li>当且仅当<code>n | a</code>时有 $a \\equiv 0 \\pmod n$</li>\n<li>当且仅当 $b \\equiv a \\pmod n$ 时有 $a \\equiv b \\pmod n$</li>\n<li>模同余的<strong>传递性</strong>: 若$a \\equiv b \\pmod n$ 且 $b \\equiv c \\pmod n$, 则 $a \\equiv c \\pmod n$</li>\n<li>如果a,b与c,d分别对于模n同余, 则 <ul>\n<li>$a + c \\equiv b + d \\pmod n$</li>\n<li>$a - c \\equiv b - d \\pmod n$</li>\n<li>$a \\cdot c \\equiv b \\cdot d \\pmod n$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"逆元\"><a href=\"#逆元\" class=\"headerlink\" title=\"逆元\"></a>逆元</h2><h3 id=\"加法模逆元\"><a href=\"#加法模逆元\" class=\"headerlink\" title=\"加法模逆元\"></a>加法模逆元</h3><p>如果 $a+b \\equiv 0 \\pmod n$ , 则称a为b的加法模n逆元, b也为a的加法模n逆元.</p>\n<p>e.g: 恺撒加密中 <code>+3</code>与<code>+23</code>互为加法模26的逆元. 在解密时, 由于<code>-3</code>与<code>+23</code>等价, 所以采用<code>+23</code>的方式解密.</p>\n<h3 id=\"乘法模逆元\"><a href=\"#乘法模逆元\" class=\"headerlink\" title=\"乘法模逆元\"></a>乘法模逆元</h3><p>如果 $a \\cdot b \\equiv 1 \\pmod n$, 则称a为b的乘法模n逆元, b也为a的乘法模n逆元.</p>\n<p>此时存在整数k满足: $a\\cdot b  = 1+n\\cdot k$.</p>\n<p>e.g: 利用扩展欧几里得法求解乘法逆元</p>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<p><strong>Notice:</strong><br>$\\gcd (a,b)$ = 1 $\\Longleftrightarrow$ a在模b下存在乘法逆元, 即 $a \\cdot k \\equiv 1 \\pmod b$</p>\n<ul>\n<li><strong>充分性</strong>证明: <ul>\n<li>前者推出 $\\exist \\ x,y$ 满足 $a\\cdot x + b\\cdot y = 1$;</li>\n<li>移项得到 $a\\cdot x = 1 - b\\cdot y$, 即满足后者的形式;</li>\n</ul>\n</li>\n<li><strong>必要性</strong>证明: <ul>\n<li>后者由上述乘法模逆元的定义可知 $\\exist \\ n$, 使得$a\\cdot k - 1 = n\\cdot b$ 成立;</li>\n<li>变换得到: $a\\cdot k - n\\cdot b = 1$, 根据裴蜀定理得到 $\\gcd (a,b) = 1$.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"古典密码\"><a href=\"#古典密码\" class=\"headerlink\" title=\"古典密码\"></a>古典密码</h1><p>encryption(加密)<br>decryption(解密)</p>\n<h2 id=\"单表密码\"><a href=\"#单表密码\" class=\"headerlink\" title=\"单表密码\"></a>单表密码</h2><ul>\n<li>加法密码<ul>\n<li>密钥量: n;</li>\n</ul>\n</li>\n<li>乘法密码<ul>\n<li>加密: y = x*k mod n;</li>\n<li>解密: x = y*$k^{-1}$ mod n, 其中 $k^{-1}$ 为 $k$ 的乘法模n逆元.</li>\n<li>密钥量: 欧拉函数$\\phi(n)$ := <strong>小于n且与n互素</strong>的非负整数的个数.</li>\n</ul>\n</li>\n<li>仿射密码<ul>\n<li>加密: y = x*k + b mod n;</li>\n<li>解密: x = (y - b) * $k^{-1}$ mod n.</li>\n<li>密钥量: $n \\cdot \\phi(n)$<blockquote>\n<p>加法密码和乘法密码是仿射密码的<strong>特例</strong>.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多表密码\"><a href=\"#多表密码\" class=\"headerlink\" title=\"多表密码\"></a>多表密码</h2><p><strong>定义</strong>: 对相同的明文字母采取不同的单表代换, 得到多个密文字母.</p>\n<p>多表古典密码中的基本加密计算:</p>\n<ul>\n<li>简单加法密码: <ul>\n<li>对m个明文采取m种单表加法加密, 且加法为模n的加法.</li>\n<li>密钥量: $n^m$, 这是因为模n的情况下密钥有n种不同的密钥, 一共有m个明文字符.</li>\n</ul>\n</li>\n<li>简单乘法密码:<ul>\n<li>对m个明文采取m种单表乘法加密, 且乘法为模n的乘法.</li>\n<li>密钥量: $\\phi(n)^m$.</li>\n</ul>\n</li>\n<li>简单仿射密码: <ul>\n<li>同理, 对m个明文使用m对的仿射密码.</li>\n<li>密钥量: $n^m \\cdot \\phi(n)^m$.</li>\n</ul>\n</li>\n</ul>\n<p>典型的古典密码:</p>\n<h3 id=\"Playfair\"><a href=\"#Playfair\" class=\"headerlink\" title=\"Playfair\"></a>Playfair</h3><p>利用字母表转换成的矩阵, 对两两分组的明文字母进行加密.</p>\n<p>具体流程:</p>\n<ul>\n<li><strong>构造矩阵</strong>: 将<code>j</code>视为<code>i</code>, 取剩下的25个字母填入矩阵$P$, 此处的矩阵视为四方循环;</li>\n<li><strong>明文的处理</strong>: 为了确保能够两两分组, 在明文字符串的特定位置插入特定的字母, 并将<code>j</code>视为<code>i</code>;</li>\n<li><strong>加密策略</strong>:<ul>\n<li>明文同行 $\\Rightarrow$ 将其<strong>右方</strong>的字母作为密文;</li>\n<li>明文同列 $\\Rightarrow$ 将其<strong>下方</strong>的字母作为密文;</li>\n<li>明文不同行不同列 $\\Rightarrow$ 找到这两个字母所在的<strong>矩形</strong>的对角线的两个字母作为密文, 且分别为<strong>同行</strong>的字母.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Vigenere\"><a href=\"#Vigenere\" class=\"headerlink\" title=\"Vigenere\"></a>Vigenere</h3><p>Vigenere是一种多表简单加法密码.</p>\n<ul>\n<li>明文为 m1,m2…mp; 密钥为 k1,k2…kq</li>\n<li>当q小于p时, 重复使用密钥;</li>\n<li>加密: $c_i = (m_i + k_i) mod \\ n$</li>\n<li>解密: $m_i = (c_i - k_i) mod \\ n$</li>\n</ul>\n<h3 id=\"Beaufort\"><a href=\"#Beaufort\" class=\"headerlink\" title=\"Beaufort\"></a>Beaufort</h3><p>使用$k_i$对$m_i$进行加密时, 密文为Beaufort方阵的第$k_i$行$m_i$列的字母.</p>\n<h3 id=\"Vernam\"><a href=\"#Vernam\" class=\"headerlink\" title=\"Vernam\"></a>Vernam</h3><p>将明文编码为0,1字符串, 且密钥也属于0,1的区域. 那么密文为:</p>\n<script type=\"math/tex; mode=display\">\nc_i =m_i \\oplus k_i \\\\\n同时\\  k_i = m_i \\oplus c_i</script><h3 id=\"Hill体制\"><a href=\"#Hill体制\" class=\"headerlink\" title=\"Hill体制\"></a>Hill体制</h3><p>Hill的思想是对于<code>n</code>位的明文字符串, 使用<code>nxn</code>的可逆矩阵$K$进行加密.</p>\n<script type=\"math/tex; mode=display\">\nc = m\\cdot K \\ mod \\ 26 \\\\\nm = c \\cdot K^{-1} \\ mod \\ 26</script><p>e.g. :</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><img src=\"cryptography.assets/image-20250224195809124.png\" alt=\"image-20250224195809124\" style=\"zoom:50%;\" /></th>\n<th><img src=\"cryptography.assets/image-20250224195821189.png\" alt=\"image-20250224195821189\" style=\"zoom:50%;\" /></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>从0开始.</p>\n</blockquote>\n<h3 id=\"Enigma\"><a href=\"#Enigma\" class=\"headerlink\" title=\"Enigma\"></a>Enigma</h3><p>TODO</p>\n<h2 id=\"课堂摘记缓冲区\"><a href=\"#课堂摘记缓冲区\" class=\"headerlink\" title=\"课堂摘记缓冲区\"></a>课堂摘记缓冲区</h2><ul>\n<li>异或相当于加法取模运算</li>\n</ul>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><h3 id=\"ase\"><a href=\"#ase\" class=\"headerlink\" title=\"ase\"></a>ase</h3><ul>\n<li>将明文<code>p</code>作为输入, 得到一个检验值<code>crc</code>, 同时将<code>p</code>在某种加密算法下加密得到<code>p&#39;</code>.</li>\n<li>将<code>p’</code>与<code>crc</code>保存在加密之后的文件当中.</li>\n<li>解密时, 将给出的密码作为输入, 由给定的解密函数得到<code>p&#39;&#39;</code>, 然后由<code>p&#39;&#39;</code>得到对应的检验值<code>crc’</code>;</li>\n<li>判断前后的检验值是否相同, 如果相同, 说明输入的密码正确, 解密得到的<code>p&#39;&#39;</code>就是`p’. 否则说明密码错误.</li>\n</ul>\n<h3 id=\"ecc\"><a href=\"#ecc\" class=\"headerlink\" title=\"ecc\"></a>ecc</h3><p>椭圆曲线加密算法</p>\n<h3 id=\"rsa\"><a href=\"#rsa\" class=\"headerlink\" title=\"rsa\"></a>rsa</h3>","more":"<h1 id=\"数学基础\"><a href=\"#数学基础\" class=\"headerlink\" title=\"数学基础\"></a>数学基础</h1><p>概念回顾:</p>\n<ul>\n<li><strong>素数相关定理</strong> :任何正整数都能分解为素数的乘积.</li>\n</ul>\n<ul>\n<li><strong>互素</strong> 若a,b的最大公因数为1, 则称a,b互素.</li>\n<li>最大公约数 gcd</li>\n<li>整除<ul>\n<li>a 整除 b记做 <code>a | b</code> </li>\n</ul>\n</li>\n</ul>\n<p>若<code>gcd(a,b) = d</code>, 且a,b至少1个不为0, 则:</p>\n<ul>\n<li>内容: <code>a*x + b*y = gcd(a,b) = d</code>;</li>\n<li>证明: 利用欧几里得法辅助证明<ul>\n<li>欧几里得法求解gcd: 每次将除数作为被除数, 余数作为除数, 最后得到的除数(余数为0时)就是gcd;</li>\n<li>a,b都可以分解为 对应的分解形式(初始的<code>x</code>,<code>y</code>分别设为<code>0</code>);</li>\n<li>之后的除数都可以通过减法得到, 所以最后的除数也符合条件</li>\n</ul>\n</li>\n<li>推广:<ul>\n<li>当<code>gcd(a,b) = 1</code>时, <code>a*x + b*y = 1</code>.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"模运算和同余\"><a href=\"#模运算和同余\" class=\"headerlink\" title=\"模运算和同余\"></a>模运算和同余</h2><p>回顾基本的模运算:<br><strong>1. 加法规则:</strong><br>    <code>(a+b) mod n = (a mod n + b mod n) mod n</code><br><strong>2. 减法规则:</strong><br>    <code>(a-b) mod n = (a mod n - b mod n + n) mod n</code></p>\n<blockquote>\n<p><code>+n</code>以避免得到负数的结果.</p>\n</blockquote>\n<p><strong>3. 乘法规则:</strong><br>    <code>(a*b) mod n = (a mod n * b mod n) mod n</code></p>\n<p>a,b,n均为整数且 $n \\neq 0$, 下面几种说法等价:</p>\n<ul>\n<li>$a = b + n \\cdot k$, 其中 k 为整数;</li>\n<li>a,b对于模n同余;</li>\n<li>$a \\equiv b \\pmod n$, 即 $a \\% n = b \\% n$.</li>\n</ul>\n<hr>\n<p><strong>相关性质:</strong></p>\n<ul>\n<li>当且仅当<code>n | a</code>时有 $a \\equiv 0 \\pmod n$</li>\n<li>当且仅当 $b \\equiv a \\pmod n$ 时有 $a \\equiv b \\pmod n$</li>\n<li>模同余的<strong>传递性</strong>: 若$a \\equiv b \\pmod n$ 且 $b \\equiv c \\pmod n$, 则 $a \\equiv c \\pmod n$</li>\n<li>如果a,b与c,d分别对于模n同余, 则 <ul>\n<li>$a + c \\equiv b + d \\pmod n$</li>\n<li>$a - c \\equiv b - d \\pmod n$</li>\n<li>$a \\cdot c \\equiv b \\cdot d \\pmod n$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"逆元\"><a href=\"#逆元\" class=\"headerlink\" title=\"逆元\"></a>逆元</h2><h3 id=\"加法模逆元\"><a href=\"#加法模逆元\" class=\"headerlink\" title=\"加法模逆元\"></a>加法模逆元</h3><p>如果 $a+b \\equiv 0 \\pmod n$ , 则称a为b的加法模n逆元, b也为a的加法模n逆元.</p>\n<p>e.g: 恺撒加密中 <code>+3</code>与<code>+23</code>互为加法模26的逆元. 在解密时, 由于<code>-3</code>与<code>+23</code>等价, 所以采用<code>+23</code>的方式解密.</p>\n<h3 id=\"乘法模逆元\"><a href=\"#乘法模逆元\" class=\"headerlink\" title=\"乘法模逆元\"></a>乘法模逆元</h3><p>如果 $a \\cdot b \\equiv 1 \\pmod n$, 则称a为b的乘法模n逆元, b也为a的乘法模n逆元.</p>\n<p>此时存在整数k满足: $a\\cdot b  = 1+n\\cdot k$.</p>\n<p>e.g: 利用扩展欧几里得法求解乘法逆元</p>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<p><strong>Notice:</strong><br>$\\gcd (a,b)$ = 1 $\\Longleftrightarrow$ a在模b下存在乘法逆元, 即 $a \\cdot k \\equiv 1 \\pmod b$</p>\n<ul>\n<li><strong>充分性</strong>证明: <ul>\n<li>前者推出 $\\exist \\ x,y$ 满足 $a\\cdot x + b\\cdot y = 1$;</li>\n<li>移项得到 $a\\cdot x = 1 - b\\cdot y$, 即满足后者的形式;</li>\n</ul>\n</li>\n<li><strong>必要性</strong>证明: <ul>\n<li>后者由上述乘法模逆元的定义可知 $\\exist \\ n$, 使得$a\\cdot k - 1 = n\\cdot b$ 成立;</li>\n<li>变换得到: $a\\cdot k - n\\cdot b = 1$, 根据裴蜀定理得到 $\\gcd (a,b) = 1$.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"古典密码\"><a href=\"#古典密码\" class=\"headerlink\" title=\"古典密码\"></a>古典密码</h1><p>encryption(加密)<br>decryption(解密)</p>\n<h2 id=\"单表密码\"><a href=\"#单表密码\" class=\"headerlink\" title=\"单表密码\"></a>单表密码</h2><ul>\n<li>加法密码<ul>\n<li>密钥量: n;</li>\n</ul>\n</li>\n<li>乘法密码<ul>\n<li>加密: y = x*k mod n;</li>\n<li>解密: x = y*$k^{-1}$ mod n, 其中 $k^{-1}$ 为 $k$ 的乘法模n逆元.</li>\n<li>密钥量: 欧拉函数$\\phi(n)$ := <strong>小于n且与n互素</strong>的非负整数的个数.</li>\n</ul>\n</li>\n<li>仿射密码<ul>\n<li>加密: y = x*k + b mod n;</li>\n<li>解密: x = (y - b) * $k^{-1}$ mod n.</li>\n<li>密钥量: $n \\cdot \\phi(n)$<blockquote>\n<p>加法密码和乘法密码是仿射密码的<strong>特例</strong>.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多表密码\"><a href=\"#多表密码\" class=\"headerlink\" title=\"多表密码\"></a>多表密码</h2><p><strong>定义</strong>: 对相同的明文字母采取不同的单表代换, 得到多个密文字母.</p>\n<p>多表古典密码中的基本加密计算:</p>\n<ul>\n<li>简单加法密码: <ul>\n<li>对m个明文采取m种单表加法加密, 且加法为模n的加法.</li>\n<li>密钥量: $n^m$, 这是因为模n的情况下密钥有n种不同的密钥, 一共有m个明文字符.</li>\n</ul>\n</li>\n<li>简单乘法密码:<ul>\n<li>对m个明文采取m种单表乘法加密, 且乘法为模n的乘法.</li>\n<li>密钥量: $\\phi(n)^m$.</li>\n</ul>\n</li>\n<li>简单仿射密码: <ul>\n<li>同理, 对m个明文使用m对的仿射密码.</li>\n<li>密钥量: $n^m \\cdot \\phi(n)^m$.</li>\n</ul>\n</li>\n</ul>\n<p>典型的古典密码:</p>\n<h3 id=\"Playfair\"><a href=\"#Playfair\" class=\"headerlink\" title=\"Playfair\"></a>Playfair</h3><p>利用字母表转换成的矩阵, 对两两分组的明文字母进行加密.</p>\n<p>具体流程:</p>\n<ul>\n<li><strong>构造矩阵</strong>: 将<code>j</code>视为<code>i</code>, 取剩下的25个字母填入矩阵$P$, 此处的矩阵视为四方循环;</li>\n<li><strong>明文的处理</strong>: 为了确保能够两两分组, 在明文字符串的特定位置插入特定的字母, 并将<code>j</code>视为<code>i</code>;</li>\n<li><strong>加密策略</strong>:<ul>\n<li>明文同行 $\\Rightarrow$ 将其<strong>右方</strong>的字母作为密文;</li>\n<li>明文同列 $\\Rightarrow$ 将其<strong>下方</strong>的字母作为密文;</li>\n<li>明文不同行不同列 $\\Rightarrow$ 找到这两个字母所在的<strong>矩形</strong>的对角线的两个字母作为密文, 且分别为<strong>同行</strong>的字母.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Vigenere\"><a href=\"#Vigenere\" class=\"headerlink\" title=\"Vigenere\"></a>Vigenere</h3><p>Vigenere是一种多表简单加法密码.</p>\n<ul>\n<li>明文为 m1,m2…mp; 密钥为 k1,k2…kq</li>\n<li>当q小于p时, 重复使用密钥;</li>\n<li>加密: $c_i = (m_i + k_i) mod \\ n$</li>\n<li>解密: $m_i = (c_i - k_i) mod \\ n$</li>\n</ul>\n<h3 id=\"Beaufort\"><a href=\"#Beaufort\" class=\"headerlink\" title=\"Beaufort\"></a>Beaufort</h3><p>使用$k_i$对$m_i$进行加密时, 密文为Beaufort方阵的第$k_i$行$m_i$列的字母.</p>\n<h3 id=\"Vernam\"><a href=\"#Vernam\" class=\"headerlink\" title=\"Vernam\"></a>Vernam</h3><p>将明文编码为0,1字符串, 且密钥也属于0,1的区域. 那么密文为:</p>\n<script type=\"math/tex; mode=display\">\nc_i =m_i \\oplus k_i \\\\\n同时\\  k_i = m_i \\oplus c_i</script><h3 id=\"Hill体制\"><a href=\"#Hill体制\" class=\"headerlink\" title=\"Hill体制\"></a>Hill体制</h3><p>Hill的思想是对于<code>n</code>位的明文字符串, 使用<code>nxn</code>的可逆矩阵$K$进行加密.</p>\n<script type=\"math/tex; mode=display\">\nc = m\\cdot K \\ mod \\ 26 \\\\\nm = c \\cdot K^{-1} \\ mod \\ 26</script><p>e.g. :</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th><img src=\"cryptography.assets/image-20250224195809124.png\" alt=\"image-20250224195809124\" style=\"zoom:50%;\" /></th>\n<th><img src=\"cryptography.assets/image-20250224195821189.png\" alt=\"image-20250224195821189\" style=\"zoom:50%;\" /></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>从0开始.</p>\n</blockquote>\n<h3 id=\"Enigma\"><a href=\"#Enigma\" class=\"headerlink\" title=\"Enigma\"></a>Enigma</h3><p>TODO</p>\n<h2 id=\"课堂摘记缓冲区\"><a href=\"#课堂摘记缓冲区\" class=\"headerlink\" title=\"课堂摘记缓冲区\"></a>课堂摘记缓冲区</h2><ul>\n<li>异或相当于加法取模运算</li>\n</ul>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><h3 id=\"ase\"><a href=\"#ase\" class=\"headerlink\" title=\"ase\"></a>ase</h3><ul>\n<li>将明文<code>p</code>作为输入, 得到一个检验值<code>crc</code>, 同时将<code>p</code>在某种加密算法下加密得到<code>p&#39;</code>.</li>\n<li>将<code>p’</code>与<code>crc</code>保存在加密之后的文件当中.</li>\n<li>解密时, 将给出的密码作为输入, 由给定的解密函数得到<code>p&#39;&#39;</code>, 然后由<code>p&#39;&#39;</code>得到对应的检验值<code>crc’</code>;</li>\n<li>判断前后的检验值是否相同, 如果相同, 说明输入的密码正确, 解密得到的<code>p&#39;&#39;</code>就是`p’. 否则说明密码错误.</li>\n</ul>\n<h3 id=\"ecc\"><a href=\"#ecc\" class=\"headerlink\" title=\"ecc\"></a>ecc</h3><p>椭圆曲线加密算法</p>\n<h3 id=\"rsa\"><a href=\"#rsa\" class=\"headerlink\" title=\"rsa\"></a>rsa</h3>"},{"_content":"\n\n<center><span style=\"font-size: 1.8em; font-weight: 600\">浙江大学实验报告</span></center>\n\n\n\n\n\n<div style=\"font-size: 1.3em; line-height: 2;\">\n  课程名称: &emsp;<b>&emsp;计算机体系结构&emsp;</b> <span style = \"float:right;\">实验类型: <b>&emsp;综合&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span><br>\n实验项目名称:&emsp; <br>&emsp;<b>Lab1:</b>&emsp;Implement pipelined CPU with forwarding paths and\nprediction-not-taken supporting RISC V 32I instructions.&emsp; <br>\n指导老师: <b> &emsp;何水兵 &emsp;</b><span style=\"float: right;\">完成时间: &emsp;<b>&emsp;2025.2.24&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span>\n</div>\n\n\n\n\n\n| 姓名         | 卓俊豪 | 学号 | 3230103739 |\n| ------------ | ------ | ---- | ---------- |\n| 同组学生姓名 | 魏云翔 | 学号 | 3230105111 |\n| 分工信息 |代码模块讨论( 该lab的report独立完成 )|||\n\n**目录:**\n\n[TOC]\n\n<div style=\"page-break-after:always;\"></div>\n\n\n## 一、实验目的和要求\n\n### 1.1 Purpose\n\n- Understand  RISC-V RV32I instructions\n- Master the design methods of **pipelined** CPU executing RV32I instructions\n- Master the method of Pipeline **Forwarding Detection** and **bypass unit** design\n- Master the methods of 1-cycle stall of **Predict-not-taken** branch design\n- master methods of program **verification** of Pipelined CPU executing RV32I instructions\n\n### 1.2 Experiment Task\n\n- Deign of Pipelined CPU executing RV32I instructions.\n  - Design datapath\n  - Design Bypass Unit\n  - Design CPU Controller\n- Verify the Pipelined CPU with program and observe the execution  of program\n\n\n\n<div style=\"page-break-after:always;\"></div>\n\n## 二、 实验内容及原理\n\n在流水线CPU中, 存在三种`Hazards` :\n\n- Structural hazard;\n- Data hazard;\n- Control hazard.\n\n### 2.1 结构冒险分析\n\n​\t对于Structural hazard(结构冒险), 在本试验中表现为”在同一个时钟周期内对寄存器堆进行读和写“. 为了解决这个冒险, 我们只需要将读写分离——在时钟信号的下降沿写入目标寄存器的值, 而在时钟信号的上升沿令其他寄存器读取输入信号.\n\n```verilog\nalways @(negedge clk or posedge rst) \n      begin\n\t\t...\n\t\telse begin\n\t\t     if ((Wt_addr != 0) && (L_S == 1)) \t// write\n\t\t     register[Wt_addr] <= Wt_data;\n\t\tend\n\tend\n```\n\n​\t因此, 结构冒险不是我们解决的重点, 本试验需要着重考虑的是另外两种冒险.\n### 2.2 数据冒险分析\n\nData hazard(数据冒险)指的是指令之间存在数据依赖关系, 导致数据读取错误的情况. 有以下几种方式和情形:\n\n1. **Stall**\n\n<table style=\"border:none\">\n    <tr>\n        <td style = \"width:50%\"><img src=\"assets/image-20250223113231052.png\" alt=\"image-20250223113231052\" style=\"zoom:50%;\" /></td>\n        <td style=\"vertical-align:center; width:50%\">\n          <ul>\n            <li> 由于涉及ALU操作的R/I类型指令需要在WB阶段才将计算结果写入目标寄存器, 此时ID阶段的寄存器堆才能正常更新和输出.\t\t\t\t\t\t</li>\n            <li> 因此如果两条存在数据依赖的上述指令前后相邻时, 只需要在第一条指令后插入两个bubble, 就可以避免数据冒险.</li>\n          </ul>\n        </td>\n    </tr>\n</table>\n\n2. **Forward**\n\n<table>\n    <tr>\n        <td style=\"width:50%; text-align:center\">\n          <ul>\n            <li>对于上述Stall碰到的情况, 由于前一条指令的目标寄存器的值实际上在EX阶段已经计算得到, 因此只需要将此时的计算结果前递(forwarding)到ID阶段, 作为对应的源寄存器的值即可.\n            </li>\n          </ul>\n        </td>\n        <td style=\"width:50%\"><img src=\"assets/image-20250223114642120.png\" style=\"zoom:50%;\" /></td>\n    </tr>\n</table>\n\n对于load-store的情况需要继续分类讨论:\n\n- 若store的`rs2`来自于load的目标寄存器`rd`: 在load的MEM阶段将`rd`**forwarding**, 将其与“正常”的`rs2`组成EX阶段的2T1多选器的输入信号, 并且让冒险检测单元产生的`forward_ctrl_ls`信号作为其选择信号.<img src=\"assets/image-20250223144526402.png\" alt=\"image-20250223144526402\" style=\"zoom:40%;\" />\n\n- 若store的`rs1`即写入内存的地址需要load的`rd`参与计算得到, 则在不额外增加`unit`的情况下, 需要**stall**1个时钟周期, 从而让store指令在其EX阶段计算得到正确的地址. ( 相当于load-use).\n\n通过forwarding还无法避免stall的另一种情况是: **load-use**. 如下图所示, 如果LW的目标寄存器和ADD的rs1相同, 那么LW在其MEM阶段进行访存, 无法为EXE阶段的ADD提供操作数. 必须插入一个bubble才能避免这种数据冒险.\n\n<img src=\"assets/image-20250223145841793.png\" alt=\"image-20250223145841793\" style=\"zoom:40%;\" />\n\n### 2.3 控制冒险分析\n\n对于Control hazard(控制冒险), 我们可以采取的策略有简单的stall——让分支指令运行完其EXE阶段,然后根据是否跳转来选择IF的PC来源. 除此之外, 我们存在`predict`的方法, 也就是预测分支语句是否执行跳转. \n\n我们采取**Predict-not-taken**的分支预测策略, 同时将地址计算和条件比较的过程前推到了ID阶段, 使得:\n\n- 如果预测正确, 不会产生stall;\n- 如果预测错误, 需要跳转, 则将此时ID阶段计算得到的地址作为下一条IF取址的地址, 并且令冒险检测单元输出IF/ID寄存器的`flush`信号, 避免当前IF区域错误指令的干扰, 因此整体上看, 流水线stall了1个时钟周期.\n\n> 如果采取**Predict--taken**的策略, 即使我们将地址计算和条件比较都前推到ID阶段, 无论预测是否正确, 都需要stall一个时钟周期.\n\n\n\n​\t具体实现的部分**代码**将在**第三部分**结合原理图给出.\n<div style=\"page-break-after:always;\"></div>\n\n## 三、 实验过程和数据记录及结果分析\n\n### 3.1 原理图\n\n<img src=\"assets/image-20250223204007274.png\" alt=\"image-20250223204007274\" style=\"zoom:100%;\" />\n\n> 更加完善的版本请见最后部分.\n\n### 3.2 模块实现\n\n#### (1) cmp_32\n\n比较模块的主要功能就是判断分支跳转的条件是否成立, 也就是和控制单元模块结合, 将条件判断的阶段**前推**到ID阶段.\n\n```verilog\n  assign c = {EQ & res_EQ} | \n          {NE & res_NE} |\n          {LT & res_LT} |\n          {LTU & res_LTU} |\n          {GE & res_GE} |\n          {GEU & res_GEU};\n```\n\n- `EQ`等由`ctrl`决定, 即指令代表的判断条件类型, `res_xx`表示根据对应的判断类型, 输入的`rs1`与`rs2`的比较结果;\n- 任何情况下, `ctrl`决定了这六个析取操作(`|`)只能有一个可能为真, 类似于多选器的选择信号;\n- 根据计算结果, 输出`c`表示分支跳转的判断条件是否成立, 并输入到控制单元.\n\n#### (2) CtrlUnit\n\n控制单元以指令`inst`和上述比较模块的输出`cmp_res`作为输入, 在ID阶段译码得到`DatatoReg`等指令. \n\n与普通的流水线相比, 这个控制单元还另外译码B类型的指令, 得到不同条件的分支指令如`bge`, `bltu`等, 将其作为输出连接到比较单元.\n\n```verilog\nassign hazard_optype = {2{R_valid | I_valid}} & 2'b00 |\n                    {2{L_valid}} & 2'b01 |\n                    {2{S_valid}}           & 2'b10 |\n                    {2{B_valid | JAL | JALR}}    & 2'b11\n;       \n```\n\n#### (3) HazardDetectionUnit\n\n**数据冒险**的处理:\n\n```verilog\n  // MEM阶段的前推\n  if(rd_MEM != 0)begin \n      if( rs1_ID == rd_MEM && rs1use_ID )\n          forward_ctrl_A = 2'b10;\n      if( rs2_ID == rd_MEM && rs2use_ID )\n          forward_ctrl_B = 2'b10;\n  end\n\n  // EXE阶段的前推\n  if(rd_EXE != 0 ) begin \n      if( rs1_ID == rd_EXE && rs1use_ID)\n          forward_ctrl_A = 2'b01; \n      if( rs2_ID == rd_EXE && rs2use_ID)\n          forward_ctrl_B = 2'b01; \n  end\n```\n\n> 将EXE阶段的判断置于下方, 使得情况同时存在时确保从**EXE**阶段前推.\n\n**e.g.** 从EXE阶段到ID的rs1的前推:\n\n<img src=\"assets/image-20250224084543612.png\" alt=\"image-20250224084543612\" style=\"zoom:40%;\" />\n\n**load**类型的处理:\n\n```verilog\n// load-store situation:\nif(rd_EXE != 0 && (hazard_optype_EXE == load_OP) && (hazard_optype_ID == store_OP)) begin \n    if(rs2_ID == rd_EXE)\n        forward_ctrl_ls = 1'b1;\n        forward_ctrl_B = 2'b00;\nend\n\n// load-use situation:\nif(rd_EXE != 0 && hazard_optype_EXE == load_OP &&\n\t((rs1use_ID && rs1_ID == rd_EXE) || (rs2use_ID && rs2_ID == rd_EXE))) begin\n// need bubble\n    reg_FD_stall = 1'b1;\n    reg_DE_flush = 1'b1;\n    PC_EN_IF = 1'b0; // 中止取址\nend\n```\n\n> 为了避免load_use的情况下数据冒险部分的前推同时成立的错误, 直接设置`forward_ctrl_B = 2'b00;`.\n\n**e.g.** load-store(只需前推)的情况:\n\n<img src=\"assets/image-20250224085632929.png\" alt=\"image-20250224085632929\" style=\"zoom:40%;\" />\n\n**控制冒险的处理**:\n\n```verilog\n// branch / jump FIXME\nif(Branch_ID || hazard_optype_ID == JUMP_OP)begin \n    reg_FD_flush = 1'b1;\nend\n```\n\n**e.g.** `JALR`的情况\n\n<img src=\"assets/image-20250224090508036.png\" alt=\"image-20250224090508036\" style=\"zoom:40%;\" /> \n\n### 3.3 仿真及波形解释\n**load-use:**\n<img src=\"lab1_report.assets/image-20250224162025072.png\" alt=\"image-20250224162025072\" style=\"zoom:40%;\" />\n\n> `add x1, x2,x4`的`rs2`来自上一条指令(load类型)的`rd`, 因此处于ID阶段的`add`指令stall, 且暂停IF阶段的PC取址一个时钟周期.\n\n**load-store:**\n\n<img src=\"lab1_report.assets/image-20250224162724537.png\" alt=\"image-20250224162724537\" style=\"zoom:40%;\" />\n\n**Branch**:\n\n<img src=\"lab1_report.assets/image-20250224163759935.png\" alt=\"image-20250224163759935\" style=\"zoom:40%;\" />\n\n> `bge x4,x4,label6` 发生跳转, 由于采取的是predict-not-taken的分支预测策略, 因此当这条指令进入ID阶段并经过条件判断, 发现实际需要跳转时, 令IF/ID寄存器的`flush`信号为`1`, 也就是清除了此时IF阶段的指令, 并将跳转地址赋值给PC, 相当于stall了一个时钟周期.\n\n**JALR**:\n\n<img src=\"lab1_report.assets/image-20250224164548855.png\" alt=\"image-20250224164548855\" style=\"zoom:40%;\" />\n\n> JALR在进入ID阶段后立即进行地址的计算, 并在下一个时钟周期跳转到正确的地址取址.\n\n### 3.4 下板\n\n<img src=\"lab1_report.assets/image-20250224170505856.png\" alt=\"image-20250224170505856\" style=\"zoom:20%;\" />\n\n<img src=\"lab1_report.assets/image-20250224170529795.png\" alt=\"image-20250224170529795\" style=\"zoom:20%;\" />\n\n<img src=\"lab1_report.assets/image-20250224170548503.png\" alt=\"image-20250224170548503\" style=\"zoom:20%;\" />\n\n\n<div style=\"page-break-after:always;\"></div>\n\n## 四、 讨论与心得\n\n​\t第一次体系结构实验, 收获还是不少的.\n\n​\t首先是团队合作方面. 数逻和计组都是单人实验的我, 在体系结构实验组队, 和队友讨论的收获很多. 我先写完整体代码, 然后一边写对应的文档, 一边仿真检查并画出对应的原理图. 当我画到EXE阶段的PC输入的多选器时, 我有了疑惑——这个CPU设计理念已经将跳转的地址计算和条件比较前推到了ID阶段, 继续将PC地址传递是不是没有必要? 于是我将其标红并继续了实验. 但是和队友交流之后, 我发现PC在之后的阶段还是有作用的——比如JUMP类型的指令需要将`pc+4`写入目标寄存器, 在WB阶段实现. 因此, 我补充了对应的数据通路并标红:<img src=\"lab1_report.assets/image-20250224165720059.png\" alt=\"image-20250224165720059\" style=\"zoom:40%;\" />\n\n​\t另外, 我画`load-store`原理图的时候想到, 助教上课提到过: 如果`store`的`rs1`来自于`load`的`rd`, 那么访存的地址计算要求S指令在EXE阶段的开始就获得对应的值, 因此需要store. 我本想在原来的基础上继续加一层判断, 但是和队友交流之后发现, 实际上这已经囊括在了`load-use`的范畴里, 不需要额外的修改.\n\n​\t在讨论的最后, 我其实还有一个问题——`cmp_32`模块似乎没有必要独立作为一个模块? 其实可以直接并入控制单元? 综上来看, 相比于计组实验的从无到有, 结构实验要求我们以`top-down`的角度理解现有代码的功能和交互, 实际上也是一种挑战.\n\n","source":"_drafts/temp_notes/lab1_report.md","raw":"\n\n<center><span style=\"font-size: 1.8em; font-weight: 600\">浙江大学实验报告</span></center>\n\n\n\n\n\n<div style=\"font-size: 1.3em; line-height: 2;\">\n  课程名称: &emsp;<b>&emsp;计算机体系结构&emsp;</b> <span style = \"float:right;\">实验类型: <b>&emsp;综合&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span><br>\n实验项目名称:&emsp; <br>&emsp;<b>Lab1:</b>&emsp;Implement pipelined CPU with forwarding paths and\nprediction-not-taken supporting RISC V 32I instructions.&emsp; <br>\n指导老师: <b> &emsp;何水兵 &emsp;</b><span style=\"float: right;\">完成时间: &emsp;<b>&emsp;2025.2.24&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span>\n</div>\n\n\n\n\n\n| 姓名         | 卓俊豪 | 学号 | 3230103739 |\n| ------------ | ------ | ---- | ---------- |\n| 同组学生姓名 | 魏云翔 | 学号 | 3230105111 |\n| 分工信息 |代码模块讨论( 该lab的report独立完成 )|||\n\n**目录:**\n\n[TOC]\n\n<div style=\"page-break-after:always;\"></div>\n\n\n## 一、实验目的和要求\n\n### 1.1 Purpose\n\n- Understand  RISC-V RV32I instructions\n- Master the design methods of **pipelined** CPU executing RV32I instructions\n- Master the method of Pipeline **Forwarding Detection** and **bypass unit** design\n- Master the methods of 1-cycle stall of **Predict-not-taken** branch design\n- master methods of program **verification** of Pipelined CPU executing RV32I instructions\n\n### 1.2 Experiment Task\n\n- Deign of Pipelined CPU executing RV32I instructions.\n  - Design datapath\n  - Design Bypass Unit\n  - Design CPU Controller\n- Verify the Pipelined CPU with program and observe the execution  of program\n\n\n\n<div style=\"page-break-after:always;\"></div>\n\n## 二、 实验内容及原理\n\n在流水线CPU中, 存在三种`Hazards` :\n\n- Structural hazard;\n- Data hazard;\n- Control hazard.\n\n### 2.1 结构冒险分析\n\n​\t对于Structural hazard(结构冒险), 在本试验中表现为”在同一个时钟周期内对寄存器堆进行读和写“. 为了解决这个冒险, 我们只需要将读写分离——在时钟信号的下降沿写入目标寄存器的值, 而在时钟信号的上升沿令其他寄存器读取输入信号.\n\n```verilog\nalways @(negedge clk or posedge rst) \n      begin\n\t\t...\n\t\telse begin\n\t\t     if ((Wt_addr != 0) && (L_S == 1)) \t// write\n\t\t     register[Wt_addr] <= Wt_data;\n\t\tend\n\tend\n```\n\n​\t因此, 结构冒险不是我们解决的重点, 本试验需要着重考虑的是另外两种冒险.\n### 2.2 数据冒险分析\n\nData hazard(数据冒险)指的是指令之间存在数据依赖关系, 导致数据读取错误的情况. 有以下几种方式和情形:\n\n1. **Stall**\n\n<table style=\"border:none\">\n    <tr>\n        <td style = \"width:50%\"><img src=\"assets/image-20250223113231052.png\" alt=\"image-20250223113231052\" style=\"zoom:50%;\" /></td>\n        <td style=\"vertical-align:center; width:50%\">\n          <ul>\n            <li> 由于涉及ALU操作的R/I类型指令需要在WB阶段才将计算结果写入目标寄存器, 此时ID阶段的寄存器堆才能正常更新和输出.\t\t\t\t\t\t</li>\n            <li> 因此如果两条存在数据依赖的上述指令前后相邻时, 只需要在第一条指令后插入两个bubble, 就可以避免数据冒险.</li>\n          </ul>\n        </td>\n    </tr>\n</table>\n\n2. **Forward**\n\n<table>\n    <tr>\n        <td style=\"width:50%; text-align:center\">\n          <ul>\n            <li>对于上述Stall碰到的情况, 由于前一条指令的目标寄存器的值实际上在EX阶段已经计算得到, 因此只需要将此时的计算结果前递(forwarding)到ID阶段, 作为对应的源寄存器的值即可.\n            </li>\n          </ul>\n        </td>\n        <td style=\"width:50%\"><img src=\"assets/image-20250223114642120.png\" style=\"zoom:50%;\" /></td>\n    </tr>\n</table>\n\n对于load-store的情况需要继续分类讨论:\n\n- 若store的`rs2`来自于load的目标寄存器`rd`: 在load的MEM阶段将`rd`**forwarding**, 将其与“正常”的`rs2`组成EX阶段的2T1多选器的输入信号, 并且让冒险检测单元产生的`forward_ctrl_ls`信号作为其选择信号.<img src=\"assets/image-20250223144526402.png\" alt=\"image-20250223144526402\" style=\"zoom:40%;\" />\n\n- 若store的`rs1`即写入内存的地址需要load的`rd`参与计算得到, 则在不额外增加`unit`的情况下, 需要**stall**1个时钟周期, 从而让store指令在其EX阶段计算得到正确的地址. ( 相当于load-use).\n\n通过forwarding还无法避免stall的另一种情况是: **load-use**. 如下图所示, 如果LW的目标寄存器和ADD的rs1相同, 那么LW在其MEM阶段进行访存, 无法为EXE阶段的ADD提供操作数. 必须插入一个bubble才能避免这种数据冒险.\n\n<img src=\"assets/image-20250223145841793.png\" alt=\"image-20250223145841793\" style=\"zoom:40%;\" />\n\n### 2.3 控制冒险分析\n\n对于Control hazard(控制冒险), 我们可以采取的策略有简单的stall——让分支指令运行完其EXE阶段,然后根据是否跳转来选择IF的PC来源. 除此之外, 我们存在`predict`的方法, 也就是预测分支语句是否执行跳转. \n\n我们采取**Predict-not-taken**的分支预测策略, 同时将地址计算和条件比较的过程前推到了ID阶段, 使得:\n\n- 如果预测正确, 不会产生stall;\n- 如果预测错误, 需要跳转, 则将此时ID阶段计算得到的地址作为下一条IF取址的地址, 并且令冒险检测单元输出IF/ID寄存器的`flush`信号, 避免当前IF区域错误指令的干扰, 因此整体上看, 流水线stall了1个时钟周期.\n\n> 如果采取**Predict--taken**的策略, 即使我们将地址计算和条件比较都前推到ID阶段, 无论预测是否正确, 都需要stall一个时钟周期.\n\n\n\n​\t具体实现的部分**代码**将在**第三部分**结合原理图给出.\n<div style=\"page-break-after:always;\"></div>\n\n## 三、 实验过程和数据记录及结果分析\n\n### 3.1 原理图\n\n<img src=\"assets/image-20250223204007274.png\" alt=\"image-20250223204007274\" style=\"zoom:100%;\" />\n\n> 更加完善的版本请见最后部分.\n\n### 3.2 模块实现\n\n#### (1) cmp_32\n\n比较模块的主要功能就是判断分支跳转的条件是否成立, 也就是和控制单元模块结合, 将条件判断的阶段**前推**到ID阶段.\n\n```verilog\n  assign c = {EQ & res_EQ} | \n          {NE & res_NE} |\n          {LT & res_LT} |\n          {LTU & res_LTU} |\n          {GE & res_GE} |\n          {GEU & res_GEU};\n```\n\n- `EQ`等由`ctrl`决定, 即指令代表的判断条件类型, `res_xx`表示根据对应的判断类型, 输入的`rs1`与`rs2`的比较结果;\n- 任何情况下, `ctrl`决定了这六个析取操作(`|`)只能有一个可能为真, 类似于多选器的选择信号;\n- 根据计算结果, 输出`c`表示分支跳转的判断条件是否成立, 并输入到控制单元.\n\n#### (2) CtrlUnit\n\n控制单元以指令`inst`和上述比较模块的输出`cmp_res`作为输入, 在ID阶段译码得到`DatatoReg`等指令. \n\n与普通的流水线相比, 这个控制单元还另外译码B类型的指令, 得到不同条件的分支指令如`bge`, `bltu`等, 将其作为输出连接到比较单元.\n\n```verilog\nassign hazard_optype = {2{R_valid | I_valid}} & 2'b00 |\n                    {2{L_valid}} & 2'b01 |\n                    {2{S_valid}}           & 2'b10 |\n                    {2{B_valid | JAL | JALR}}    & 2'b11\n;       \n```\n\n#### (3) HazardDetectionUnit\n\n**数据冒险**的处理:\n\n```verilog\n  // MEM阶段的前推\n  if(rd_MEM != 0)begin \n      if( rs1_ID == rd_MEM && rs1use_ID )\n          forward_ctrl_A = 2'b10;\n      if( rs2_ID == rd_MEM && rs2use_ID )\n          forward_ctrl_B = 2'b10;\n  end\n\n  // EXE阶段的前推\n  if(rd_EXE != 0 ) begin \n      if( rs1_ID == rd_EXE && rs1use_ID)\n          forward_ctrl_A = 2'b01; \n      if( rs2_ID == rd_EXE && rs2use_ID)\n          forward_ctrl_B = 2'b01; \n  end\n```\n\n> 将EXE阶段的判断置于下方, 使得情况同时存在时确保从**EXE**阶段前推.\n\n**e.g.** 从EXE阶段到ID的rs1的前推:\n\n<img src=\"assets/image-20250224084543612.png\" alt=\"image-20250224084543612\" style=\"zoom:40%;\" />\n\n**load**类型的处理:\n\n```verilog\n// load-store situation:\nif(rd_EXE != 0 && (hazard_optype_EXE == load_OP) && (hazard_optype_ID == store_OP)) begin \n    if(rs2_ID == rd_EXE)\n        forward_ctrl_ls = 1'b1;\n        forward_ctrl_B = 2'b00;\nend\n\n// load-use situation:\nif(rd_EXE != 0 && hazard_optype_EXE == load_OP &&\n\t((rs1use_ID && rs1_ID == rd_EXE) || (rs2use_ID && rs2_ID == rd_EXE))) begin\n// need bubble\n    reg_FD_stall = 1'b1;\n    reg_DE_flush = 1'b1;\n    PC_EN_IF = 1'b0; // 中止取址\nend\n```\n\n> 为了避免load_use的情况下数据冒险部分的前推同时成立的错误, 直接设置`forward_ctrl_B = 2'b00;`.\n\n**e.g.** load-store(只需前推)的情况:\n\n<img src=\"assets/image-20250224085632929.png\" alt=\"image-20250224085632929\" style=\"zoom:40%;\" />\n\n**控制冒险的处理**:\n\n```verilog\n// branch / jump FIXME\nif(Branch_ID || hazard_optype_ID == JUMP_OP)begin \n    reg_FD_flush = 1'b1;\nend\n```\n\n**e.g.** `JALR`的情况\n\n<img src=\"assets/image-20250224090508036.png\" alt=\"image-20250224090508036\" style=\"zoom:40%;\" /> \n\n### 3.3 仿真及波形解释\n**load-use:**\n<img src=\"lab1_report.assets/image-20250224162025072.png\" alt=\"image-20250224162025072\" style=\"zoom:40%;\" />\n\n> `add x1, x2,x4`的`rs2`来自上一条指令(load类型)的`rd`, 因此处于ID阶段的`add`指令stall, 且暂停IF阶段的PC取址一个时钟周期.\n\n**load-store:**\n\n<img src=\"lab1_report.assets/image-20250224162724537.png\" alt=\"image-20250224162724537\" style=\"zoom:40%;\" />\n\n**Branch**:\n\n<img src=\"lab1_report.assets/image-20250224163759935.png\" alt=\"image-20250224163759935\" style=\"zoom:40%;\" />\n\n> `bge x4,x4,label6` 发生跳转, 由于采取的是predict-not-taken的分支预测策略, 因此当这条指令进入ID阶段并经过条件判断, 发现实际需要跳转时, 令IF/ID寄存器的`flush`信号为`1`, 也就是清除了此时IF阶段的指令, 并将跳转地址赋值给PC, 相当于stall了一个时钟周期.\n\n**JALR**:\n\n<img src=\"lab1_report.assets/image-20250224164548855.png\" alt=\"image-20250224164548855\" style=\"zoom:40%;\" />\n\n> JALR在进入ID阶段后立即进行地址的计算, 并在下一个时钟周期跳转到正确的地址取址.\n\n### 3.4 下板\n\n<img src=\"lab1_report.assets/image-20250224170505856.png\" alt=\"image-20250224170505856\" style=\"zoom:20%;\" />\n\n<img src=\"lab1_report.assets/image-20250224170529795.png\" alt=\"image-20250224170529795\" style=\"zoom:20%;\" />\n\n<img src=\"lab1_report.assets/image-20250224170548503.png\" alt=\"image-20250224170548503\" style=\"zoom:20%;\" />\n\n\n<div style=\"page-break-after:always;\"></div>\n\n## 四、 讨论与心得\n\n​\t第一次体系结构实验, 收获还是不少的.\n\n​\t首先是团队合作方面. 数逻和计组都是单人实验的我, 在体系结构实验组队, 和队友讨论的收获很多. 我先写完整体代码, 然后一边写对应的文档, 一边仿真检查并画出对应的原理图. 当我画到EXE阶段的PC输入的多选器时, 我有了疑惑——这个CPU设计理念已经将跳转的地址计算和条件比较前推到了ID阶段, 继续将PC地址传递是不是没有必要? 于是我将其标红并继续了实验. 但是和队友交流之后, 我发现PC在之后的阶段还是有作用的——比如JUMP类型的指令需要将`pc+4`写入目标寄存器, 在WB阶段实现. 因此, 我补充了对应的数据通路并标红:<img src=\"lab1_report.assets/image-20250224165720059.png\" alt=\"image-20250224165720059\" style=\"zoom:40%;\" />\n\n​\t另外, 我画`load-store`原理图的时候想到, 助教上课提到过: 如果`store`的`rs1`来自于`load`的`rd`, 那么访存的地址计算要求S指令在EXE阶段的开始就获得对应的值, 因此需要store. 我本想在原来的基础上继续加一层判断, 但是和队友交流之后发现, 实际上这已经囊括在了`load-use`的范畴里, 不需要额外的修改.\n\n​\t在讨论的最后, 我其实还有一个问题——`cmp_32`模块似乎没有必要独立作为一个模块? 其实可以直接并入控制单元? 综上来看, 相比于计组实验的从无到有, 结构实验要求我们以`top-down`的角度理解现有代码的功能和交互, 实际上也是一种挑战.\n\n","slug":"temp_notes/lab1_report","published":0,"date":"2025-02-23T01:51:46.498Z","updated":"2025-02-24T09:24:36.554Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm7kndg8q0006dmqg62li1dgp","content":"<center><span style=\"font-size: 1.8em; font-weight: 600\">浙江大学实验报告</span></center>\n\n\n\n\n\n<div style=\"font-size: 1.3em; line-height: 2;\">\n  课程名称: &emsp;<b>&emsp;计算机体系结构&emsp;</b> <span style = \"float:right;\">实验类型: <b>&emsp;综合&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span><br>\n实验项目名称:&emsp; <br>&emsp;<b>Lab1:</b>&emsp;Implement pipelined CPU with forwarding paths and\nprediction-not-taken supporting RISC V 32I instructions.&emsp; <br>\n指导老师: <b> &emsp;何水兵 &emsp;</b><span style=\"float: right;\">完成时间: &emsp;<b>&emsp;2025.2.24&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span>\n</div>\n\n\n\n\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>卓俊豪</th>\n<th>学号</th>\n<th>3230103739</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同组学生姓名</td>\n<td>魏云翔</td>\n<td>学号</td>\n<td>3230105111</td>\n</tr>\n<tr>\n<td>分工信息</td>\n<td>代码模块讨论( 该lab的report独立完成 )</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>目录:</strong></p>\n<p>[TOC]</p>\n<div style=\"page-break-after:always;\"></div>\n\n\n<h2 id=\"一、实验目的和要求\"><a href=\"#一、实验目的和要求\" class=\"headerlink\" title=\"一、实验目的和要求\"></a>一、实验目的和要求</h2><h3 id=\"1-1-Purpose\"><a href=\"#1-1-Purpose\" class=\"headerlink\" title=\"1.1 Purpose\"></a>1.1 Purpose</h3><ul>\n<li>Understand  RISC-V RV32I instructions</li>\n<li>Master the design methods of <strong>pipelined</strong> CPU executing RV32I instructions</li>\n<li>Master the method of Pipeline <strong>Forwarding Detection</strong> and <strong>bypass unit</strong> design</li>\n<li>Master the methods of 1-cycle stall of <strong>Predict-not-taken</strong> branch design</li>\n<li>master methods of program <strong>verification</strong> of Pipelined CPU executing RV32I instructions</li>\n</ul>\n<h3 id=\"1-2-Experiment-Task\"><a href=\"#1-2-Experiment-Task\" class=\"headerlink\" title=\"1.2 Experiment Task\"></a>1.2 Experiment Task</h3><ul>\n<li>Deign of Pipelined CPU executing RV32I instructions.<ul>\n<li>Design datapath</li>\n<li>Design Bypass Unit</li>\n<li>Design CPU Controller</li>\n</ul>\n</li>\n<li>Verify the Pipelined CPU with program and observe the execution  of program</li>\n</ul>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"二、-实验内容及原理\"><a href=\"#二、-实验内容及原理\" class=\"headerlink\" title=\"二、 实验内容及原理\"></a>二、 实验内容及原理</h2><p>在流水线CPU中, 存在三种<code>Hazards</code> :</p>\n<ul>\n<li>Structural hazard;</li>\n<li>Data hazard;</li>\n<li>Control hazard.</li>\n</ul>\n<h3 id=\"2-1-结构冒险分析\"><a href=\"#2-1-结构冒险分析\" class=\"headerlink\" title=\"2.1 结构冒险分析\"></a>2.1 结构冒险分析</h3><p>​    对于Structural hazard(结构冒险), 在本试验中表现为”在同一个时钟周期内对寄存器堆进行读和写“. 为了解决这个冒险, 我们只需要将读写分离——在时钟信号的下降沿写入目标寄存器的值, 而在时钟信号的上升沿令其他寄存器读取输入信号.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">always</span> @(<span class=\"hljs-keyword\">negedge</span> clk <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">posedge</span> rst) <br>      <span class=\"hljs-keyword\">begin</span><br>\t\t...<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">begin</span><br>\t\t     <span class=\"hljs-keyword\">if</span> ((Wt_addr != <span class=\"hljs-number\">0</span>) &amp;&amp; (L_S == <span class=\"hljs-number\">1</span>)) \t<span class=\"hljs-comment\">// write</span><br>\t\t     register[Wt_addr] &lt;= Wt_data;<br>\t\t<span class=\"hljs-keyword\">end</span><br>\t<span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<p>​    因此, 结构冒险不是我们解决的重点, 本试验需要着重考虑的是另外两种冒险.</p>\n<h3 id=\"2-2-数据冒险分析\"><a href=\"#2-2-数据冒险分析\" class=\"headerlink\" title=\"2.2 数据冒险分析\"></a>2.2 数据冒险分析</h3><p>Data hazard(数据冒险)指的是指令之间存在数据依赖关系, 导致数据读取错误的情况. 有以下几种方式和情形:</p>\n<ol>\n<li><strong>Stall</strong></li>\n</ol>\n<table style=\"border:none\">\n    <tr>\n        <td style = \"width:50%\"><img src=\"assets/image-20250223113231052.png\" alt=\"image-20250223113231052\" style=\"zoom:50%;\" /></td>\n        <td style=\"vertical-align:center; width:50%\">\n          <ul>\n            <li> 由于涉及ALU操作的R/I类型指令需要在WB阶段才将计算结果写入目标寄存器, 此时ID阶段的寄存器堆才能正常更新和输出.                        </li>\n            <li> 因此如果两条存在数据依赖的上述指令前后相邻时, 只需要在第一条指令后插入两个bubble, 就可以避免数据冒险.</li>\n          </ul>\n        </td>\n    </tr>\n</table>\n\n<ol>\n<li><strong>Forward</strong></li>\n</ol>\n<table>\n    <tr>\n        <td style=\"width:50%; text-align:center\">\n          <ul>\n            <li>对于上述Stall碰到的情况, 由于前一条指令的目标寄存器的值实际上在EX阶段已经计算得到, 因此只需要将此时的计算结果前递(forwarding)到ID阶段, 作为对应的源寄存器的值即可.\n            </li>\n          </ul>\n        </td>\n        <td style=\"width:50%\"><img src=\"assets/image-20250223114642120.png\" style=\"zoom:50%;\" /></td>\n    </tr>\n</table>\n\n<p>对于load-store的情况需要继续分类讨论:</p>\n<ul>\n<li><p>若store的<code>rs2</code>来自于load的目标寄存器<code>rd</code>: 在load的MEM阶段将<code>rd</code><strong>forwarding</strong>, 将其与“正常”的<code>rs2</code>组成EX阶段的2T1多选器的输入信号, 并且让冒险检测单元产生的<code>forward_ctrl_ls</code>信号作为其选择信号.<img src=\"assets/image-20250223144526402.png\" alt=\"image-20250223144526402\" style=\"zoom:40%;\" /></p>\n</li>\n<li><p>若store的<code>rs1</code>即写入内存的地址需要load的<code>rd</code>参与计算得到, 则在不额外增加<code>unit</code>的情况下, 需要<strong>stall</strong>1个时钟周期, 从而让store指令在其EX阶段计算得到正确的地址. ( 相当于load-use).</p>\n</li>\n</ul>\n<p>通过forwarding还无法避免stall的另一种情况是: <strong>load-use</strong>. 如下图所示, 如果LW的目标寄存器和ADD的rs1相同, 那么LW在其MEM阶段进行访存, 无法为EXE阶段的ADD提供操作数. 必须插入一个bubble才能避免这种数据冒险.</p>\n<p><img src=\"assets/image-20250223145841793.png\" alt=\"image-20250223145841793\" style=\"zoom:40%;\" /></p>\n<h3 id=\"2-3-控制冒险分析\"><a href=\"#2-3-控制冒险分析\" class=\"headerlink\" title=\"2.3 控制冒险分析\"></a>2.3 控制冒险分析</h3><p>对于Control hazard(控制冒险), 我们可以采取的策略有简单的stall——让分支指令运行完其EXE阶段,然后根据是否跳转来选择IF的PC来源. 除此之外, 我们存在<code>predict</code>的方法, 也就是预测分支语句是否执行跳转. </p>\n<p>我们采取<strong>Predict-not-taken</strong>的分支预测策略, 同时将地址计算和条件比较的过程前推到了ID阶段, 使得:</p>\n<ul>\n<li>如果预测正确, 不会产生stall;</li>\n<li>如果预测错误, 需要跳转, 则将此时ID阶段计算得到的地址作为下一条IF取址的地址, 并且令冒险检测单元输出IF/ID寄存器的<code>flush</code>信号, 避免当前IF区域错误指令的干扰, 因此整体上看, 流水线stall了1个时钟周期.</li>\n</ul>\n<blockquote>\n<p>如果采取<strong>Predict—taken</strong>的策略, 即使我们将地址计算和条件比较都前推到ID阶段, 无论预测是否正确, 都需要stall一个时钟周期.</p>\n</blockquote>\n<p>​    具体实现的部分<strong>代码</strong>将在<strong>第三部分</strong>结合原理图给出.</p>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"三、-实验过程和数据记录及结果分析\"><a href=\"#三、-实验过程和数据记录及结果分析\" class=\"headerlink\" title=\"三、 实验过程和数据记录及结果分析\"></a>三、 实验过程和数据记录及结果分析</h2><h3 id=\"3-1-原理图\"><a href=\"#3-1-原理图\" class=\"headerlink\" title=\"3.1 原理图\"></a>3.1 原理图</h3><p><img src=\"assets/image-20250223204007274.png\" alt=\"image-20250223204007274\" style=\"zoom:100%;\" /></p>\n<blockquote>\n<p>更加完善的版本请见最后部分.</p>\n</blockquote>\n<h3 id=\"3-2-模块实现\"><a href=\"#3-2-模块实现\" class=\"headerlink\" title=\"3.2 模块实现\"></a>3.2 模块实现</h3><h4 id=\"1-cmp-32\"><a href=\"#1-cmp-32\" class=\"headerlink\" title=\"(1) cmp_32\"></a>(1) cmp_32</h4><p>比较模块的主要功能就是判断分支跳转的条件是否成立, 也就是和控制单元模块结合, 将条件判断的阶段<strong>前推</strong>到ID阶段.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">assign</span> c = &#123;EQ &amp; res_EQ&#125; | <br>        &#123;NE &amp; res_NE&#125; |<br>        &#123;LT &amp; res_LT&#125; |<br>        &#123;LTU &amp; res_LTU&#125; |<br>        &#123;GE &amp; res_GE&#125; |<br>        &#123;GEU &amp; res_GEU&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>EQ</code>等由<code>ctrl</code>决定, 即指令代表的判断条件类型, <code>res_xx</code>表示根据对应的判断类型, 输入的<code>rs1</code>与<code>rs2</code>的比较结果;</li>\n<li>任何情况下, <code>ctrl</code>决定了这六个析取操作(<code>|</code>)只能有一个可能为真, 类似于多选器的选择信号;</li>\n<li>根据计算结果, 输出<code>c</code>表示分支跳转的判断条件是否成立, 并输入到控制单元.</li>\n</ul>\n<h4 id=\"2-CtrlUnit\"><a href=\"#2-CtrlUnit\" class=\"headerlink\" title=\"(2) CtrlUnit\"></a>(2) CtrlUnit</h4><p>控制单元以指令<code>inst</code>和上述比较模块的输出<code>cmp_res</code>作为输入, 在ID阶段译码得到<code>DatatoReg</code>等指令. </p>\n<p>与普通的流水线相比, 这个控制单元还另外译码B类型的指令, 得到不同条件的分支指令如<code>bge</code>, <code>bltu</code>等, 将其作为输出连接到比较单元.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">assign</span> hazard_optype = &#123;<span class=\"hljs-number\">2</span>&#123;R_valid | I_valid&#125;&#125; &amp; <span class=\"hljs-number\">2&#x27;b00</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;L_valid&#125;&#125; &amp; <span class=\"hljs-number\">2&#x27;b01</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;S_valid&#125;&#125;           &amp; <span class=\"hljs-number\">2&#x27;b10</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;B_valid | JAL | JALR&#125;&#125;    &amp; <span class=\"hljs-number\">2&#x27;b11</span><br>;       <br></code></pre></td></tr></table></figure>\n<h4 id=\"3-HazardDetectionUnit\"><a href=\"#3-HazardDetectionUnit\" class=\"headerlink\" title=\"(3) HazardDetectionUnit\"></a>(3) HazardDetectionUnit</h4><p><strong>数据冒险</strong>的处理:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// MEM阶段的前推</span><br><span class=\"hljs-keyword\">if</span>(rd_MEM != <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>( rs1_ID == rd_MEM &amp;&amp; rs1use_ID )<br>        forward_ctrl_A = <span class=\"hljs-number\">2&#x27;b10</span>;<br>    <span class=\"hljs-keyword\">if</span>( rs2_ID == rd_MEM &amp;&amp; rs2use_ID )<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b10</span>;<br><span class=\"hljs-keyword\">end</span><br><br><span class=\"hljs-comment\">// EXE阶段的前推</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> ) <span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>( rs1_ID == rd_EXE &amp;&amp; rs1use_ID)<br>        forward_ctrl_A = <span class=\"hljs-number\">2&#x27;b01</span>; <br>    <span class=\"hljs-keyword\">if</span>( rs2_ID == rd_EXE &amp;&amp; rs2use_ID)<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b01</span>; <br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>将EXE阶段的判断置于下方, 使得情况同时存在时确保从<strong>EXE</strong>阶段前推.</p>\n</blockquote>\n<p><strong>e.g.</strong> 从EXE阶段到ID的rs1的前推:</p>\n<p><img src=\"assets/image-20250224084543612.png\" alt=\"image-20250224084543612\" style=\"zoom:40%;\" /></p>\n<p><strong>load</strong>类型的处理:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// load-store situation:</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> &amp;&amp; (hazard_optype_EXE == load_OP) &amp;&amp; (hazard_optype_ID == store_OP)) <span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>(rs2_ID == rd_EXE)<br>        forward_ctrl_ls = <span class=\"hljs-number\">1&#x27;b1</span>;<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b00</span>;<br><span class=\"hljs-keyword\">end</span><br><br><span class=\"hljs-comment\">// load-use situation:</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> &amp;&amp; hazard_optype_EXE == load_OP &amp;&amp;<br>\t((rs1use_ID &amp;&amp; rs1_ID == rd_EXE) || (rs2use_ID &amp;&amp; rs2_ID == rd_EXE))) <span class=\"hljs-keyword\">begin</span><br><span class=\"hljs-comment\">// need bubble</span><br>    reg_FD_stall = <span class=\"hljs-number\">1&#x27;b1</span>;<br>    reg_DE_flush = <span class=\"hljs-number\">1&#x27;b1</span>;<br>    PC_EN_IF = <span class=\"hljs-number\">1&#x27;b0</span>; <span class=\"hljs-comment\">// 中止取址</span><br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>为了避免load_use的情况下数据冒险部分的前推同时成立的错误, 直接设置<code>forward_ctrl_B = 2&#39;b00;</code>.</p>\n</blockquote>\n<p><strong>e.g.</strong> load-store(只需前推)的情况:</p>\n<p><img src=\"assets/image-20250224085632929.png\" alt=\"image-20250224085632929\" style=\"zoom:40%;\" /></p>\n<p><strong>控制冒险的处理</strong>:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// branch / jump FIXME</span><br><span class=\"hljs-keyword\">if</span>(Branch_ID || hazard_optype_ID == JUMP_OP)<span class=\"hljs-keyword\">begin</span> <br>    reg_FD_flush = <span class=\"hljs-number\">1&#x27;b1</span>;<br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<p><strong>e.g.</strong> <code>JALR</code>的情况</p>\n<p><img src=\"assets/image-20250224090508036.png\" alt=\"image-20250224090508036\" style=\"zoom:40%;\" /> </p>\n<h3 id=\"3-3-仿真及波形解释\"><a href=\"#3-3-仿真及波形解释\" class=\"headerlink\" title=\"3.3 仿真及波形解释\"></a>3.3 仿真及波形解释</h3><p><strong>load-use:</strong><br><img src=\"lab1_report.assets/image-20250224162025072.png\" alt=\"image-20250224162025072\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p><code>add x1, x2,x4</code>的<code>rs2</code>来自上一条指令(load类型)的<code>rd</code>, 因此处于ID阶段的<code>add</code>指令stall, 且暂停IF阶段的PC取址一个时钟周期.</p>\n</blockquote>\n<p><strong>load-store:</strong></p>\n<p><img src=\"lab1_report.assets/image-20250224162724537.png\" alt=\"image-20250224162724537\" style=\"zoom:40%;\" /></p>\n<p><strong>Branch</strong>:</p>\n<p><img src=\"lab1_report.assets/image-20250224163759935.png\" alt=\"image-20250224163759935\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p><code>bge x4,x4,label6</code> 发生跳转, 由于采取的是predict-not-taken的分支预测策略, 因此当这条指令进入ID阶段并经过条件判断, 发现实际需要跳转时, 令IF/ID寄存器的<code>flush</code>信号为<code>1</code>, 也就是清除了此时IF阶段的指令, 并将跳转地址赋值给PC, 相当于stall了一个时钟周期.</p>\n</blockquote>\n<p><strong>JALR</strong>:</p>\n<p><img src=\"lab1_report.assets/image-20250224164548855.png\" alt=\"image-20250224164548855\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p>JALR在进入ID阶段后立即进行地址的计算, 并在下一个时钟周期跳转到正确的地址取址.</p>\n</blockquote>\n<h3 id=\"3-4-下板\"><a href=\"#3-4-下板\" class=\"headerlink\" title=\"3.4 下板\"></a>3.4 下板</h3><p><img src=\"lab1_report.assets/image-20250224170505856.png\" alt=\"image-20250224170505856\" style=\"zoom:20%;\" /></p>\n<p><img src=\"lab1_report.assets/image-20250224170529795.png\" alt=\"image-20250224170529795\" style=\"zoom:20%;\" /></p>\n<p><img src=\"lab1_report.assets/image-20250224170548503.png\" alt=\"image-20250224170548503\" style=\"zoom:20%;\" /></p>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"四、-讨论与心得\"><a href=\"#四、-讨论与心得\" class=\"headerlink\" title=\"四、 讨论与心得\"></a>四、 讨论与心得</h2><p>​    第一次体系结构实验, 收获还是不少的.</p>\n<p>​    首先是团队合作方面. 数逻和计组都是单人实验的我, 在体系结构实验组队, 和队友讨论的收获很多. 我先写完整体代码, 然后一边写对应的文档, 一边仿真检查并画出对应的原理图. 当我画到EXE阶段的PC输入的多选器时, 我有了疑惑——这个CPU设计理念已经将跳转的地址计算和条件比较前推到了ID阶段, 继续将PC地址传递是不是没有必要? 于是我将其标红并继续了实验. 但是和队友交流之后, 我发现PC在之后的阶段还是有作用的——比如JUMP类型的指令需要将<code>pc+4</code>写入目标寄存器, 在WB阶段实现. 因此, 我补充了对应的数据通路并标红:<img src=\"lab1_report.assets/image-20250224165720059.png\" alt=\"image-20250224165720059\" style=\"zoom:40%;\" /></p>\n<p>​    另外, 我画<code>load-store</code>原理图的时候想到, 助教上课提到过: 如果<code>store</code>的<code>rs1</code>来自于<code>load</code>的<code>rd</code>, 那么访存的地址计算要求S指令在EXE阶段的开始就获得对应的值, 因此需要store. 我本想在原来的基础上继续加一层判断, 但是和队友交流之后发现, 实际上这已经囊括在了<code>load-use</code>的范畴里, 不需要额外的修改.</p>\n<p>​    在讨论的最后, 我其实还有一个问题——<code>cmp_32</code>模块似乎没有必要独立作为一个模块? 其实可以直接并入控制单元? 综上来看, 相比于计组实验的从无到有, 结构实验要求我们以<code>top-down</code>的角度理解现有代码的功能和交互, 实际上也是一种挑战.</p>\n","excerpt":"","more":"<center><span style=\"font-size: 1.8em; font-weight: 600\">浙江大学实验报告</span></center>\n\n\n\n\n\n<div style=\"font-size: 1.3em; line-height: 2;\">\n  课程名称: &emsp;<b>&emsp;计算机体系结构&emsp;</b> <span style = \"float:right;\">实验类型: <b>&emsp;综合&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span><br>\n实验项目名称:&emsp; <br>&emsp;<b>Lab1:</b>&emsp;Implement pipelined CPU with forwarding paths and\nprediction-not-taken supporting RISC V 32I instructions.&emsp; <br>\n指导老师: <b> &emsp;何水兵 &emsp;</b><span style=\"float: right;\">完成时间: &emsp;<b>&emsp;2025.2.24&emsp;</b>&emsp;&emsp;&emsp;&emsp;</span>\n</div>\n\n\n\n\n\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>卓俊豪</th>\n<th>学号</th>\n<th>3230103739</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同组学生姓名</td>\n<td>魏云翔</td>\n<td>学号</td>\n<td>3230105111</td>\n</tr>\n<tr>\n<td>分工信息</td>\n<td>代码模块讨论( 该lab的report独立完成 )</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>目录:</strong></p>\n<p>[TOC]</p>\n<div style=\"page-break-after:always;\"></div>\n\n\n<h2 id=\"一、实验目的和要求\"><a href=\"#一、实验目的和要求\" class=\"headerlink\" title=\"一、实验目的和要求\"></a>一、实验目的和要求</h2><h3 id=\"1-1-Purpose\"><a href=\"#1-1-Purpose\" class=\"headerlink\" title=\"1.1 Purpose\"></a>1.1 Purpose</h3><ul>\n<li>Understand  RISC-V RV32I instructions</li>\n<li>Master the design methods of <strong>pipelined</strong> CPU executing RV32I instructions</li>\n<li>Master the method of Pipeline <strong>Forwarding Detection</strong> and <strong>bypass unit</strong> design</li>\n<li>Master the methods of 1-cycle stall of <strong>Predict-not-taken</strong> branch design</li>\n<li>master methods of program <strong>verification</strong> of Pipelined CPU executing RV32I instructions</li>\n</ul>\n<h3 id=\"1-2-Experiment-Task\"><a href=\"#1-2-Experiment-Task\" class=\"headerlink\" title=\"1.2 Experiment Task\"></a>1.2 Experiment Task</h3><ul>\n<li>Deign of Pipelined CPU executing RV32I instructions.<ul>\n<li>Design datapath</li>\n<li>Design Bypass Unit</li>\n<li>Design CPU Controller</li>\n</ul>\n</li>\n<li>Verify the Pipelined CPU with program and observe the execution  of program</li>\n</ul>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"二、-实验内容及原理\"><a href=\"#二、-实验内容及原理\" class=\"headerlink\" title=\"二、 实验内容及原理\"></a>二、 实验内容及原理</h2><p>在流水线CPU中, 存在三种<code>Hazards</code> :</p>\n<ul>\n<li>Structural hazard;</li>\n<li>Data hazard;</li>\n<li>Control hazard.</li>\n</ul>\n<h3 id=\"2-1-结构冒险分析\"><a href=\"#2-1-结构冒险分析\" class=\"headerlink\" title=\"2.1 结构冒险分析\"></a>2.1 结构冒险分析</h3><p>​    对于Structural hazard(结构冒险), 在本试验中表现为”在同一个时钟周期内对寄存器堆进行读和写“. 为了解决这个冒险, 我们只需要将读写分离——在时钟信号的下降沿写入目标寄存器的值, 而在时钟信号的上升沿令其他寄存器读取输入信号.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">always</span> @(<span class=\"hljs-keyword\">negedge</span> clk <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">posedge</span> rst) <br>      <span class=\"hljs-keyword\">begin</span><br>\t\t...<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">begin</span><br>\t\t     <span class=\"hljs-keyword\">if</span> ((Wt_addr != <span class=\"hljs-number\">0</span>) &amp;&amp; (L_S == <span class=\"hljs-number\">1</span>)) \t<span class=\"hljs-comment\">// write</span><br>\t\t     register[Wt_addr] &lt;= Wt_data;<br>\t\t<span class=\"hljs-keyword\">end</span><br>\t<span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<p>​    因此, 结构冒险不是我们解决的重点, 本试验需要着重考虑的是另外两种冒险.</p>\n<h3 id=\"2-2-数据冒险分析\"><a href=\"#2-2-数据冒险分析\" class=\"headerlink\" title=\"2.2 数据冒险分析\"></a>2.2 数据冒险分析</h3><p>Data hazard(数据冒险)指的是指令之间存在数据依赖关系, 导致数据读取错误的情况. 有以下几种方式和情形:</p>\n<ol>\n<li><strong>Stall</strong></li>\n</ol>\n<table style=\"border:none\">\n    <tr>\n        <td style = \"width:50%\"><img src=\"assets/image-20250223113231052.png\" alt=\"image-20250223113231052\" style=\"zoom:50%;\" /></td>\n        <td style=\"vertical-align:center; width:50%\">\n          <ul>\n            <li> 由于涉及ALU操作的R/I类型指令需要在WB阶段才将计算结果写入目标寄存器, 此时ID阶段的寄存器堆才能正常更新和输出.                        </li>\n            <li> 因此如果两条存在数据依赖的上述指令前后相邻时, 只需要在第一条指令后插入两个bubble, 就可以避免数据冒险.</li>\n          </ul>\n        </td>\n    </tr>\n</table>\n\n<ol>\n<li><strong>Forward</strong></li>\n</ol>\n<table>\n    <tr>\n        <td style=\"width:50%; text-align:center\">\n          <ul>\n            <li>对于上述Stall碰到的情况, 由于前一条指令的目标寄存器的值实际上在EX阶段已经计算得到, 因此只需要将此时的计算结果前递(forwarding)到ID阶段, 作为对应的源寄存器的值即可.\n            </li>\n          </ul>\n        </td>\n        <td style=\"width:50%\"><img src=\"assets/image-20250223114642120.png\" style=\"zoom:50%;\" /></td>\n    </tr>\n</table>\n\n<p>对于load-store的情况需要继续分类讨论:</p>\n<ul>\n<li><p>若store的<code>rs2</code>来自于load的目标寄存器<code>rd</code>: 在load的MEM阶段将<code>rd</code><strong>forwarding</strong>, 将其与“正常”的<code>rs2</code>组成EX阶段的2T1多选器的输入信号, 并且让冒险检测单元产生的<code>forward_ctrl_ls</code>信号作为其选择信号.<img src=\"assets/image-20250223144526402.png\" alt=\"image-20250223144526402\" style=\"zoom:40%;\" /></p>\n</li>\n<li><p>若store的<code>rs1</code>即写入内存的地址需要load的<code>rd</code>参与计算得到, 则在不额外增加<code>unit</code>的情况下, 需要<strong>stall</strong>1个时钟周期, 从而让store指令在其EX阶段计算得到正确的地址. ( 相当于load-use).</p>\n</li>\n</ul>\n<p>通过forwarding还无法避免stall的另一种情况是: <strong>load-use</strong>. 如下图所示, 如果LW的目标寄存器和ADD的rs1相同, 那么LW在其MEM阶段进行访存, 无法为EXE阶段的ADD提供操作数. 必须插入一个bubble才能避免这种数据冒险.</p>\n<p><img src=\"assets/image-20250223145841793.png\" alt=\"image-20250223145841793\" style=\"zoom:40%;\" /></p>\n<h3 id=\"2-3-控制冒险分析\"><a href=\"#2-3-控制冒险分析\" class=\"headerlink\" title=\"2.3 控制冒险分析\"></a>2.3 控制冒险分析</h3><p>对于Control hazard(控制冒险), 我们可以采取的策略有简单的stall——让分支指令运行完其EXE阶段,然后根据是否跳转来选择IF的PC来源. 除此之外, 我们存在<code>predict</code>的方法, 也就是预测分支语句是否执行跳转. </p>\n<p>我们采取<strong>Predict-not-taken</strong>的分支预测策略, 同时将地址计算和条件比较的过程前推到了ID阶段, 使得:</p>\n<ul>\n<li>如果预测正确, 不会产生stall;</li>\n<li>如果预测错误, 需要跳转, 则将此时ID阶段计算得到的地址作为下一条IF取址的地址, 并且令冒险检测单元输出IF/ID寄存器的<code>flush</code>信号, 避免当前IF区域错误指令的干扰, 因此整体上看, 流水线stall了1个时钟周期.</li>\n</ul>\n<blockquote>\n<p>如果采取<strong>Predict—taken</strong>的策略, 即使我们将地址计算和条件比较都前推到ID阶段, 无论预测是否正确, 都需要stall一个时钟周期.</p>\n</blockquote>\n<p>​    具体实现的部分<strong>代码</strong>将在<strong>第三部分</strong>结合原理图给出.</p>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"三、-实验过程和数据记录及结果分析\"><a href=\"#三、-实验过程和数据记录及结果分析\" class=\"headerlink\" title=\"三、 实验过程和数据记录及结果分析\"></a>三、 实验过程和数据记录及结果分析</h2><h3 id=\"3-1-原理图\"><a href=\"#3-1-原理图\" class=\"headerlink\" title=\"3.1 原理图\"></a>3.1 原理图</h3><p><img src=\"assets/image-20250223204007274.png\" alt=\"image-20250223204007274\" style=\"zoom:100%;\" /></p>\n<blockquote>\n<p>更加完善的版本请见最后部分.</p>\n</blockquote>\n<h3 id=\"3-2-模块实现\"><a href=\"#3-2-模块实现\" class=\"headerlink\" title=\"3.2 模块实现\"></a>3.2 模块实现</h3><h4 id=\"1-cmp-32\"><a href=\"#1-cmp-32\" class=\"headerlink\" title=\"(1) cmp_32\"></a>(1) cmp_32</h4><p>比较模块的主要功能就是判断分支跳转的条件是否成立, 也就是和控制单元模块结合, 将条件判断的阶段<strong>前推</strong>到ID阶段.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">assign</span> c = &#123;EQ &amp; res_EQ&#125; | <br>        &#123;NE &amp; res_NE&#125; |<br>        &#123;LT &amp; res_LT&#125; |<br>        &#123;LTU &amp; res_LTU&#125; |<br>        &#123;GE &amp; res_GE&#125; |<br>        &#123;GEU &amp; res_GEU&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>EQ</code>等由<code>ctrl</code>决定, 即指令代表的判断条件类型, <code>res_xx</code>表示根据对应的判断类型, 输入的<code>rs1</code>与<code>rs2</code>的比较结果;</li>\n<li>任何情况下, <code>ctrl</code>决定了这六个析取操作(<code>|</code>)只能有一个可能为真, 类似于多选器的选择信号;</li>\n<li>根据计算结果, 输出<code>c</code>表示分支跳转的判断条件是否成立, 并输入到控制单元.</li>\n</ul>\n<h4 id=\"2-CtrlUnit\"><a href=\"#2-CtrlUnit\" class=\"headerlink\" title=\"(2) CtrlUnit\"></a>(2) CtrlUnit</h4><p>控制单元以指令<code>inst</code>和上述比较模块的输出<code>cmp_res</code>作为输入, 在ID阶段译码得到<code>DatatoReg</code>等指令. </p>\n<p>与普通的流水线相比, 这个控制单元还另外译码B类型的指令, 得到不同条件的分支指令如<code>bge</code>, <code>bltu</code>等, 将其作为输出连接到比较单元.</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-keyword\">assign</span> hazard_optype = &#123;<span class=\"hljs-number\">2</span>&#123;R_valid | I_valid&#125;&#125; &amp; <span class=\"hljs-number\">2&#x27;b00</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;L_valid&#125;&#125; &amp; <span class=\"hljs-number\">2&#x27;b01</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;S_valid&#125;&#125;           &amp; <span class=\"hljs-number\">2&#x27;b10</span> |<br>                    &#123;<span class=\"hljs-number\">2</span>&#123;B_valid | JAL | JALR&#125;&#125;    &amp; <span class=\"hljs-number\">2&#x27;b11</span><br>;       <br></code></pre></td></tr></table></figure>\n<h4 id=\"3-HazardDetectionUnit\"><a href=\"#3-HazardDetectionUnit\" class=\"headerlink\" title=\"(3) HazardDetectionUnit\"></a>(3) HazardDetectionUnit</h4><p><strong>数据冒险</strong>的处理:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// MEM阶段的前推</span><br><span class=\"hljs-keyword\">if</span>(rd_MEM != <span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>( rs1_ID == rd_MEM &amp;&amp; rs1use_ID )<br>        forward_ctrl_A = <span class=\"hljs-number\">2&#x27;b10</span>;<br>    <span class=\"hljs-keyword\">if</span>( rs2_ID == rd_MEM &amp;&amp; rs2use_ID )<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b10</span>;<br><span class=\"hljs-keyword\">end</span><br><br><span class=\"hljs-comment\">// EXE阶段的前推</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> ) <span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>( rs1_ID == rd_EXE &amp;&amp; rs1use_ID)<br>        forward_ctrl_A = <span class=\"hljs-number\">2&#x27;b01</span>; <br>    <span class=\"hljs-keyword\">if</span>( rs2_ID == rd_EXE &amp;&amp; rs2use_ID)<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b01</span>; <br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>将EXE阶段的判断置于下方, 使得情况同时存在时确保从<strong>EXE</strong>阶段前推.</p>\n</blockquote>\n<p><strong>e.g.</strong> 从EXE阶段到ID的rs1的前推:</p>\n<p><img src=\"assets/image-20250224084543612.png\" alt=\"image-20250224084543612\" style=\"zoom:40%;\" /></p>\n<p><strong>load</strong>类型的处理:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// load-store situation:</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> &amp;&amp; (hazard_optype_EXE == load_OP) &amp;&amp; (hazard_optype_ID == store_OP)) <span class=\"hljs-keyword\">begin</span> <br>    <span class=\"hljs-keyword\">if</span>(rs2_ID == rd_EXE)<br>        forward_ctrl_ls = <span class=\"hljs-number\">1&#x27;b1</span>;<br>        forward_ctrl_B = <span class=\"hljs-number\">2&#x27;b00</span>;<br><span class=\"hljs-keyword\">end</span><br><br><span class=\"hljs-comment\">// load-use situation:</span><br><span class=\"hljs-keyword\">if</span>(rd_EXE != <span class=\"hljs-number\">0</span> &amp;&amp; hazard_optype_EXE == load_OP &amp;&amp;<br>\t((rs1use_ID &amp;&amp; rs1_ID == rd_EXE) || (rs2use_ID &amp;&amp; rs2_ID == rd_EXE))) <span class=\"hljs-keyword\">begin</span><br><span class=\"hljs-comment\">// need bubble</span><br>    reg_FD_stall = <span class=\"hljs-number\">1&#x27;b1</span>;<br>    reg_DE_flush = <span class=\"hljs-number\">1&#x27;b1</span>;<br>    PC_EN_IF = <span class=\"hljs-number\">1&#x27;b0</span>; <span class=\"hljs-comment\">// 中止取址</span><br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>为了避免load_use的情况下数据冒险部分的前推同时成立的错误, 直接设置<code>forward_ctrl_B = 2&#39;b00;</code>.</p>\n</blockquote>\n<p><strong>e.g.</strong> load-store(只需前推)的情况:</p>\n<p><img src=\"assets/image-20250224085632929.png\" alt=\"image-20250224085632929\" style=\"zoom:40%;\" /></p>\n<p><strong>控制冒险的处理</strong>:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs verilog\"><span class=\"hljs-comment\">// branch / jump FIXME</span><br><span class=\"hljs-keyword\">if</span>(Branch_ID || hazard_optype_ID == JUMP_OP)<span class=\"hljs-keyword\">begin</span> <br>    reg_FD_flush = <span class=\"hljs-number\">1&#x27;b1</span>;<br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<p><strong>e.g.</strong> <code>JALR</code>的情况</p>\n<p><img src=\"assets/image-20250224090508036.png\" alt=\"image-20250224090508036\" style=\"zoom:40%;\" /> </p>\n<h3 id=\"3-3-仿真及波形解释\"><a href=\"#3-3-仿真及波形解释\" class=\"headerlink\" title=\"3.3 仿真及波形解释\"></a>3.3 仿真及波形解释</h3><p><strong>load-use:</strong><br><img src=\"lab1_report.assets/image-20250224162025072.png\" alt=\"image-20250224162025072\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p><code>add x1, x2,x4</code>的<code>rs2</code>来自上一条指令(load类型)的<code>rd</code>, 因此处于ID阶段的<code>add</code>指令stall, 且暂停IF阶段的PC取址一个时钟周期.</p>\n</blockquote>\n<p><strong>load-store:</strong></p>\n<p><img src=\"lab1_report.assets/image-20250224162724537.png\" alt=\"image-20250224162724537\" style=\"zoom:40%;\" /></p>\n<p><strong>Branch</strong>:</p>\n<p><img src=\"lab1_report.assets/image-20250224163759935.png\" alt=\"image-20250224163759935\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p><code>bge x4,x4,label6</code> 发生跳转, 由于采取的是predict-not-taken的分支预测策略, 因此当这条指令进入ID阶段并经过条件判断, 发现实际需要跳转时, 令IF/ID寄存器的<code>flush</code>信号为<code>1</code>, 也就是清除了此时IF阶段的指令, 并将跳转地址赋值给PC, 相当于stall了一个时钟周期.</p>\n</blockquote>\n<p><strong>JALR</strong>:</p>\n<p><img src=\"lab1_report.assets/image-20250224164548855.png\" alt=\"image-20250224164548855\" style=\"zoom:40%;\" /></p>\n<blockquote>\n<p>JALR在进入ID阶段后立即进行地址的计算, 并在下一个时钟周期跳转到正确的地址取址.</p>\n</blockquote>\n<h3 id=\"3-4-下板\"><a href=\"#3-4-下板\" class=\"headerlink\" title=\"3.4 下板\"></a>3.4 下板</h3><p><img src=\"lab1_report.assets/image-20250224170505856.png\" alt=\"image-20250224170505856\" style=\"zoom:20%;\" /></p>\n<p><img src=\"lab1_report.assets/image-20250224170529795.png\" alt=\"image-20250224170529795\" style=\"zoom:20%;\" /></p>\n<p><img src=\"lab1_report.assets/image-20250224170548503.png\" alt=\"image-20250224170548503\" style=\"zoom:20%;\" /></p>\n<div style=\"page-break-after:always;\"></div>\n\n<h2 id=\"四、-讨论与心得\"><a href=\"#四、-讨论与心得\" class=\"headerlink\" title=\"四、 讨论与心得\"></a>四、 讨论与心得</h2><p>​    第一次体系结构实验, 收获还是不少的.</p>\n<p>​    首先是团队合作方面. 数逻和计组都是单人实验的我, 在体系结构实验组队, 和队友讨论的收获很多. 我先写完整体代码, 然后一边写对应的文档, 一边仿真检查并画出对应的原理图. 当我画到EXE阶段的PC输入的多选器时, 我有了疑惑——这个CPU设计理念已经将跳转的地址计算和条件比较前推到了ID阶段, 继续将PC地址传递是不是没有必要? 于是我将其标红并继续了实验. 但是和队友交流之后, 我发现PC在之后的阶段还是有作用的——比如JUMP类型的指令需要将<code>pc+4</code>写入目标寄存器, 在WB阶段实现. 因此, 我补充了对应的数据通路并标红:<img src=\"lab1_report.assets/image-20250224165720059.png\" alt=\"image-20250224165720059\" style=\"zoom:40%;\" /></p>\n<p>​    另外, 我画<code>load-store</code>原理图的时候想到, 助教上课提到过: 如果<code>store</code>的<code>rs1</code>来自于<code>load</code>的<code>rd</code>, 那么访存的地址计算要求S指令在EXE阶段的开始就获得对应的值, 因此需要store. 我本想在原来的基础上继续加一层判断, 但是和队友交流之后发现, 实际上这已经囊括在了<code>load-use</code>的范畴里, 不需要额外的修改.</p>\n<p>​    在讨论的最后, 我其实还有一个问题——<code>cmp_32</code>模块似乎没有必要独立作为一个模块? 其实可以直接并入控制单元? 综上来看, 相比于计组实验的从无到有, 结构实验要求我们以<code>top-down</code>的角度理解现有代码的功能和交互, 实际上也是一种挑战.</p>\n"},{"_content":"`ctrl+g`然后输入地址, 快速定位到目标地址以查看信息;\n\n`F7`, 在选中`call`指令后跳转到目标地址的指令;\n\n\n\n- 源代码中函数最右侧的参数是首先`push`压入, 最左侧的参数是最后压入的.\n- `test`进行与运算\n- 汇编语言本身不存在库函数, 但是可以调用操作系统的函数\n\n\n\n```sql\ninvoke wsprintf, offset result, offset format, eax\ninvoke MessageBox, 0, offset result, offset prompt, 0\n\n```\n\n1. result 正文; prompt 标题\n\n\n\n以`h`结尾表示16进制, 如果是字母开头, 还需要前增`0`.\n\n\n\n`ds`无法直接被常值赋值.\n\n \n\n`db` := define byte\n\n\\r -- 0Dh 表示回车; \\n -- 0Ah 表示换行.\n\ns db \"...\", 0Dh, 0Ah, '$' \n\n汇编中的字符串末尾不存在`\\0`.\n\n- 使用masm编译和链接asm(汇编)文件\n\n```shell\nd:\ncd masm\n\nmasm xx.asm;\nlink xx.obj;\n\nxx\n```\n\n>  执行`masm`时可省略`.asm`, `link`同理.\n\n`td hello.exe` 表示用Turbo debugger调试16位的程序.\n\n> OD用于32位.\n\n\n\n`ds:dx` 将段地址和偏移量组合构成完整的指针.\n\n\n\n","source":"_drafts/temp_notes/汇编基础.md","raw":"`ctrl+g`然后输入地址, 快速定位到目标地址以查看信息;\n\n`F7`, 在选中`call`指令后跳转到目标地址的指令;\n\n\n\n- 源代码中函数最右侧的参数是首先`push`压入, 最左侧的参数是最后压入的.\n- `test`进行与运算\n- 汇编语言本身不存在库函数, 但是可以调用操作系统的函数\n\n\n\n```sql\ninvoke wsprintf, offset result, offset format, eax\ninvoke MessageBox, 0, offset result, offset prompt, 0\n\n```\n\n1. result 正文; prompt 标题\n\n\n\n以`h`结尾表示16进制, 如果是字母开头, 还需要前增`0`.\n\n\n\n`ds`无法直接被常值赋值.\n\n \n\n`db` := define byte\n\n\\r -- 0Dh 表示回车; \\n -- 0Ah 表示换行.\n\ns db \"...\", 0Dh, 0Ah, '$' \n\n汇编中的字符串末尾不存在`\\0`.\n\n- 使用masm编译和链接asm(汇编)文件\n\n```shell\nd:\ncd masm\n\nmasm xx.asm;\nlink xx.obj;\n\nxx\n```\n\n>  执行`masm`时可省略`.asm`, `link`同理.\n\n`td hello.exe` 表示用Turbo debugger调试16位的程序.\n\n> OD用于32位.\n\n\n\n`ds:dx` 将段地址和偏移量组合构成完整的指针.\n\n\n\n","slug":"temp_notes/汇编基础","published":0,"date":"2025-02-25T06:25:47.124Z","updated":"2025-02-25T15:30:06.822Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm7kndg8q0007dmqg8fbe9bjr","content":"<p><code>ctrl+g</code>然后输入地址, 快速定位到目标地址以查看信息;</p>\n<p><code>F7</code>, 在选中<code>call</code>指令后跳转到目标地址的指令;</p>\n<ul>\n<li>源代码中函数最右侧的参数是首先<code>push</code>压入, 最左侧的参数是最后压入的.</li>\n<li><code>test</code>进行与运算</li>\n<li>汇编语言本身不存在库函数, 但是可以调用操作系统的函数</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">invoke wsprintf, <span class=\"hljs-keyword\">offset</span> <span class=\"hljs-keyword\">result</span>, <span class=\"hljs-keyword\">offset</span> format, eax<br>invoke MessageBox, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">offset</span> <span class=\"hljs-keyword\">result</span>, <span class=\"hljs-keyword\">offset</span> prompt, <span class=\"hljs-number\">0</span><br><br></code></pre></td></tr></table></figure>\n<ol>\n<li>result 正文; prompt 标题</li>\n</ol>\n<p>以<code>h</code>结尾表示16进制, 如果是字母开头, 还需要前增<code>0</code>.</p>\n<p><code>ds</code>无法直接被常值赋值.</p>\n<p><code>db</code> := define byte</p>\n<p>\\r — 0Dh 表示回车; \\n — 0Ah 表示换行.</p>\n<p>s db “…”, 0Dh, 0Ah, ‘$’ </p>\n<p>汇编中的字符串末尾不存在<code>\\0</code>.</p>\n<ul>\n<li>使用masm编译和链接asm(汇编)文件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">d:<br>cd masm<br><br>masm xx.asm;<br>link xx.obj;<br><br>xx<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> 执行<code>masm</code>时可省略<code>.asm</code>, <code>link</code>同理.</p>\n</blockquote>\n<p><code>td hello.exe</code> 表示用Turbo debugger调试16位的程序.</p>\n<blockquote>\n<p>OD用于32位.</p>\n</blockquote>\n<p><code>ds:dx</code> 将段地址和偏移量组合构成完整的指针.</p>\n","excerpt":"","more":"<p><code>ctrl+g</code>然后输入地址, 快速定位到目标地址以查看信息;</p>\n<p><code>F7</code>, 在选中<code>call</code>指令后跳转到目标地址的指令;</p>\n<ul>\n<li>源代码中函数最右侧的参数是首先<code>push</code>压入, 最左侧的参数是最后压入的.</li>\n<li><code>test</code>进行与运算</li>\n<li>汇编语言本身不存在库函数, 但是可以调用操作系统的函数</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">invoke wsprintf, <span class=\"hljs-keyword\">offset</span> <span class=\"hljs-keyword\">result</span>, <span class=\"hljs-keyword\">offset</span> format, eax<br>invoke MessageBox, <span class=\"hljs-number\">0</span>, <span class=\"hljs-keyword\">offset</span> <span class=\"hljs-keyword\">result</span>, <span class=\"hljs-keyword\">offset</span> prompt, <span class=\"hljs-number\">0</span><br><br></code></pre></td></tr></table></figure>\n<ol>\n<li>result 正文; prompt 标题</li>\n</ol>\n<p>以<code>h</code>结尾表示16进制, 如果是字母开头, 还需要前增<code>0</code>.</p>\n<p><code>ds</code>无法直接被常值赋值.</p>\n<p><code>db</code> := define byte</p>\n<p>\\r — 0Dh 表示回车; \\n — 0Ah 表示换行.</p>\n<p>s db “…”, 0Dh, 0Ah, ‘$’ </p>\n<p>汇编中的字符串末尾不存在<code>\\0</code>.</p>\n<ul>\n<li>使用masm编译和链接asm(汇编)文件</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">d:<br>cd masm<br><br>masm xx.asm;<br>link xx.obj;<br><br>xx<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> 执行<code>masm</code>时可省略<code>.asm</code>, <code>link</code>同理.</p>\n</blockquote>\n<p><code>td hello.exe</code> 表示用Turbo debugger调试16位的程序.</p>\n<blockquote>\n<p>OD用于32位.</p>\n</blockquote>\n<p><code>ds:dx</code> 将段地址和偏移量组合构成完整的指针.</p>\n"},{"title":"DataBase","date":"2025-02-20T03:09:12.000Z","excerpt":"DB","math":true,"index_assets":"/assets/db_index.png","_content":"# Intro\n\n<img src=\"数据库系统.assets/image-20250225103821388.png\" alt=\"image-20250225103821388\" style=\"zoom:50%;\" />\n\n概念:\n- **DBMS**: database-management system, \n- **Different levels** \n  - Physical:  数据如何存储;\n  - Logical: data如何在数据库中组织(内部关系)\n    ```pascal\n    type instructor = record\n        ID: string;        // ID字段，字符串类型\n        name: string;      // 姓名字段，字符串类型\n        dept_name: string; // 部门名称字段，字符串类型\n        salary: integer;   // 薪资字段，整数类型\n    end;\n    ```\n  - View: 可以根据用户需求定义可见的数据结构;\n\n**Data Models**\n\n- Relational model: 关系型数据库;\n- Entity-Relationship data model(E-R) : 实体-关系型数据库;\n  - 实体是现实世界中可区分的对象, 属性是实体的特征描述;\n- Object-based data models : 对象型数据库;\n- Semistructured data model(**XML** 和 **JSON**) : 半结构化数据库;\n  - 灵活性体现在: 嵌套结构, 可选字段, 混合类型等.\n\n**Instances and Schemas**\n\n- 模式 **Schema** : 数据的组织方式\n  - 逻辑模式 Logical Schema: 对数据库结构的描述;\n    ```sql\n    CREATE TABLE Customer (\n        customer_id INT PRIMARY KEY,\n        name VARCHAR(100),\n        email VARCHAR(100),\n        registration_date DATE\n    );\n    ```\n  - 物理模式 Physical Schema: 描述数据实际存储的方式;\n    - 比如使用的索引结构(B+树, 哈希表等), 缓冲区的管理策略等.\n- 实例 **Instance**: 实际存储的数据\n    ```sql\n    INSERT INTO Customer VALUES\n    (1, '张三', 'zhang@email.com', '2024-01-15'),\n    (2, '李四', 'li@email.com', '2024-02-01');\n    ```\n- 物理数据独立性 **Physical Data Independence** \n  - 指的是允许用户在不影响数据库逻辑结构的情况下, 改变物理存储方式.\n  - 比如数据存储的位置, 索引结构等的改变.\n\n---\n\nData Definition Language (**DDL**) \n- 作用: 定义数据库的结构, 包括表, 索引, 视图等;\n- e.g:\n  - 基本表的结构定义:\n    ```sql\n    CREATE TABLE instructor (\n        ID char(5),           -- 固定长度5个字符\n        name varchar(20),     -- 可变长度，最多20个字符\n        dept_name varchar(20),\n        salary numeric(8,2)   -- 总长8位，小数点后2位\n    );\n    ```\n  - 完整性约束:\n    ```sql\n    CREATE TABLE instructor (\n            ID char(5) PRIMARY KEY,  -- 主键约束\n            name varchar(20) NOT NULL,  -- 非空约束\n            dept_name varchar(20) REFERENCES department(dept_name),  -- 外键约束\n            salary numeric(8,2) CHECK (salary > 0)  -- 值约束\n        );\n    ```\n\n使用DDL创建数据库对象时, 上述的定义将会被存储在称为数据字典(**Data dictionary**)的结构当中, 包括以下元数据:\n- 模式信息\n- 完整性约束\n  - 主键, 引用完整性, 值约束\n- 授权信息\n    ```sql\n    -- 授权示例\n    GRANT SELECT, INSERT ON instructor TO user1;\n    GRANT UPDATE (salary) ON instructor TO payroll_admin;\n    ```\n\n---\n\nData Manipulation Language (**DML**)\n- 指的是用于处理和操纵对应模型的数据的语言;\n- 根据是否需要用户声明 `how to get those data`分为 **two classes**:\n  - **Procedural** : 需要声明;\n  - **Declarative**: 无需声明\n    - SQL 就是其中被广泛应用的类型之一.\n\n# Relational Model\n\n基本概念:\n\n- 属性(attribute) 也就是列;\n- 元组(tuple) 也就是行;\n- $R = (A_1,A_2,\\dots,A_n)$ 为关系的范式;\n- `NULL`表示未知, 而非不存在. 是所有类型属性的值域的一员.\n\n##  keys\n**superkey**: \n- 定义: values for K are sufficient to identify a unique tuple of each possible relation r(R) $\\Longrightarrow$ K is a  ~(超键) of R.\n- 超键在推断的时候, 可能存在冗余的属性.\n\n**candidate key**(候选键): 超键K is **minimal** $\\Rightarrow$ K is ~\n\n**primary key**(主键): 我们从候选键中选择一个key作为主键.\n\n**foreign key**(外键): \n\n-  R1 的一个或一组列的值(的范围)与 R2 的主键值(的范围)相匹配 \n  $\\Rightarrow$ R1 的这个或这组列，称为指向 R2 的外键。\n\n**Referential Integrity Constraint**: \n\n- 即 参照完整性约束;\n- 指 引用关系表R1以被引用关系表R2, R1的外键的值必须在R2中存在.\n- *e.g*  存在订单表和客户表, 订单表中的“客户ID”列是外键，它引用客户表中的“客户ID”列(主键), 要求订单表中的“客户ID”值必须在客户表中存在.\n\n---\n\n## Relational algebra\n关系代数(relational algebra), 元组关系演算(tuple relational calculus), 域关系演算(domain relational calculus) 相互等价. 我们将重点关注**关系代数**.\n### Basic Op.\n关系代数包含以下六种基本操作:\n- ***select*** $\\sigma$: 选取满足条件的元组;\n  - $\\sigma _{\\rho}(r)$, 其中$\\rho$由一系列的`term`在 $\\wedge$,$\\vee$,$\\neg$的符号连接下组成.\n  - `term`由列与列(或常值)的比较运算得到;\n  - e.g: $$\\sigma _{salary\\ >\\ 30000}(instructor)$$\n- ***project*** $\\pi$ : 投影以选取指定的属性;\n  - $\\pi_{A,B}(R)$: 只保留R中的A,B列;\n- ***union*** $\\cup$: 将不同的关系相结合\n  - **要求**: 不同关系的属性数量和对应的类型保持一致;\n  - **结果**: 自动**去除重复**的元组.\n- ***rename*** $\\rho$: 用于重命名属性或者表名;\n  - $\\rho_{(A_1, \\dots, A_n)}(R)$: 将R中的属性重命名为$A_1,\\dots,A_n$;\n  - $\\rho_{R_1}(R_2)$: 将R_2的表名重命名为R_1;\n  - $\\rho_{S(B1,B2,...,Bn)}(R)$  -- 将关系R重命名为S，并重命名其属性\n- ***set difference*** $-$: 在一个关系中删除另一个关系中存在的元组;\n  - **要求**: 关系相容, 即具有相同的属性个数和类型\n  - 如果两个关系有相同的属性, 则将其重命名为不同的名称;\n- ***cartesian product*** $\\times$: 笛卡尔积, 将不同表格中的数据进行组合匹配\n  - **结果**: 属性数量是二者之和, 元组数量是二者之积\n  - 可以事先对参与计算的表进行$\\sigma$ 等计算, 减小计算成本.\n\n**e.g**\n- Find all courses taught in the Fall 2009 semester,but\n**not in** the Spring 2010 semester:\n$$\n\\pi_{course\\_id}(\\sigma_{semester=\"Fall\"\\  \\wedge \\ year = 2009}(section)) - \\\\\n\\pi_{course\\_id}(\\sigma_{semester=\"spring\"\\  \\wedge \\ year = 2010}(section))\n$$\n\n- Find the largest salary in the university\n  - **Step1**: 将员工表重命名为`d`然后与自身`i`进行笛卡尔积, 得到的元组, 筛选出`i`的工资较少的元组集合, 利用 $\\pi$ 投影获得工资部分\n  ![](assets/2025-02-22-17-27-31.png)\n> 去除了工资本身最大的元组\n  - **Step2**: 对原表投影得到工资部分, 然后对第一步得到的集合取差\n![](assets/2025-02-22-17-31-07.png)\n  - **可视化:**\n![](assets/2025-02-22-17-32-24.png)\n\n\n\n### Additional Op.\n关系代数包含以下扩展操作：\n\n- ***set intersection*** $\\cap$：获取两个关系的公共元组\n\n  - **要求**：关系相容，具有相同的属性结构\n  - **结果**：包含同时出现在两个关系中的元组\n  - e.g: $r \\cap s$ 表示同时存在于r和s中的元组\n\n  $$\n  r \\cap s = r -(r-s) \n  $$\n\n  \n\n- ***natural join*** $\\bowtie$：基于**共同属性**的自动连接\n\n  - 识别并匹配具有相同名称的属性, 结果中只选取相同名称属性**对应值相等**的部分;\n  - 其他连接的“满足连接条件”指的就是自然连接$\\bowtie $ \n\n  e.g. \n\n  <img src=\"数据库系统.assets/image-20250224214646008.png\" alt=\"image-20250224214646008\" style=\"zoom:50%;\" />\n\n  - **theta join**:  $r \\bowtie_\\theta s := \\sigma_\\theta (r \\times s)$ , 先对作笛卡尔积, 然后取用满足条件$\\theta$的部分.\t\n\n- ***semijoin*** $\\ltimes$：半连接操作\n\n  - 结果仅保留**左表中**满足连接条件的元组\n  - 属性仅包含左表的所有属性\n  - e.g: $student \\ltimes takes$ 返回选过课的**学生信息**\n  - $ r \\ltimes_\\theta s := \\pi_R(r\\bowtie_\\theta s)$\n\n- ***assignment*** $\\leftarrow$：将查询结果赋值给临时关系\n\n  - 用于简化复杂查询\n  - 可以重复使用中间结果\n  - e.g: $temp \\leftarrow \\pi_{ID,name}(instructor)$\n\n- ***outer join***：**保留未匹配**元组的连接操作, 避免信息缺失(均在$\\bowtie$的基础上, 即笛卡尔积的结果)\n\n  - 左外连接 $\\leftarrow\\bowtie$：保留左表未匹配的元组\n  - 右外连接 $\\bowtie\\rightarrow$：保留右表未匹配的元组\n  - 全外连接 $\\leftarrow\\bowtie\\rightarrow$：保留两表中未匹配的元组\n  - 未匹配的属性值**填充NULL**\n  - e.g. <img src=\"数据库系统.assets/image-20250224220313846.png\" alt=\"image-20250224220313846\" style=\"zoom:50%;\" />\n\n- ***division*** $\\div$： $ r \\div s$ \n\n  - 用于查找满足所有条件的元组\n  - 更具体地说, 寻找r中的tuple使得与s关系的所有元组的笛卡尔积都在r中;\n  - **要求**: $s \\sub r$ \n\n  > [!note]\n  >\n  > <img src=\"数据库系统.assets/image-20250225121938529.png\" alt=\"image-20250224223816689\" style=\"zoom:50%; float: left;\" />\n\n  **e.g.** \n\n <img src=\"数据库系统.assets/image-20250224221730846.png\" alt=\"image-20250224221730846\" style=\"zoom:50%;\" />\n\n### Aggregate\n\n**聚合函数**: avg, min, max, sum ,count.\n\n- 除了`count`, 其他函数对于**属性的类型**有要求(可以计算).\n\n**聚合操作**: $_{G_1,G_2\\dots}\\mathcal{G}_{F_i(A_i)}(E)$ \n\n- $G_i$是待聚合的属性, 可以为空;\n- $F_i$是聚合函数, $A_i$是属性名.\n\ne.g.:\n\n<img src=\"数据库系统.assets/image-20250224224824019.png\" alt=\"image-20250224224824019\" style=\"zoom:50%;\" />\n\n由于聚合操作得到的列没有自己的名字, 为了方便起见, SQL允许我们直接使用关键字`as`来快速`rename`. 比如对于上述在表`instructor`上的聚合操作, 将结果命名为`avg_sal`的指令:\n$$\n_{dept\\_name}\\ \\mathcal{G}_{avg(salary)\\ as \\ avg\\_sal}(instructor)\n$$\n\n### Multiset\n\npure relational algebra 中不存在重复的元组.\n\n但是在多重集(multiset)当中允许元组重复. \n\n- 多重集的关系代数:\n  - 选择: 即使给出一个元组, 也选中所有符合条件的元组;\n  - 投影: 同理;\n  - **cross product:** 也会将重复的元组多次计算.\n    - m copies of t1 in r, and n copies of t2 in s , then $ m \\times n$ copies of t1.t2 in $r \\times s$ .\n\n- 其他操作:\n  - **union**: m + n copies;\n  - **intersection**: min(m, n) copies;\n  - **difference**: min(0, m-n) copies.\n\n\n\n---\n\n# SQL\n\n###  Domain Types\n\n\n- Char(n): 定长字符串，用户指定长度为 n。\n- Varchar(n): 变长字符串，用户指定最大长度为 n。\n- Int: 整数 (机器相关的整数的有限子集)。\n- Smallint: 小整数 (机器相关的整数域子集)。\n- Numeric(p,d): 定点数，用户指定精度，总共 p 位数字，其中小数点后 d 位。 例如：number(3,1) 允许精确存储 44.5，但不允许 444.5 或 0.32。\n- Real, Double precision: 浮点数和双精度浮点数，精度与机器相关。\n- Float(n): 浮点数，用户指定至少 n 位数字的精度。\n\n\n\n关于时间的类型:\n\n- Date: 日期，包含（4 位数）年份、月份和日期。例如：date '2005-7-27'\n- Time: 一天中的时间，以小时、分钟和秒为单位。例如：time '09:00:30'  time '09:00:30.75'\n- Timestamp: 日期加上一天中的时间。例如：timestamp '2005-7-27 09:00:30.75'\n- Interval: 一段时间。例如：interval '1' day。从另一个日期/时间/时间戳值中减去一个日期/时间/时间戳值会得到一个 interval 值。Interval 值可以添加到日期/时间/时间戳值。\n- Date, time 函数:\n  - current_date()\n  - current_time()\n  - year(x), month(x), day(x), hour(x), minute(x), second(x)\n\n## Common Operations\n\n### 1. 创建表 (CREATE TABLE)\n\n**语法:**\n\n```sql\nCREATE TABLE table_name (\n    column1 datatype constraint,\n    column2 datatype constraint,\n    column3 datatype,\n    ....\n);\n```\n\n**e.g.:**\n\n```sql\nCREATE TABLE Employees (\n    EmployeeID int PRIMARY KEY,\n    FirstName varchar(255) NOT NULL,\n    LastName varchar(255),\n    Salary decimal(10, 2),\n    HireDate date\n);\n```\n\n*   `Employees`: 表名\n*   `EmployeeID`: 列名，`int` 类型，`PRIMARY KEY` (主键)\n*   `FirstName`: 列名，`varchar(255)` 类型，`NOT NULL` (非空约束)\n*   `Salary`: 列名，`decimal(10, 2)` 类型 (总共 10 位数字，小数点后 2 位)\n*   `HireDate`: 列名，`date` 类型\n\n\n\n### 2. 插入数据 (INSERT INTO)\n\n**语法:**\n\n```sql\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n```\n\n**示例:**\n\n```sql\nINSERT INTO Employees (EmployeeID, FirstName, LastName, Salary, HireDate)\nVALUES (1, 'John', 'Doe', 60000.00, '2023-01-15');\n```\n\n### 3. 查询数据 (SELECT)\n\n**语法:**\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;  -- 可选\n```\n\n**示例:**\n\n```sql\nSELECT FirstName, LastName, Salary\nFROM Employees\nWHERE Salary > 50000;\n```\n\n*   选择 `Employees` 表中 `Salary` 大于 50000 的员工的 `FirstName`, `LastName`, 和 `Salary`。\n\n\n\n### 4. 更新数据 (UPDATE)\n\n**语法:**\n\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n```\n\n**示例:**\n\n```sql\nUPDATE Employees\nSET Salary = 65000.00\nWHERE EmployeeID = 1;\n```\n\n*   将 `EmployeeID` 为 1 的员工的 `Salary` 更新为 65000.00。\n\n### 5. 删除数据 (DELETE)\n\n**语法:**\n\n```sql\nDELETE FROM table_name\nWHERE condition;\n```\n\n**示例:**\n\n```sql\nDELETE FROM Employees\nWHERE EmployeeID = 1;\n```\n\n*   删除 `EmployeeID` 为 1 的员工记录.\n\n### 6. 修改表结构 (ALTER TABLE)\n\n**语法 (添加列):**\n\n```sql\nALTER TABLE table_name\nADD column_name datatype constraint;\n```\n\n**语法 (修改列):**\n\n```sql\nALTER TABLE table_name\nALTER COLUMN column_name datatype;  \n```\n\n**语法 (删除列):**\n\n```sql\nALTER TABLE table_name\nDROP COLUMN column_name; \n```\n\n**示例 (添加列):**\n\n```sql\nALTER TABLE Employees\nADD Department varchar(255);\n```\n\n**示例 (修改列 - SQL Server):**\n\n```sql\nALTER TABLE Employees\nALTER COLUMN Department varchar(100);\n```\n\n**示例 (删除列):**\n\n```sql\nALTER TABLE Employees\nDROP COLUMN Department;\n```\n\n### 7. 删除表 (DROP TABLE)\n\n**语法:**\n\n```sql\nDROP TABLE table_name;\n```\n\n**示例:**\n\n```sql\nDROP TABLE Employees;\n```\n\n*   删除名为 `Employees` 的表.\n\n除此之外, 如果我们希望保留表的结构, 只是删除表内部的内容, 可以使用`drop from table_name`.\n\n### 8. 常用约束 (Constraints)\n\n*   `PRIMARY KEY`:  唯一标识表中每一行的列。\n*   `NOT NULL`:  确保列不能包含 NULL 值。\n*   `UNIQUE`:  确保列中的所有值都是不同的。\n*   `FOREIGN KEY`:  在一个表中引用另一个表中的 PRIMARY KEY。\n*   `CHECK`:  限制可以放入列中的值的范围。\n*   `DEFAULT`:  如果在没有指定值的情况下插入行，则设置列的默认值。\n\ne.g. \n\n```sql\ncreate table instructor(\n\tID char(5),\n  name varchar(20) not null,\n  dept_name varchar(20),\n  salary numeric(8,2) default 0,\n  primary key (ID),\n  foreign key(dept_name) references department\n);\n```\n\n> 可以将主键简写成: `ID char(5) primary key,`\n\n\n\ne.g. 外键的约束:\n\n```sql\nforeign key(dept_name) references department)\n\ton delete cascade \n\ton update cascade,\n```\n\n> `cascade`表示当`department`表当中的对应条目被删除/更新时, 同样删除/更新`course`表中的内容;\n>\n> 此外, 还有其他的约束条件可供选择: `set null`和`set default`分别表示操作之后将其设置为空或者默认值; `restrict`表示限制操作(避免存在于`course`中的条目在`department`当中被删除或者更新).\n\n\n\n### 9. 索引 (INDEX)\n\n**语法:**\n\n```sql\nCREATE INDEX index_name\nON table_name (column1, column2, ...);\n```\n\n**示例:**\n\n```sql\nCREATE INDEX idx_lastname\nON Employees (LastName);\n```\n\n*   在 `Employees` 表的 `LastName` 列上创建一个名为 `idx_lastname` 的索引，以提高查询效率。\n\n\n\n## Query Structure\n\nDML( data-manipulation language ) 允许我们对元组进行增删改查的操作:\n\n```sql\nselect A1,A2...\nfrom r1, r2...\nwhere P\n```\n\n其中, $A_i$ 表示属性, $R_i$表示关系, $P$表示约束条件.\n\n> SQL的name对于大小写**不敏感**.\n\n- `select`: 选择操作对应于关系代数中的**投影**\n\n  - 使用`select distinct`消除结果中的重复元组(`all`则强调不移除);\n  - `select *`表示投影获得全部的属性;\n  - 属性中支持基本的四则运算: `select salary/2`;\n\n- `from`: 列出语句中涉及的关系, 对应于关系代数中的**笛卡尔积**\n\n  - 可以使用声明`natural join`, 也即是将关系根据相同属性的值进行组合.\n    e.g. \n    <img src=\"数据库系统.assets/image-20250228111935730.png\" alt=\"image-20250228111935730\" style=\"zoom:30%;\" />\n  - \n\n- `where`: 对应于关系代数中的选择 $\\sigma$ \n\n  - 使用 `and`,`or`,`not`对应逻辑运算;\n\n  - 支持只用`between`进行比较运算, `<>`表示不相等;\n\n    e.g: `where salary between 3000 and 4000`.\n\n  - 同样支持**元组**的比较:\n\n    e.g:   <img src=\"数据库系统.assets/image-20250228111447627.png\" alt=\"image-20250228111447627\" style=\"zoom:50%;\" />\n\n\n\n## Other\n\n### Rename\n\n- `as`: 使用~进行重命名操作\n  - 可以忽略关键字`as` (i.e `instructor as T`等价于`instructor T`) \n\n\n\n### String\n\nSQL为字符串匹配设置了`%`和`_`操作, 需要与`like`搭配使用:\n\n- `%`: 匹配任意字符串;\n- `_`: 匹配任意的**字符**\n\n> 如果字符串中包含了实际的 `%` 或 `_` 字符，可以使用 `ESCAPE` 关键字指定一个转义字符，用于转义这些特殊字符.\n\n\n\ne.g. 名字当中包含了子串`dar`: \n\n```sql\nwhere name like  '%dar%'\n```\n\ne.g. 匹配字符串 \"100 %\" 的几种方法 (假设转义字符为 `\\` 和 `#`):\n\n```sql\nLIKE '100 \\\\%' ESCAPE '\\\\'  -- 使用反斜杠作为转义字符\nLIKE '100 %'                -- 如果数据库支持直接匹配，或者百分号不需要转义\nLIKE '100 #%' ESCAPE '#'    -- 使用井号作为转义字符\n```\n\n> TODO\n\n\n\n组合使用的例子:\n\n- 恰好有3个字符的字符串: `_ _ _`\n- 至少有3个字符的字符串: `_ _ _ %`\n\n\n\n### `Order`\n\n使用关键字`order`可以帮助我们将得到的元组进行按照属性的字典序进行排序:\n\n- `order by name`: 按照名称的字典序排序;\n- 可以使用`desc`和`asc`分别强调按照降序和升序来排序: \n  e.g. `order by name desc`\n\n- 支持组合的排序: `order by dept_name, name`.\n\n\n\n### `Limit`\n\n*   **作用:** 用于限制 `SELECT` 语句返回的行数;\n*   **参数:** 接受一个或两个数字参数，必须是非负整数常量。\n    *   `LIMIT row_count`:  返回从结果集开始的前 `row_count` 行。\n    *   `LIMIT offset, row_count`: 从结果集的 `offset` 行开始（`offset`从 0 开始计数），返回 `row_count` 行。  等价于 `LIMIT row_count OFFSET offset`。\n    \n*   **等价关系:** `LIMIT row_count` 等价于 `LIMIT 0, row_count`;\n\n\n\n**e.g.:** 列出薪水最高的 3 位 instructors 的姓名:\n\n```sql\nSELECT name\nFROM instructor\nORDER BY salary DESC\nLIMIT 3;   -- 等价于 LIMIT 0, 3;\n```\n\n**要点总结:**\n\n*   `LIMIT` 用于分页显示数据，或者只获取结果集中的一部分数据。\n*   `OFFSET` 指定起始位置，`row_count` 指定返回的行数。\n*   通常与 `order by` 子句一起使用，以确保返回的是排序后的结果集的前几行。\n\n**补充说明:**\n\n*   在没有 `ORDER BY` 子句的情况下使用 `LIMIT`，结果的顺序是不确定的.\n*   `LIMIT` 可以显著提高查询性能，特别是当处理大型数据集时.\n\n> P31\n\n\n\n# 笔记缓冲区\n\n### Domain\n\n当某些列需要限制其取值范围, 也就是具有一定的约束条件时, 如果每次创建类似的列都重复书写, 工作量较大.\n\n`domain`可以理解为对数据类型的**扩展定义**，它允许我们**创建自定义**的数据类型，并且可以为其指定约束条件。使用 domain 可以确保数据的一致性，\n\n- 基本语法\n\n```sql\nCREATE DOMAIN 域名 数据类型\n[DEFAULT 默认值]\n[CONSTRAINT 约束名称]\n[CHECK (约束条件)];\n```\n\n- e.g. \n\n  - ```sql\n    -- 创建一个表示年龄的域\n    CREATE DOMAIN age_type INTEGER\n    CONSTRAINT valid_age\n    CHECK (VALUE >= 0 AND VALUE <= 150);\n    ```\n\n- 使用:\n\n```sql\n-- 1. 首先创建一个域\nCREATE DOMAIN phone_number VARCHAR(15)\nCONSTRAINT phone_format_check\nCHECK (VALUE ~ '^\\d{11}$');  -- 初始约束：只允许11位数字\n\n-- 2. 创建使用该域的表\nCREATE TABLE customers (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    phone phone_number\n);\n\n-- 3. 插入一些数据\nINSERT INTO customers (name, phone) VALUES ('张三', '13812345678');  -- 成功\nINSERT INTO customers (name, phone) VALUES ('李四', '138-1234-5678');  -- 失败，因为包含破折号\n\n-- 4. 如果我们想修改约束，允许带破折号的电话号码格式\nALTER DOMAIN phone_number \nDROP CONSTRAINT phone_format_check;  -- 首先删除旧的约束\n\nALTER DOMAIN phone_number\nADD CONSTRAINT phone_format_check    -- 添加新的约束\nCHECK (VALUE ~ '^\\d{3}(-?\\d{4}){2}$');  -- 新格式：允许有破折号\n\n-- 现在可以插入带破折号的电话号码了\nINSERT INTO customers (name, phone) VALUES ('李四', '138-1234-5678');  -- 成功\n\n```\n\n> 由此可见, 约束名称的定义方便我们后续对`domain`的维护.\n\n\n\n### Index\n\n如果要经常查询大型表格中的某列属性, 可以为其添加索引(`index`). \n\n- 语法:\t\n\n```sql\nCREATE INDEX index_name ON table_name(column1, column2, ...);\n```\n\n>  index_name 是索引的名称，table_name 是要建立索引的表，括号中是要建立索引的列名.\n\n\n\n- 作用方式:\n  - 根据给出的列, 将其构造成B+树等数据结构, 每个节点的key是属性值, value是在原表中的行的指针.\n  - 因此, 将原本的线性搜索O(n)时间成本降低为了O(log n).\n- e.g.\n\n```sql\n-- 创建表结构 --\nCREATE TABLE students (\n    id INT,\n    name VARCHAR(50),\n    email VARCHAR(100)\n);\n\n-- 插入一些数据\nINSERT INTO students VALUES \n(1, '张三', 'zhang@zju.edu.cn'),\n(2, '李四', 'li@zju.edu.cn'),\n(3, '王五', 'wang@zju.edu.cn');\n\n-- 创建索引 --\nCREATE INDEX idx_email ON students(email);\n\n-- 此时的索引内部结构 --\n           li@zju.edu.cn\n          /              \\\n    zhang@zju.edu.cn    wang@zju.edu.cn\n\n-- 执行查询 --\nSELECT * FROM students WHERE email = 'zhang@zju.edu.cn';\n```\n\n\n\n### Assertion\n\nAssertion(断言): 是数据库中的完整性约束机制, 用于**预先定义**数据库中必须始终满足的条件.\n\ne.g:\n\n```sql\ncreate assertion credits_constaint check (\n    not exists(\n        select *\n        from student S\n        where total_cred <> (\n            select sum(credits)\n            from takes natural join course\n            where takes.ID = S.ID \n                and grade is not null \n                and grade <> 'F'\n        )\n    )\n)\n```\n\n> 在最外层，通过`create assertion`语句创建断言并使用`not exists`确保没有违规记录；中间层主要关注学生表中的总学分字段；而最内层则通过复杂的子查询来计算学生实际获得的有效学分总和(成绩存在且不为`false`).\n>\n> `<>`表示不等于.\n\n\n\n虽然断言是一个强大的数据完整性保证机制，但MySQL并不支持这一特性。这主要是出于性能考虑：断言需要在相关表发生变化时进行复杂的检查，这可能会显著影响数据库的操作效率。作为替代方案，MySQL通常会使用**触发器（trigger）**来实现类似的功能。\n\n\n\n### Trigger\n\n- 语法:\n\n```sql\n  create trigger trigger_name before/after trigger_event of table_name on attribute\n  referencing xxx\n  for each row\n  when xxxx\n  begin \n  xxxx(SQL operation)\n  end\n```\n\n\n\n### Authorization\n\n1. **权限控制的重要性**\n\n在数据库系统中，不同用户往往需要不同级别的访问权限。例如，普通员工可能只需要查询权限，而部门主管可能需要更新数据的权限。为了确保数据安全和隐私保护，数据库系统提供了完善的权限控制机制，包括读取(read)、插入(insert)、更新(update)和删除(delete)这四种基本权限。\n\n2. **基本授权语法**\n\nSQL提供了灵活的授权语句来管理用户权限。最基本的授权使用`GRANT`语句：\n\n```sql\nGRANT <privilege_list> ON <relation_name or view_name> TO <user_list>\n```\n\n这里的`<user_list>`既可以是具体的用户名，也可以是关键字`PUBLIC`（表示授权给所有用户）。特别地，当我们需要允许用户具有转授权的能力时，可以在授权语句末尾添加`WITH GRANT OPTION`子句。\n\n3. **权限管理的高级特性**\n\n为了更灵活地管理权限，SQL还提供了权限回收机制和角色管理：\n\n- 权限回收使用`REVOKE`语句：\n\n```sql\nREVOKE <privilege_list> ON <relation_name> FROM <user_list> [RESTRICT|CASCADE]\n```\n其中`RESTRICT`表示仅回收**直接授予**的权限，而`CASCADE`则会同时回收该用户**转授给其他**用户的权限。\n\n- 角色管理通过`CREATE ROLE`实现：\n\n```sql\nCREATE ROLE manager;\nGRANT SELECT, UPDATE ON employees TO manager;\nGRANT manager TO user1, user2;\n```\n\n4. **实际应用示例**\n\n假设我们正在管理一个大学教务系统，可能会有如下权限设置：\n\n```sql\n-- 创建教师角色\nCREATE ROLE teacher;\n\n-- 给教师角色授予查看和修改成绩的权限\nGRANT SELECT, UPDATE ON student_grades TO teacher;\n\n-- 给具体教师授予角色\nGRANT teacher TO 'prof_zhang', 'prof_li';\n\n-- 给教务主管额外的权限，并允许其转授权限\nGRANT ALL PRIVILEGES ON student_grades TO 'academic_dean' WITH GRANT OPTION;\n\n-- 如果教师离职，收回其权限\nREVOKE teacher FROM 'prof_zhang' CASCADE;\n```\n\n> ` ALL PRIVILEGES`表示授予所有的权限.\n\n","source":"_drafts/temp_notes/数据库系统.md","raw":"---\ntitle: DataBase\ndate: 2025-02-20 11:09:12\ntags:\ncategories: 课程笔记\nexcerpt: DB\nmath: true\nindex_assets: /assets/db_index.png\n---\n# Intro\n\n<img src=\"数据库系统.assets/image-20250225103821388.png\" alt=\"image-20250225103821388\" style=\"zoom:50%;\" />\n\n概念:\n- **DBMS**: database-management system, \n- **Different levels** \n  - Physical:  数据如何存储;\n  - Logical: data如何在数据库中组织(内部关系)\n    ```pascal\n    type instructor = record\n        ID: string;        // ID字段，字符串类型\n        name: string;      // 姓名字段，字符串类型\n        dept_name: string; // 部门名称字段，字符串类型\n        salary: integer;   // 薪资字段，整数类型\n    end;\n    ```\n  - View: 可以根据用户需求定义可见的数据结构;\n\n**Data Models**\n\n- Relational model: 关系型数据库;\n- Entity-Relationship data model(E-R) : 实体-关系型数据库;\n  - 实体是现实世界中可区分的对象, 属性是实体的特征描述;\n- Object-based data models : 对象型数据库;\n- Semistructured data model(**XML** 和 **JSON**) : 半结构化数据库;\n  - 灵活性体现在: 嵌套结构, 可选字段, 混合类型等.\n\n**Instances and Schemas**\n\n- 模式 **Schema** : 数据的组织方式\n  - 逻辑模式 Logical Schema: 对数据库结构的描述;\n    ```sql\n    CREATE TABLE Customer (\n        customer_id INT PRIMARY KEY,\n        name VARCHAR(100),\n        email VARCHAR(100),\n        registration_date DATE\n    );\n    ```\n  - 物理模式 Physical Schema: 描述数据实际存储的方式;\n    - 比如使用的索引结构(B+树, 哈希表等), 缓冲区的管理策略等.\n- 实例 **Instance**: 实际存储的数据\n    ```sql\n    INSERT INTO Customer VALUES\n    (1, '张三', 'zhang@email.com', '2024-01-15'),\n    (2, '李四', 'li@email.com', '2024-02-01');\n    ```\n- 物理数据独立性 **Physical Data Independence** \n  - 指的是允许用户在不影响数据库逻辑结构的情况下, 改变物理存储方式.\n  - 比如数据存储的位置, 索引结构等的改变.\n\n---\n\nData Definition Language (**DDL**) \n- 作用: 定义数据库的结构, 包括表, 索引, 视图等;\n- e.g:\n  - 基本表的结构定义:\n    ```sql\n    CREATE TABLE instructor (\n        ID char(5),           -- 固定长度5个字符\n        name varchar(20),     -- 可变长度，最多20个字符\n        dept_name varchar(20),\n        salary numeric(8,2)   -- 总长8位，小数点后2位\n    );\n    ```\n  - 完整性约束:\n    ```sql\n    CREATE TABLE instructor (\n            ID char(5) PRIMARY KEY,  -- 主键约束\n            name varchar(20) NOT NULL,  -- 非空约束\n            dept_name varchar(20) REFERENCES department(dept_name),  -- 外键约束\n            salary numeric(8,2) CHECK (salary > 0)  -- 值约束\n        );\n    ```\n\n使用DDL创建数据库对象时, 上述的定义将会被存储在称为数据字典(**Data dictionary**)的结构当中, 包括以下元数据:\n- 模式信息\n- 完整性约束\n  - 主键, 引用完整性, 值约束\n- 授权信息\n    ```sql\n    -- 授权示例\n    GRANT SELECT, INSERT ON instructor TO user1;\n    GRANT UPDATE (salary) ON instructor TO payroll_admin;\n    ```\n\n---\n\nData Manipulation Language (**DML**)\n- 指的是用于处理和操纵对应模型的数据的语言;\n- 根据是否需要用户声明 `how to get those data`分为 **two classes**:\n  - **Procedural** : 需要声明;\n  - **Declarative**: 无需声明\n    - SQL 就是其中被广泛应用的类型之一.\n\n# Relational Model\n\n基本概念:\n\n- 属性(attribute) 也就是列;\n- 元组(tuple) 也就是行;\n- $R = (A_1,A_2,\\dots,A_n)$ 为关系的范式;\n- `NULL`表示未知, 而非不存在. 是所有类型属性的值域的一员.\n\n##  keys\n**superkey**: \n- 定义: values for K are sufficient to identify a unique tuple of each possible relation r(R) $\\Longrightarrow$ K is a  ~(超键) of R.\n- 超键在推断的时候, 可能存在冗余的属性.\n\n**candidate key**(候选键): 超键K is **minimal** $\\Rightarrow$ K is ~\n\n**primary key**(主键): 我们从候选键中选择一个key作为主键.\n\n**foreign key**(外键): \n\n-  R1 的一个或一组列的值(的范围)与 R2 的主键值(的范围)相匹配 \n  $\\Rightarrow$ R1 的这个或这组列，称为指向 R2 的外键。\n\n**Referential Integrity Constraint**: \n\n- 即 参照完整性约束;\n- 指 引用关系表R1以被引用关系表R2, R1的外键的值必须在R2中存在.\n- *e.g*  存在订单表和客户表, 订单表中的“客户ID”列是外键，它引用客户表中的“客户ID”列(主键), 要求订单表中的“客户ID”值必须在客户表中存在.\n\n---\n\n## Relational algebra\n关系代数(relational algebra), 元组关系演算(tuple relational calculus), 域关系演算(domain relational calculus) 相互等价. 我们将重点关注**关系代数**.\n### Basic Op.\n关系代数包含以下六种基本操作:\n- ***select*** $\\sigma$: 选取满足条件的元组;\n  - $\\sigma _{\\rho}(r)$, 其中$\\rho$由一系列的`term`在 $\\wedge$,$\\vee$,$\\neg$的符号连接下组成.\n  - `term`由列与列(或常值)的比较运算得到;\n  - e.g: $$\\sigma _{salary\\ >\\ 30000}(instructor)$$\n- ***project*** $\\pi$ : 投影以选取指定的属性;\n  - $\\pi_{A,B}(R)$: 只保留R中的A,B列;\n- ***union*** $\\cup$: 将不同的关系相结合\n  - **要求**: 不同关系的属性数量和对应的类型保持一致;\n  - **结果**: 自动**去除重复**的元组.\n- ***rename*** $\\rho$: 用于重命名属性或者表名;\n  - $\\rho_{(A_1, \\dots, A_n)}(R)$: 将R中的属性重命名为$A_1,\\dots,A_n$;\n  - $\\rho_{R_1}(R_2)$: 将R_2的表名重命名为R_1;\n  - $\\rho_{S(B1,B2,...,Bn)}(R)$  -- 将关系R重命名为S，并重命名其属性\n- ***set difference*** $-$: 在一个关系中删除另一个关系中存在的元组;\n  - **要求**: 关系相容, 即具有相同的属性个数和类型\n  - 如果两个关系有相同的属性, 则将其重命名为不同的名称;\n- ***cartesian product*** $\\times$: 笛卡尔积, 将不同表格中的数据进行组合匹配\n  - **结果**: 属性数量是二者之和, 元组数量是二者之积\n  - 可以事先对参与计算的表进行$\\sigma$ 等计算, 减小计算成本.\n\n**e.g**\n- Find all courses taught in the Fall 2009 semester,but\n**not in** the Spring 2010 semester:\n$$\n\\pi_{course\\_id}(\\sigma_{semester=\"Fall\"\\  \\wedge \\ year = 2009}(section)) - \\\\\n\\pi_{course\\_id}(\\sigma_{semester=\"spring\"\\  \\wedge \\ year = 2010}(section))\n$$\n\n- Find the largest salary in the university\n  - **Step1**: 将员工表重命名为`d`然后与自身`i`进行笛卡尔积, 得到的元组, 筛选出`i`的工资较少的元组集合, 利用 $\\pi$ 投影获得工资部分\n  ![](assets/2025-02-22-17-27-31.png)\n> 去除了工资本身最大的元组\n  - **Step2**: 对原表投影得到工资部分, 然后对第一步得到的集合取差\n![](assets/2025-02-22-17-31-07.png)\n  - **可视化:**\n![](assets/2025-02-22-17-32-24.png)\n\n\n\n### Additional Op.\n关系代数包含以下扩展操作：\n\n- ***set intersection*** $\\cap$：获取两个关系的公共元组\n\n  - **要求**：关系相容，具有相同的属性结构\n  - **结果**：包含同时出现在两个关系中的元组\n  - e.g: $r \\cap s$ 表示同时存在于r和s中的元组\n\n  $$\n  r \\cap s = r -(r-s) \n  $$\n\n  \n\n- ***natural join*** $\\bowtie$：基于**共同属性**的自动连接\n\n  - 识别并匹配具有相同名称的属性, 结果中只选取相同名称属性**对应值相等**的部分;\n  - 其他连接的“满足连接条件”指的就是自然连接$\\bowtie $ \n\n  e.g. \n\n  <img src=\"数据库系统.assets/image-20250224214646008.png\" alt=\"image-20250224214646008\" style=\"zoom:50%;\" />\n\n  - **theta join**:  $r \\bowtie_\\theta s := \\sigma_\\theta (r \\times s)$ , 先对作笛卡尔积, 然后取用满足条件$\\theta$的部分.\t\n\n- ***semijoin*** $\\ltimes$：半连接操作\n\n  - 结果仅保留**左表中**满足连接条件的元组\n  - 属性仅包含左表的所有属性\n  - e.g: $student \\ltimes takes$ 返回选过课的**学生信息**\n  - $ r \\ltimes_\\theta s := \\pi_R(r\\bowtie_\\theta s)$\n\n- ***assignment*** $\\leftarrow$：将查询结果赋值给临时关系\n\n  - 用于简化复杂查询\n  - 可以重复使用中间结果\n  - e.g: $temp \\leftarrow \\pi_{ID,name}(instructor)$\n\n- ***outer join***：**保留未匹配**元组的连接操作, 避免信息缺失(均在$\\bowtie$的基础上, 即笛卡尔积的结果)\n\n  - 左外连接 $\\leftarrow\\bowtie$：保留左表未匹配的元组\n  - 右外连接 $\\bowtie\\rightarrow$：保留右表未匹配的元组\n  - 全外连接 $\\leftarrow\\bowtie\\rightarrow$：保留两表中未匹配的元组\n  - 未匹配的属性值**填充NULL**\n  - e.g. <img src=\"数据库系统.assets/image-20250224220313846.png\" alt=\"image-20250224220313846\" style=\"zoom:50%;\" />\n\n- ***division*** $\\div$： $ r \\div s$ \n\n  - 用于查找满足所有条件的元组\n  - 更具体地说, 寻找r中的tuple使得与s关系的所有元组的笛卡尔积都在r中;\n  - **要求**: $s \\sub r$ \n\n  > [!note]\n  >\n  > <img src=\"数据库系统.assets/image-20250225121938529.png\" alt=\"image-20250224223816689\" style=\"zoom:50%; float: left;\" />\n\n  **e.g.** \n\n <img src=\"数据库系统.assets/image-20250224221730846.png\" alt=\"image-20250224221730846\" style=\"zoom:50%;\" />\n\n### Aggregate\n\n**聚合函数**: avg, min, max, sum ,count.\n\n- 除了`count`, 其他函数对于**属性的类型**有要求(可以计算).\n\n**聚合操作**: $_{G_1,G_2\\dots}\\mathcal{G}_{F_i(A_i)}(E)$ \n\n- $G_i$是待聚合的属性, 可以为空;\n- $F_i$是聚合函数, $A_i$是属性名.\n\ne.g.:\n\n<img src=\"数据库系统.assets/image-20250224224824019.png\" alt=\"image-20250224224824019\" style=\"zoom:50%;\" />\n\n由于聚合操作得到的列没有自己的名字, 为了方便起见, SQL允许我们直接使用关键字`as`来快速`rename`. 比如对于上述在表`instructor`上的聚合操作, 将结果命名为`avg_sal`的指令:\n$$\n_{dept\\_name}\\ \\mathcal{G}_{avg(salary)\\ as \\ avg\\_sal}(instructor)\n$$\n\n### Multiset\n\npure relational algebra 中不存在重复的元组.\n\n但是在多重集(multiset)当中允许元组重复. \n\n- 多重集的关系代数:\n  - 选择: 即使给出一个元组, 也选中所有符合条件的元组;\n  - 投影: 同理;\n  - **cross product:** 也会将重复的元组多次计算.\n    - m copies of t1 in r, and n copies of t2 in s , then $ m \\times n$ copies of t1.t2 in $r \\times s$ .\n\n- 其他操作:\n  - **union**: m + n copies;\n  - **intersection**: min(m, n) copies;\n  - **difference**: min(0, m-n) copies.\n\n\n\n---\n\n# SQL\n\n###  Domain Types\n\n\n- Char(n): 定长字符串，用户指定长度为 n。\n- Varchar(n): 变长字符串，用户指定最大长度为 n。\n- Int: 整数 (机器相关的整数的有限子集)。\n- Smallint: 小整数 (机器相关的整数域子集)。\n- Numeric(p,d): 定点数，用户指定精度，总共 p 位数字，其中小数点后 d 位。 例如：number(3,1) 允许精确存储 44.5，但不允许 444.5 或 0.32。\n- Real, Double precision: 浮点数和双精度浮点数，精度与机器相关。\n- Float(n): 浮点数，用户指定至少 n 位数字的精度。\n\n\n\n关于时间的类型:\n\n- Date: 日期，包含（4 位数）年份、月份和日期。例如：date '2005-7-27'\n- Time: 一天中的时间，以小时、分钟和秒为单位。例如：time '09:00:30'  time '09:00:30.75'\n- Timestamp: 日期加上一天中的时间。例如：timestamp '2005-7-27 09:00:30.75'\n- Interval: 一段时间。例如：interval '1' day。从另一个日期/时间/时间戳值中减去一个日期/时间/时间戳值会得到一个 interval 值。Interval 值可以添加到日期/时间/时间戳值。\n- Date, time 函数:\n  - current_date()\n  - current_time()\n  - year(x), month(x), day(x), hour(x), minute(x), second(x)\n\n## Common Operations\n\n### 1. 创建表 (CREATE TABLE)\n\n**语法:**\n\n```sql\nCREATE TABLE table_name (\n    column1 datatype constraint,\n    column2 datatype constraint,\n    column3 datatype,\n    ....\n);\n```\n\n**e.g.:**\n\n```sql\nCREATE TABLE Employees (\n    EmployeeID int PRIMARY KEY,\n    FirstName varchar(255) NOT NULL,\n    LastName varchar(255),\n    Salary decimal(10, 2),\n    HireDate date\n);\n```\n\n*   `Employees`: 表名\n*   `EmployeeID`: 列名，`int` 类型，`PRIMARY KEY` (主键)\n*   `FirstName`: 列名，`varchar(255)` 类型，`NOT NULL` (非空约束)\n*   `Salary`: 列名，`decimal(10, 2)` 类型 (总共 10 位数字，小数点后 2 位)\n*   `HireDate`: 列名，`date` 类型\n\n\n\n### 2. 插入数据 (INSERT INTO)\n\n**语法:**\n\n```sql\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n```\n\n**示例:**\n\n```sql\nINSERT INTO Employees (EmployeeID, FirstName, LastName, Salary, HireDate)\nVALUES (1, 'John', 'Doe', 60000.00, '2023-01-15');\n```\n\n### 3. 查询数据 (SELECT)\n\n**语法:**\n\n```sql\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;  -- 可选\n```\n\n**示例:**\n\n```sql\nSELECT FirstName, LastName, Salary\nFROM Employees\nWHERE Salary > 50000;\n```\n\n*   选择 `Employees` 表中 `Salary` 大于 50000 的员工的 `FirstName`, `LastName`, 和 `Salary`。\n\n\n\n### 4. 更新数据 (UPDATE)\n\n**语法:**\n\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n```\n\n**示例:**\n\n```sql\nUPDATE Employees\nSET Salary = 65000.00\nWHERE EmployeeID = 1;\n```\n\n*   将 `EmployeeID` 为 1 的员工的 `Salary` 更新为 65000.00。\n\n### 5. 删除数据 (DELETE)\n\n**语法:**\n\n```sql\nDELETE FROM table_name\nWHERE condition;\n```\n\n**示例:**\n\n```sql\nDELETE FROM Employees\nWHERE EmployeeID = 1;\n```\n\n*   删除 `EmployeeID` 为 1 的员工记录.\n\n### 6. 修改表结构 (ALTER TABLE)\n\n**语法 (添加列):**\n\n```sql\nALTER TABLE table_name\nADD column_name datatype constraint;\n```\n\n**语法 (修改列):**\n\n```sql\nALTER TABLE table_name\nALTER COLUMN column_name datatype;  \n```\n\n**语法 (删除列):**\n\n```sql\nALTER TABLE table_name\nDROP COLUMN column_name; \n```\n\n**示例 (添加列):**\n\n```sql\nALTER TABLE Employees\nADD Department varchar(255);\n```\n\n**示例 (修改列 - SQL Server):**\n\n```sql\nALTER TABLE Employees\nALTER COLUMN Department varchar(100);\n```\n\n**示例 (删除列):**\n\n```sql\nALTER TABLE Employees\nDROP COLUMN Department;\n```\n\n### 7. 删除表 (DROP TABLE)\n\n**语法:**\n\n```sql\nDROP TABLE table_name;\n```\n\n**示例:**\n\n```sql\nDROP TABLE Employees;\n```\n\n*   删除名为 `Employees` 的表.\n\n除此之外, 如果我们希望保留表的结构, 只是删除表内部的内容, 可以使用`drop from table_name`.\n\n### 8. 常用约束 (Constraints)\n\n*   `PRIMARY KEY`:  唯一标识表中每一行的列。\n*   `NOT NULL`:  确保列不能包含 NULL 值。\n*   `UNIQUE`:  确保列中的所有值都是不同的。\n*   `FOREIGN KEY`:  在一个表中引用另一个表中的 PRIMARY KEY。\n*   `CHECK`:  限制可以放入列中的值的范围。\n*   `DEFAULT`:  如果在没有指定值的情况下插入行，则设置列的默认值。\n\ne.g. \n\n```sql\ncreate table instructor(\n\tID char(5),\n  name varchar(20) not null,\n  dept_name varchar(20),\n  salary numeric(8,2) default 0,\n  primary key (ID),\n  foreign key(dept_name) references department\n);\n```\n\n> 可以将主键简写成: `ID char(5) primary key,`\n\n\n\ne.g. 外键的约束:\n\n```sql\nforeign key(dept_name) references department)\n\ton delete cascade \n\ton update cascade,\n```\n\n> `cascade`表示当`department`表当中的对应条目被删除/更新时, 同样删除/更新`course`表中的内容;\n>\n> 此外, 还有其他的约束条件可供选择: `set null`和`set default`分别表示操作之后将其设置为空或者默认值; `restrict`表示限制操作(避免存在于`course`中的条目在`department`当中被删除或者更新).\n\n\n\n### 9. 索引 (INDEX)\n\n**语法:**\n\n```sql\nCREATE INDEX index_name\nON table_name (column1, column2, ...);\n```\n\n**示例:**\n\n```sql\nCREATE INDEX idx_lastname\nON Employees (LastName);\n```\n\n*   在 `Employees` 表的 `LastName` 列上创建一个名为 `idx_lastname` 的索引，以提高查询效率。\n\n\n\n## Query Structure\n\nDML( data-manipulation language ) 允许我们对元组进行增删改查的操作:\n\n```sql\nselect A1,A2...\nfrom r1, r2...\nwhere P\n```\n\n其中, $A_i$ 表示属性, $R_i$表示关系, $P$表示约束条件.\n\n> SQL的name对于大小写**不敏感**.\n\n- `select`: 选择操作对应于关系代数中的**投影**\n\n  - 使用`select distinct`消除结果中的重复元组(`all`则强调不移除);\n  - `select *`表示投影获得全部的属性;\n  - 属性中支持基本的四则运算: `select salary/2`;\n\n- `from`: 列出语句中涉及的关系, 对应于关系代数中的**笛卡尔积**\n\n  - 可以使用声明`natural join`, 也即是将关系根据相同属性的值进行组合.\n    e.g. \n    <img src=\"数据库系统.assets/image-20250228111935730.png\" alt=\"image-20250228111935730\" style=\"zoom:30%;\" />\n  - \n\n- `where`: 对应于关系代数中的选择 $\\sigma$ \n\n  - 使用 `and`,`or`,`not`对应逻辑运算;\n\n  - 支持只用`between`进行比较运算, `<>`表示不相等;\n\n    e.g: `where salary between 3000 and 4000`.\n\n  - 同样支持**元组**的比较:\n\n    e.g:   <img src=\"数据库系统.assets/image-20250228111447627.png\" alt=\"image-20250228111447627\" style=\"zoom:50%;\" />\n\n\n\n## Other\n\n### Rename\n\n- `as`: 使用~进行重命名操作\n  - 可以忽略关键字`as` (i.e `instructor as T`等价于`instructor T`) \n\n\n\n### String\n\nSQL为字符串匹配设置了`%`和`_`操作, 需要与`like`搭配使用:\n\n- `%`: 匹配任意字符串;\n- `_`: 匹配任意的**字符**\n\n> 如果字符串中包含了实际的 `%` 或 `_` 字符，可以使用 `ESCAPE` 关键字指定一个转义字符，用于转义这些特殊字符.\n\n\n\ne.g. 名字当中包含了子串`dar`: \n\n```sql\nwhere name like  '%dar%'\n```\n\ne.g. 匹配字符串 \"100 %\" 的几种方法 (假设转义字符为 `\\` 和 `#`):\n\n```sql\nLIKE '100 \\\\%' ESCAPE '\\\\'  -- 使用反斜杠作为转义字符\nLIKE '100 %'                -- 如果数据库支持直接匹配，或者百分号不需要转义\nLIKE '100 #%' ESCAPE '#'    -- 使用井号作为转义字符\n```\n\n> TODO\n\n\n\n组合使用的例子:\n\n- 恰好有3个字符的字符串: `_ _ _`\n- 至少有3个字符的字符串: `_ _ _ %`\n\n\n\n### `Order`\n\n使用关键字`order`可以帮助我们将得到的元组进行按照属性的字典序进行排序:\n\n- `order by name`: 按照名称的字典序排序;\n- 可以使用`desc`和`asc`分别强调按照降序和升序来排序: \n  e.g. `order by name desc`\n\n- 支持组合的排序: `order by dept_name, name`.\n\n\n\n### `Limit`\n\n*   **作用:** 用于限制 `SELECT` 语句返回的行数;\n*   **参数:** 接受一个或两个数字参数，必须是非负整数常量。\n    *   `LIMIT row_count`:  返回从结果集开始的前 `row_count` 行。\n    *   `LIMIT offset, row_count`: 从结果集的 `offset` 行开始（`offset`从 0 开始计数），返回 `row_count` 行。  等价于 `LIMIT row_count OFFSET offset`。\n    \n*   **等价关系:** `LIMIT row_count` 等价于 `LIMIT 0, row_count`;\n\n\n\n**e.g.:** 列出薪水最高的 3 位 instructors 的姓名:\n\n```sql\nSELECT name\nFROM instructor\nORDER BY salary DESC\nLIMIT 3;   -- 等价于 LIMIT 0, 3;\n```\n\n**要点总结:**\n\n*   `LIMIT` 用于分页显示数据，或者只获取结果集中的一部分数据。\n*   `OFFSET` 指定起始位置，`row_count` 指定返回的行数。\n*   通常与 `order by` 子句一起使用，以确保返回的是排序后的结果集的前几行。\n\n**补充说明:**\n\n*   在没有 `ORDER BY` 子句的情况下使用 `LIMIT`，结果的顺序是不确定的.\n*   `LIMIT` 可以显著提高查询性能，特别是当处理大型数据集时.\n\n> P31\n\n\n\n# 笔记缓冲区\n\n### Domain\n\n当某些列需要限制其取值范围, 也就是具有一定的约束条件时, 如果每次创建类似的列都重复书写, 工作量较大.\n\n`domain`可以理解为对数据类型的**扩展定义**，它允许我们**创建自定义**的数据类型，并且可以为其指定约束条件。使用 domain 可以确保数据的一致性，\n\n- 基本语法\n\n```sql\nCREATE DOMAIN 域名 数据类型\n[DEFAULT 默认值]\n[CONSTRAINT 约束名称]\n[CHECK (约束条件)];\n```\n\n- e.g. \n\n  - ```sql\n    -- 创建一个表示年龄的域\n    CREATE DOMAIN age_type INTEGER\n    CONSTRAINT valid_age\n    CHECK (VALUE >= 0 AND VALUE <= 150);\n    ```\n\n- 使用:\n\n```sql\n-- 1. 首先创建一个域\nCREATE DOMAIN phone_number VARCHAR(15)\nCONSTRAINT phone_format_check\nCHECK (VALUE ~ '^\\d{11}$');  -- 初始约束：只允许11位数字\n\n-- 2. 创建使用该域的表\nCREATE TABLE customers (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    phone phone_number\n);\n\n-- 3. 插入一些数据\nINSERT INTO customers (name, phone) VALUES ('张三', '13812345678');  -- 成功\nINSERT INTO customers (name, phone) VALUES ('李四', '138-1234-5678');  -- 失败，因为包含破折号\n\n-- 4. 如果我们想修改约束，允许带破折号的电话号码格式\nALTER DOMAIN phone_number \nDROP CONSTRAINT phone_format_check;  -- 首先删除旧的约束\n\nALTER DOMAIN phone_number\nADD CONSTRAINT phone_format_check    -- 添加新的约束\nCHECK (VALUE ~ '^\\d{3}(-?\\d{4}){2}$');  -- 新格式：允许有破折号\n\n-- 现在可以插入带破折号的电话号码了\nINSERT INTO customers (name, phone) VALUES ('李四', '138-1234-5678');  -- 成功\n\n```\n\n> 由此可见, 约束名称的定义方便我们后续对`domain`的维护.\n\n\n\n### Index\n\n如果要经常查询大型表格中的某列属性, 可以为其添加索引(`index`). \n\n- 语法:\t\n\n```sql\nCREATE INDEX index_name ON table_name(column1, column2, ...);\n```\n\n>  index_name 是索引的名称，table_name 是要建立索引的表，括号中是要建立索引的列名.\n\n\n\n- 作用方式:\n  - 根据给出的列, 将其构造成B+树等数据结构, 每个节点的key是属性值, value是在原表中的行的指针.\n  - 因此, 将原本的线性搜索O(n)时间成本降低为了O(log n).\n- e.g.\n\n```sql\n-- 创建表结构 --\nCREATE TABLE students (\n    id INT,\n    name VARCHAR(50),\n    email VARCHAR(100)\n);\n\n-- 插入一些数据\nINSERT INTO students VALUES \n(1, '张三', 'zhang@zju.edu.cn'),\n(2, '李四', 'li@zju.edu.cn'),\n(3, '王五', 'wang@zju.edu.cn');\n\n-- 创建索引 --\nCREATE INDEX idx_email ON students(email);\n\n-- 此时的索引内部结构 --\n           li@zju.edu.cn\n          /              \\\n    zhang@zju.edu.cn    wang@zju.edu.cn\n\n-- 执行查询 --\nSELECT * FROM students WHERE email = 'zhang@zju.edu.cn';\n```\n\n\n\n### Assertion\n\nAssertion(断言): 是数据库中的完整性约束机制, 用于**预先定义**数据库中必须始终满足的条件.\n\ne.g:\n\n```sql\ncreate assertion credits_constaint check (\n    not exists(\n        select *\n        from student S\n        where total_cred <> (\n            select sum(credits)\n            from takes natural join course\n            where takes.ID = S.ID \n                and grade is not null \n                and grade <> 'F'\n        )\n    )\n)\n```\n\n> 在最外层，通过`create assertion`语句创建断言并使用`not exists`确保没有违规记录；中间层主要关注学生表中的总学分字段；而最内层则通过复杂的子查询来计算学生实际获得的有效学分总和(成绩存在且不为`false`).\n>\n> `<>`表示不等于.\n\n\n\n虽然断言是一个强大的数据完整性保证机制，但MySQL并不支持这一特性。这主要是出于性能考虑：断言需要在相关表发生变化时进行复杂的检查，这可能会显著影响数据库的操作效率。作为替代方案，MySQL通常会使用**触发器（trigger）**来实现类似的功能。\n\n\n\n### Trigger\n\n- 语法:\n\n```sql\n  create trigger trigger_name before/after trigger_event of table_name on attribute\n  referencing xxx\n  for each row\n  when xxxx\n  begin \n  xxxx(SQL operation)\n  end\n```\n\n\n\n### Authorization\n\n1. **权限控制的重要性**\n\n在数据库系统中，不同用户往往需要不同级别的访问权限。例如，普通员工可能只需要查询权限，而部门主管可能需要更新数据的权限。为了确保数据安全和隐私保护，数据库系统提供了完善的权限控制机制，包括读取(read)、插入(insert)、更新(update)和删除(delete)这四种基本权限。\n\n2. **基本授权语法**\n\nSQL提供了灵活的授权语句来管理用户权限。最基本的授权使用`GRANT`语句：\n\n```sql\nGRANT <privilege_list> ON <relation_name or view_name> TO <user_list>\n```\n\n这里的`<user_list>`既可以是具体的用户名，也可以是关键字`PUBLIC`（表示授权给所有用户）。特别地，当我们需要允许用户具有转授权的能力时，可以在授权语句末尾添加`WITH GRANT OPTION`子句。\n\n3. **权限管理的高级特性**\n\n为了更灵活地管理权限，SQL还提供了权限回收机制和角色管理：\n\n- 权限回收使用`REVOKE`语句：\n\n```sql\nREVOKE <privilege_list> ON <relation_name> FROM <user_list> [RESTRICT|CASCADE]\n```\n其中`RESTRICT`表示仅回收**直接授予**的权限，而`CASCADE`则会同时回收该用户**转授给其他**用户的权限。\n\n- 角色管理通过`CREATE ROLE`实现：\n\n```sql\nCREATE ROLE manager;\nGRANT SELECT, UPDATE ON employees TO manager;\nGRANT manager TO user1, user2;\n```\n\n4. **实际应用示例**\n\n假设我们正在管理一个大学教务系统，可能会有如下权限设置：\n\n```sql\n-- 创建教师角色\nCREATE ROLE teacher;\n\n-- 给教师角色授予查看和修改成绩的权限\nGRANT SELECT, UPDATE ON student_grades TO teacher;\n\n-- 给具体教师授予角色\nGRANT teacher TO 'prof_zhang', 'prof_li';\n\n-- 给教务主管额外的权限，并允许其转授权限\nGRANT ALL PRIVILEGES ON student_grades TO 'academic_dean' WITH GRANT OPTION;\n\n-- 如果教师离职，收回其权限\nREVOKE teacher FROM 'prof_zhang' CASCADE;\n```\n\n> ` ALL PRIVILEGES`表示授予所有的权限.\n\n","slug":"temp_notes/数据库系统","published":0,"updated":"2025-02-28T04:09:20.997Z","_id":"cm7kndg8q0008dmqgcf8v9jsl","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p><img src=\"数据库系统.assets/image-20250225103821388.png\" alt=\"image-20250225103821388\" style=\"zoom:50%;\" /></p>\n<p>概念:</p>\n<ul>\n<li><strong>DBMS</strong>: database-management system, </li>\n<li><strong>Different levels</strong> <ul>\n<li>Physical:  数据如何存储;</li>\n<li>Logical: data如何在数据库中组织(内部关系)<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pascal\"><span class=\"hljs-keyword\">type</span> instructor = <span class=\"hljs-keyword\">record</span><br>    ID: <span class=\"hljs-keyword\">string</span>;        <span class=\"hljs-comment\">// ID字段，字符串类型</span><br>    <span class=\"hljs-keyword\">name</span>: <span class=\"hljs-keyword\">string</span>;      <span class=\"hljs-comment\">// 姓名字段，字符串类型</span><br>    dept_name: <span class=\"hljs-keyword\">string</span>; <span class=\"hljs-comment\">// 部门名称字段，字符串类型</span><br>    salary: integer;   <span class=\"hljs-comment\">// 薪资字段，整数类型</span><br><span class=\"hljs-keyword\">end</span>;<br></code></pre></td></tr></table></figure></li>\n<li>View: 可以根据用户需求定义可见的数据结构;</li>\n</ul>\n</li>\n</ul>\n<p><strong>Data Models</strong></p>\n<ul>\n<li>Relational model: 关系型数据库;</li>\n<li>Entity-Relationship data model(E-R) : 实体-关系型数据库;<ul>\n<li>实体是现实世界中可区分的对象, 属性是实体的特征描述;</li>\n</ul>\n</li>\n<li>Object-based data models : 对象型数据库;</li>\n<li>Semistructured data model(<strong>XML</strong> 和 <strong>JSON</strong>) : 半结构化数据库;<ul>\n<li>灵活性体现在: 嵌套结构, 可选字段, 混合类型等.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Instances and Schemas</strong></p>\n<ul>\n<li>模式 <strong>Schema</strong> : 数据的组织方式<ul>\n<li>逻辑模式 Logical Schema: 对数据库结构的描述;<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> Customer (<br>    customer_id <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    email <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    registration_date <span class=\"hljs-type\">DATE</span><br>);<br></code></pre></td></tr></table></figure></li>\n<li>物理模式 Physical Schema: 描述数据实际存储的方式;<ul>\n<li>比如使用的索引结构(B+树, 哈希表等), 缓冲区的管理策略等.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实例 <strong>Instance</strong>: 实际存储的数据  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> Customer <span class=\"hljs-keyword\">VALUES</span><br>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;zhang@email.com&#x27;</span>, <span class=\"hljs-string\">&#x27;2024-01-15&#x27;</span>),<br>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;li@email.com&#x27;</span>, <span class=\"hljs-string\">&#x27;2024-02-01&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n<li>物理数据独立性 <strong>Physical Data Independence</strong> <ul>\n<li>指的是允许用户在不影响数据库逻辑结构的情况下, 改变物理存储方式.</li>\n<li>比如数据存储的位置, 索引结构等的改变.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>Data Definition Language (<strong>DDL</strong>) </p>\n<ul>\n<li>作用: 定义数据库的结构, 包括表, 索引, 视图等;</li>\n<li>e.g:<ul>\n<li>基本表的结构定义:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> instructor (<br>    ID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),           <span class=\"hljs-comment\">-- 固定长度5个字符</span><br>    name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),     <span class=\"hljs-comment\">-- 可变长度，最多20个字符</span><br>    dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>)   <span class=\"hljs-comment\">-- 总长8位，小数点后2位</span><br>);<br></code></pre></td></tr></table></figure></li>\n<li>完整性约束:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> instructor (<br>        ID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">PRIMARY KEY</span>,  <span class=\"hljs-comment\">-- 主键约束</span><br>        name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT NULL</span>,  <span class=\"hljs-comment\">-- 非空约束</span><br>        dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">REFERENCES</span> department(dept_name),  <span class=\"hljs-comment\">-- 外键约束</span><br>        salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">CHECK</span> (salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>)  <span class=\"hljs-comment\">-- 值约束</span><br>    );<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用DDL创建数据库对象时, 上述的定义将会被存储在称为数据字典(<strong>Data dictionary</strong>)的结构当中, 包括以下元数据:</p>\n<ul>\n<li>模式信息</li>\n<li>完整性约束<ul>\n<li>主键, 引用完整性, 值约束</li>\n</ul>\n</li>\n<li>授权信息  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 授权示例</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">ON</span> instructor <span class=\"hljs-keyword\">TO</span> user1;<br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">UPDATE</span> (salary) <span class=\"hljs-keyword\">ON</span> instructor <span class=\"hljs-keyword\">TO</span> payroll_admin;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>Data Manipulation Language (<strong>DML</strong>)</p>\n<ul>\n<li>指的是用于处理和操纵对应模型的数据的语言;</li>\n<li>根据是否需要用户声明 <code>how to get those data</code>分为 <strong>two classes</strong>:<ul>\n<li><strong>Procedural</strong> : 需要声明;</li>\n<li><strong>Declarative</strong>: 无需声明<ul>\n<li>SQL 就是其中被广泛应用的类型之一.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Relational-Model\"><a href=\"#Relational-Model\" class=\"headerlink\" title=\"Relational Model\"></a>Relational Model</h1><p>基本概念:</p>\n<ul>\n<li>属性(attribute) 也就是列;</li>\n<li>元组(tuple) 也就是行;</li>\n<li>$R = (A_1,A_2,\\dots,A_n)$ 为关系的范式;</li>\n<li><code>NULL</code>表示未知, 而非不存在. 是所有类型属性的值域的一员.</li>\n</ul>\n<h2 id=\"keys\"><a href=\"#keys\" class=\"headerlink\" title=\"keys\"></a>keys</h2><p><strong>superkey</strong>: </p>\n<ul>\n<li>定义: values for K are sufficient to identify a unique tuple of each possible relation r(R) $\\Longrightarrow$ K is a  ~(超键) of R.</li>\n<li>超键在推断的时候, 可能存在冗余的属性.</li>\n</ul>\n<p><strong>candidate key</strong>(候选键): 超键K is <strong>minimal</strong> $\\Rightarrow$ K is ~</p>\n<p><strong>primary key</strong>(主键): 我们从候选键中选择一个key作为主键.</p>\n<p><strong>foreign key</strong>(外键): </p>\n<ul>\n<li>R1 的一个或一组列的值(的范围)与 R2 的主键值(的范围)相匹配<br>$\\Rightarrow$ R1 的这个或这组列，称为指向 R2 的外键。</li>\n</ul>\n<p><strong>Referential Integrity Constraint</strong>: </p>\n<ul>\n<li>即 参照完整性约束;</li>\n<li>指 引用关系表R1以被引用关系表R2, R1的外键的值必须在R2中存在.</li>\n<li><em>e.g</em>  存在订单表和客户表, 订单表中的“客户ID”列是外键，它引用客户表中的“客户ID”列(主键), 要求订单表中的“客户ID”值必须在客户表中存在.</li>\n</ul>\n<hr>\n<h2 id=\"Relational-algebra\"><a href=\"#Relational-algebra\" class=\"headerlink\" title=\"Relational algebra\"></a>Relational algebra</h2><p>关系代数(relational algebra), 元组关系演算(tuple relational calculus), 域关系演算(domain relational calculus) 相互等价. 我们将重点关注<strong>关系代数</strong>.</p>\n<h3 id=\"Basic-Op\"><a href=\"#Basic-Op\" class=\"headerlink\" title=\"Basic Op.\"></a>Basic Op.</h3><p>关系代数包含以下六种基本操作:</p>\n<ul>\n<li><strong><em>select</em></strong> $\\sigma$: 选取满足条件的元组;<ul>\n<li>$\\sigma _{\\rho}(r)$, 其中$\\rho$由一系列的<code>term</code>在 $\\wedge$,$\\vee$,$\\neg$的符号连接下组成.</li>\n<li><code>term</code>由列与列(或常值)的比较运算得到;</li>\n<li>e.g: <script type=\"math/tex\">\\sigma _{salary\\ >\\ 30000}(instructor)</script></li>\n</ul>\n</li>\n<li><strong><em>project</em></strong> $\\pi$ : 投影以选取指定的属性;<ul>\n<li>$\\pi_{A,B}(R)$: 只保留R中的A,B列;</li>\n</ul>\n</li>\n<li><strong><em>union</em></strong> $\\cup$: 将不同的关系相结合<ul>\n<li><strong>要求</strong>: 不同关系的属性数量和对应的类型保持一致;</li>\n<li><strong>结果</strong>: 自动<strong>去除重复</strong>的元组.</li>\n</ul>\n</li>\n<li><strong><em>rename</em></strong> $\\rho$: 用于重命名属性或者表名;<ul>\n<li>$\\rho_{(A_1, \\dots, A_n)}(R)$: 将R中的属性重命名为$A_1,\\dots,A_n$;</li>\n<li>$\\rho_{R_1}(R_2)$: 将R_2的表名重命名为R_1;</li>\n<li>$\\rho_{S(B1,B2,…,Bn)}(R)$  — 将关系R重命名为S，并重命名其属性</li>\n</ul>\n</li>\n<li><strong><em>set difference</em></strong> $-$: 在一个关系中删除另一个关系中存在的元组;<ul>\n<li><strong>要求</strong>: 关系相容, 即具有相同的属性个数和类型</li>\n<li>如果两个关系有相同的属性, 则将其重命名为不同的名称;</li>\n</ul>\n</li>\n<li><strong><em>cartesian product</em></strong> $\\times$: 笛卡尔积, 将不同表格中的数据进行组合匹配<ul>\n<li><strong>结果</strong>: 属性数量是二者之和, 元组数量是二者之积</li>\n<li>可以事先对参与计算的表进行$\\sigma$ 等计算, 减小计算成本.</li>\n</ul>\n</li>\n</ul>\n<p><strong>e.g</strong></p>\n<ul>\n<li><p>Find all courses taught in the Fall 2009 semester,but<br><strong>not in</strong> the Spring 2010 semester:</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{course\\_id}(\\sigma_{semester=\"Fall\"\\  \\wedge \\ year = 2009}(section)) - \\\\\n\\pi_{course\\_id}(\\sigma_{semester=\"spring\"\\  \\wedge \\ year = 2010}(section))</script></li>\n<li><p>Find the largest salary in the university</p>\n<ul>\n<li><strong>Step1</strong>: 将员工表重命名为<code>d</code>然后与自身<code>i</code>进行笛卡尔积, 得到的元组, 筛选出<code>i</code>的工资较少的元组集合, 利用 $\\pi$ 投影获得工资部分<br><img src=\"assets/2025-02-22-17-27-31.png\" alt=\"\"><blockquote>\n<p>去除了工资本身最大的元组</p>\n</blockquote>\n</li>\n<li><strong>Step2</strong>: 对原表投影得到工资部分, 然后对第一步得到的集合取差<br><img src=\"assets/2025-02-22-17-31-07.png\" alt=\"\"></li>\n<li><strong>可视化:</strong><br><img src=\"assets/2025-02-22-17-32-24.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Additional-Op\"><a href=\"#Additional-Op\" class=\"headerlink\" title=\"Additional Op.\"></a>Additional Op.</h3><p>关系代数包含以下扩展操作：</p>\n<ul>\n<li><p><strong><em>set intersection</em></strong> $\\cap$：获取两个关系的公共元组</p>\n<ul>\n<li><strong>要求</strong>：关系相容，具有相同的属性结构</li>\n<li><strong>结果</strong>：包含同时出现在两个关系中的元组</li>\n<li>e.g: $r \\cap s$ 表示同时存在于r和s中的元组</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nr \\cap s = r -(r-s)</script></li>\n</ul>\n<ul>\n<li><p><strong><em>natural join</em></strong> $\\bowtie$：基于<strong>共同属性</strong>的自动连接</p>\n<ul>\n<li>识别并匹配具有相同名称的属性, 结果中只选取相同名称属性<strong>对应值相等</strong>的部分;</li>\n<li>其他连接的“满足连接条件”指的就是自然连接$\\bowtie $ </li>\n</ul>\n<p>e.g. </p>\n<p><img src=\"数据库系统.assets/image-20250224214646008.png\" alt=\"image-20250224214646008\" style=\"zoom:50%;\" /></p>\n<ul>\n<li><strong>theta join</strong>:  $r \\bowtie<em>\\theta s := \\sigma</em>\\theta (r \\times s)$ , 先对作笛卡尔积, 然后取用满足条件$\\theta$的部分.    </li>\n</ul>\n</li>\n<li><p><strong><em>semijoin</em></strong> $\\ltimes$：半连接操作</p>\n<ul>\n<li>结果仅保留<strong>左表中</strong>满足连接条件的元组</li>\n<li>属性仅包含左表的所有属性</li>\n<li>e.g: $student \\ltimes takes$ 返回选过课的<strong>学生信息</strong></li>\n<li>$ r \\ltimes<em>\\theta s := \\pi_R(r\\bowtie</em>\\theta s)$</li>\n</ul>\n</li>\n<li><p><strong><em>assignment</em></strong> $\\leftarrow$：将查询结果赋值给临时关系</p>\n<ul>\n<li>用于简化复杂查询</li>\n<li>可以重复使用中间结果</li>\n<li>e.g: $temp \\leftarrow \\pi_{ID,name}(instructor)$</li>\n</ul>\n</li>\n<li><p><strong><em>outer join</em></strong>：<strong>保留未匹配</strong>元组的连接操作, 避免信息缺失(均在$\\bowtie$的基础上, 即笛卡尔积的结果)</p>\n<ul>\n<li>左外连接 $\\leftarrow\\bowtie$：保留左表未匹配的元组</li>\n<li>右外连接 $\\bowtie\\rightarrow$：保留右表未匹配的元组</li>\n<li>全外连接 $\\leftarrow\\bowtie\\rightarrow$：保留两表中未匹配的元组</li>\n<li>未匹配的属性值<strong>填充NULL</strong></li>\n<li>e.g. <img src=\"数据库系统.assets/image-20250224220313846.png\" alt=\"image-20250224220313846\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p><strong><em>division</em></strong> $\\div$： $ r \\div s$ </p>\n<ul>\n<li>用于查找满足所有条件的元组</li>\n<li>更具体地说, 寻找r中的tuple使得与s关系的所有元组的笛卡尔积都在r中;</li>\n<li><strong>要求</strong>: $s \\sub r$ </li>\n</ul>\n<blockquote>\n<p>[!note]</p>\n<p><img src=\"数据库系统.assets/image-20250225121938529.png\" alt=\"image-20250224223816689\" style=\"zoom:50%; float: left;\" /></p>\n</blockquote>\n<p><strong>e.g.</strong> </p>\n<p><img src=\"数据库系统.assets/image-20250224221730846.png\" alt=\"image-20250224221730846\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n<h3 id=\"Aggregate\"><a href=\"#Aggregate\" class=\"headerlink\" title=\"Aggregate\"></a>Aggregate</h3><p><strong>聚合函数</strong>: avg, min, max, sum ,count.</p>\n<ul>\n<li>除了<code>count</code>, 其他函数对于<strong>属性的类型</strong>有要求(可以计算).</li>\n</ul>\n<p><strong>聚合操作</strong>: $<em>{G_1,G_2\\dots}\\mathcal{G}</em>{F_i(A_i)}(E)$ </p>\n<ul>\n<li>$G_i$是待聚合的属性, 可以为空;</li>\n<li>$F_i$是聚合函数, $A_i$是属性名.</li>\n</ul>\n<p>e.g.:</p>\n<p><img src=\"数据库系统.assets/image-20250224224824019.png\" alt=\"image-20250224224824019\" style=\"zoom:50%;\" /></p>\n<p>由于聚合操作得到的列没有自己的名字, 为了方便起见, SQL允许我们直接使用关键字<code>as</code>来快速<code>rename</code>. 比如对于上述在表<code>instructor</code>上的聚合操作, 将结果命名为<code>avg_sal</code>的指令:</p>\n<script type=\"math/tex; mode=display\">\n_{dept\\_name}\\ \\mathcal{G}_{avg(salary)\\ as \\ avg\\_sal}(instructor)</script><h3 id=\"Multiset\"><a href=\"#Multiset\" class=\"headerlink\" title=\"Multiset\"></a>Multiset</h3><p>pure relational algebra 中不存在重复的元组.</p>\n<p>但是在多重集(multiset)当中允许元组重复. </p>\n<ul>\n<li><p>多重集的关系代数:</p>\n<ul>\n<li>选择: 即使给出一个元组, 也选中所有符合条件的元组;</li>\n<li>投影: 同理;</li>\n<li><strong>cross product:</strong> 也会将重复的元组多次计算.<ul>\n<li>m copies of t1 in r, and n copies of t2 in s , then $ m \\times n$ copies of t1.t2 in $r \\times s$ .</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他操作:</p>\n<ul>\n<li><strong>union</strong>: m + n copies;</li>\n<li><strong>intersection</strong>: min(m, n) copies;</li>\n<li><strong>difference</strong>: min(0, m-n) copies.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><h3 id=\"Domain-Types\"><a href=\"#Domain-Types\" class=\"headerlink\" title=\"Domain Types\"></a>Domain Types</h3><ul>\n<li>Char(n): 定长字符串，用户指定长度为 n。</li>\n<li>Varchar(n): 变长字符串，用户指定最大长度为 n。</li>\n<li>Int: 整数 (机器相关的整数的有限子集)。</li>\n<li>Smallint: 小整数 (机器相关的整数域子集)。</li>\n<li>Numeric(p,d): 定点数，用户指定精度，总共 p 位数字，其中小数点后 d 位。 例如：number(3,1) 允许精确存储 44.5，但不允许 444.5 或 0.32。</li>\n<li>Real, Double precision: 浮点数和双精度浮点数，精度与机器相关。</li>\n<li>Float(n): 浮点数，用户指定至少 n 位数字的精度。</li>\n</ul>\n<p>关于时间的类型:</p>\n<ul>\n<li>Date: 日期，包含（4 位数）年份、月份和日期。例如：date ‘2005-7-27’</li>\n<li>Time: 一天中的时间，以小时、分钟和秒为单位。例如：time ‘09:00:30’  time ‘09:00:30.75’</li>\n<li>Timestamp: 日期加上一天中的时间。例如：timestamp ‘2005-7-27 09:00:30.75’</li>\n<li>Interval: 一段时间。例如：interval ‘1’ day。从另一个日期/时间/时间戳值中减去一个日期/时间/时间戳值会得到一个 interval 值。Interval 值可以添加到日期/时间/时间戳值。</li>\n<li>Date, time 函数:<ul>\n<li>current_date()</li>\n<li>current_time()</li>\n<li>year(x), month(x), day(x), hour(x), minute(x), second(x)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Common-Operations\"><a href=\"#Common-Operations\" class=\"headerlink\" title=\"Common Operations\"></a>Common Operations</h2><h3 id=\"1-创建表-CREATE-TABLE\"><a href=\"#1-创建表-CREATE-TABLE\" class=\"headerlink\" title=\"1. 创建表 (CREATE TABLE)\"></a>1. 创建表 (CREATE TABLE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> table_name (<br>    column1 datatype <span class=\"hljs-keyword\">constraint</span>,<br>    column2 datatype <span class=\"hljs-keyword\">constraint</span>,<br>    column3 datatype,<br>    ....<br>);<br></code></pre></td></tr></table></figure>\n<p><strong>e.g.:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> Employees (<br>    EmployeeID <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    FirstName <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT NULL</span>,<br>    LastName <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>),<br>    Salary <span class=\"hljs-type\">decimal</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>),<br>    HireDate <span class=\"hljs-type\">date</span><br>);<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>Employees</code>: 表名</li>\n<li><code>EmployeeID</code>: 列名，<code>int</code> 类型，<code>PRIMARY KEY</code> (主键)</li>\n<li><code>FirstName</code>: 列名，<code>varchar(255)</code> 类型，<code>NOT NULL</code> (非空约束)</li>\n<li><code>Salary</code>: 列名，<code>decimal(10, 2)</code> 类型 (总共 10 位数字，小数点后 2 位)</li>\n<li><code>HireDate</code>: 列名，<code>date</code> 类型</li>\n</ul>\n<h3 id=\"2-插入数据-INSERT-INTO\"><a href=\"#2-插入数据-INSERT-INTO\" class=\"headerlink\" title=\"2. 插入数据 (INSERT INTO)\"></a>2. 插入数据 (INSERT INTO)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> table_name (column1, column2, column3, ...)<br><span class=\"hljs-keyword\">VALUES</span> (value1, value2, value3, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> Employees (EmployeeID, FirstName, LastName, Salary, HireDate)<br><span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;John&#x27;</span>, <span class=\"hljs-string\">&#x27;Doe&#x27;</span>, <span class=\"hljs-number\">60000.00</span>, <span class=\"hljs-string\">&#x27;2023-01-15&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-查询数据-SELECT\"><a href=\"#3-查询数据-SELECT\" class=\"headerlink\" title=\"3. 查询数据 (SELECT)\"></a>3. 查询数据 (SELECT)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> column1, column2, ...<br><span class=\"hljs-keyword\">FROM</span> table_name<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;  <span class=\"hljs-comment\">-- 可选</span><br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> FirstName, LastName, Salary<br><span class=\"hljs-keyword\">FROM</span> Employees<br><span class=\"hljs-keyword\">WHERE</span> Salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">50000</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>选择 <code>Employees</code> 表中 <code>Salary</code> 大于 50000 的员工的 <code>FirstName</code>, <code>LastName</code>, 和 <code>Salary</code>。</li>\n</ul>\n<h3 id=\"4-更新数据-UPDATE\"><a href=\"#4-更新数据-UPDATE\" class=\"headerlink\" title=\"4. 更新数据 (UPDATE)\"></a>4. 更新数据 (UPDATE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">UPDATE</span> table_name<br><span class=\"hljs-keyword\">SET</span> column1 <span class=\"hljs-operator\">=</span> value1, column2 <span class=\"hljs-operator\">=</span> value2, ...<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">UPDATE</span> Employees<br><span class=\"hljs-keyword\">SET</span> Salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">65000.00</span><br><span class=\"hljs-keyword\">WHERE</span> EmployeeID <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>将 <code>EmployeeID</code> 为 1 的员工的 <code>Salary</code> 更新为 65000.00。</li>\n</ul>\n<h3 id=\"5-删除数据-DELETE\"><a href=\"#5-删除数据-DELETE\" class=\"headerlink\" title=\"5. 删除数据 (DELETE)\"></a>5. 删除数据 (DELETE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> table_name<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> Employees<br><span class=\"hljs-keyword\">WHERE</span> EmployeeID <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>删除 <code>EmployeeID</code> 为 1 的员工记录.</li>\n</ul>\n<h3 id=\"6-修改表结构-ALTER-TABLE\"><a href=\"#6-修改表结构-ALTER-TABLE\" class=\"headerlink\" title=\"6. 修改表结构 (ALTER TABLE)\"></a>6. 修改表结构 (ALTER TABLE)</h3><p><strong>语法 (添加列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">ADD</span> column_name datatype <span class=\"hljs-keyword\">constraint</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>语法 (修改列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">COLUMN</span> column_name datatype;  <br></code></pre></td></tr></table></figure>\n<p><strong>语法 (删除列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">COLUMN</span> column_name; <br></code></pre></td></tr></table></figure>\n<p><strong>示例 (添加列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">ADD</span> Department <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>);<br></code></pre></td></tr></table></figure>\n<p><strong>示例 (修改列 - SQL Server):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">COLUMN</span> Department <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p><strong>示例 (删除列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">COLUMN</span> Department;<br></code></pre></td></tr></table></figure>\n<h3 id=\"7-删除表-DROP-TABLE\"><a href=\"#7-删除表-DROP-TABLE\" class=\"headerlink\" title=\"7. 删除表 (DROP TABLE)\"></a>7. 删除表 (DROP TABLE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> Employees;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>删除名为 <code>Employees</code> 的表.</li>\n</ul>\n<p>除此之外, 如果我们希望保留表的结构, 只是删除表内部的内容, 可以使用<code>drop from table_name</code>.</p>\n<h3 id=\"8-常用约束-Constraints\"><a href=\"#8-常用约束-Constraints\" class=\"headerlink\" title=\"8. 常用约束 (Constraints)\"></a>8. 常用约束 (Constraints)</h3><ul>\n<li><code>PRIMARY KEY</code>:  唯一标识表中每一行的列。</li>\n<li><code>NOT NULL</code>:  确保列不能包含 NULL 值。</li>\n<li><code>UNIQUE</code>:  确保列中的所有值都是不同的。</li>\n<li><code>FOREIGN KEY</code>:  在一个表中引用另一个表中的 PRIMARY KEY。</li>\n<li><code>CHECK</code>:  限制可以放入列中的值的范围。</li>\n<li><code>DEFAULT</code>:  如果在没有指定值的情况下插入行，则设置列的默认值。</li>\n</ul>\n<p>e.g. </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create table</span> instructor(<br>\tID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>  name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">not null</span>,<br>  dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>  salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span>,<br>  <span class=\"hljs-keyword\">primary key</span> (ID),<br>  <span class=\"hljs-keyword\">foreign key</span>(dept_name) <span class=\"hljs-keyword\">references</span> department<br>);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将主键简写成: <code>ID char(5) primary key,</code></p>\n</blockquote>\n<p>e.g. 外键的约束:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">foreign key</span>(dept_name) <span class=\"hljs-keyword\">references</span> department)<br>\t<span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span> cascade <br>\t<span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> cascade,<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>cascade</code>表示当<code>department</code>表当中的对应条目被删除/更新时, 同样删除/更新<code>course</code>表中的内容;</p>\n<p>此外, 还有其他的约束条件可供选择: <code>set null</code>和<code>set default</code>分别表示操作之后将其设置为空或者默认值; <code>restrict</code>表示限制操作(避免存在于<code>course</code>中的条目在<code>department</code>当中被删除或者更新).</p>\n</blockquote>\n<h3 id=\"9-索引-INDEX\"><a href=\"#9-索引-INDEX\" class=\"headerlink\" title=\"9. 索引 (INDEX)\"></a>9. 索引 (INDEX)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX index_name<br><span class=\"hljs-keyword\">ON</span> table_name (column1, column2, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX idx_lastname<br><span class=\"hljs-keyword\">ON</span> Employees (LastName);<br></code></pre></td></tr></table></figure>\n<ul>\n<li>在 <code>Employees</code> 表的 <code>LastName</code> 列上创建一个名为 <code>idx_lastname</code> 的索引，以提高查询效率。</li>\n</ul>\n<h2 id=\"Query-Structure\"><a href=\"#Query-Structure\" class=\"headerlink\" title=\"Query Structure\"></a>Query Structure</h2><p>DML( data-manipulation language ) 允许我们对元组进行增删改查的操作:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> A1,A2...<br><span class=\"hljs-keyword\">from</span> r1, r2...<br><span class=\"hljs-keyword\">where</span> P<br></code></pre></td></tr></table></figure>\n<p>其中, $A_i$ 表示属性, $R_i$表示关系, $P$表示约束条件.</p>\n<blockquote>\n<p>SQL的name对于大小写<strong>不敏感</strong>.</p>\n</blockquote>\n<ul>\n<li><p><code>select</code>: 选择操作对应于关系代数中的<strong>投影</strong></p>\n<ul>\n<li>使用<code>select distinct</code>消除结果中的重复元组(<code>all</code>则强调不移除);</li>\n<li><code>select *</code>表示投影获得全部的属性;</li>\n<li>属性中支持基本的四则运算: <code>select salary/2</code>;</li>\n</ul>\n</li>\n<li><p><code>from</code>: 列出语句中涉及的关系, 对应于关系代数中的<strong>笛卡尔积</strong></p>\n<ul>\n<li>可以使用声明<code>natural join</code>, 也即是将关系根据相同属性的值进行组合.<br>e.g.<br><img src=\"数据库系统.assets/image-20250228111935730.png\" alt=\"image-20250228111935730\" style=\"zoom:30%;\" /></li>\n<li></li>\n</ul>\n</li>\n<li><p><code>where</code>: 对应于关系代数中的选择 $\\sigma$ </p>\n<ul>\n<li><p>使用 <code>and</code>,<code>or</code>,<code>not</code>对应逻辑运算;</p>\n</li>\n<li><p>支持只用<code>between</code>进行比较运算, <code>&lt;&gt;</code>表示不相等;</p>\n<p>e.g: <code>where salary between 3000 and 4000</code>.</p>\n</li>\n<li><p>同样支持<strong>元组</strong>的比较:</p>\n<p>e.g:   <img src=\"数据库系统.assets/image-20250228111447627.png\" alt=\"image-20250228111447627\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h2><h3 id=\"Rename\"><a href=\"#Rename\" class=\"headerlink\" title=\"Rename\"></a>Rename</h3><ul>\n<li><code>as</code>: 使用~进行重命名操作<ul>\n<li>可以忽略关键字<code>as</code> (i.e <code>instructor as T</code>等价于<code>instructor T</code>) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>SQL为字符串匹配设置了<code>%</code>和<code>_</code>操作, 需要与<code>like</code>搭配使用:</p>\n<ul>\n<li><code>%</code>: 匹配任意字符串;</li>\n<li><code>_</code>: 匹配任意的<strong>字符</strong></li>\n</ul>\n<blockquote>\n<p>如果字符串中包含了实际的 <code>%</code> 或 <code>_</code> 字符，可以使用 <code>ESCAPE</code> 关键字指定一个转义字符，用于转义这些特殊字符.</p>\n</blockquote>\n<p>e.g. 名字当中包含了子串<code>dar</code>: </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">where</span> name <span class=\"hljs-keyword\">like</span>  <span class=\"hljs-string\">&#x27;%dar%&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>e.g. 匹配字符串 “100 %” 的几种方法 (假设转义字符为 <code>\\</code> 和 <code>#</code>):</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 \\\\%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;\\\\&#x27;</span>  <span class=\"hljs-comment\">-- 使用反斜杠作为转义字符</span><br><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 %&#x27;</span>                <span class=\"hljs-comment\">-- 如果数据库支持直接匹配，或者百分号不需要转义</span><br><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 #%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;#&#x27;</span>    <span class=\"hljs-comment\">-- 使用井号作为转义字符</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<p>组合使用的例子:</p>\n<ul>\n<li>恰好有3个字符的字符串: <code>_ _ _</code></li>\n<li>至少有3个字符的字符串: <code>_ _ _ %</code></li>\n</ul>\n<h3 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a><code>Order</code></h3><p>使用关键字<code>order</code>可以帮助我们将得到的元组进行按照属性的字典序进行排序:</p>\n<ul>\n<li><code>order by name</code>: 按照名称的字典序排序;</li>\n<li><p>可以使用<code>desc</code>和<code>asc</code>分别强调按照降序和升序来排序:<br>e.g. <code>order by name desc</code></p>\n</li>\n<li><p>支持组合的排序: <code>order by dept_name, name</code>.</p>\n</li>\n</ul>\n<h3 id=\"Limit\"><a href=\"#Limit\" class=\"headerlink\" title=\"Limit\"></a><code>Limit</code></h3><ul>\n<li><strong>作用:</strong> 用于限制 <code>SELECT</code> 语句返回的行数;</li>\n<li><p><strong>参数:</strong> 接受一个或两个数字参数，必须是非负整数常量。</p>\n<ul>\n<li><code>LIMIT row_count</code>:  返回从结果集开始的前 <code>row_count</code> 行。</li>\n<li><code>LIMIT offset, row_count</code>: 从结果集的 <code>offset</code> 行开始（<code>offset</code>从 0 开始计数），返回 <code>row_count</code> 行。  等价于 <code>LIMIT row_count OFFSET offset</code>。</li>\n</ul>\n</li>\n<li><p><strong>等价关系:</strong> <code>LIMIT row_count</code> 等价于 <code>LIMIT 0, row_count</code>;</p>\n</li>\n</ul>\n<p><strong>e.g.:</strong> 列出薪水最高的 3 位 instructors 的姓名:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> salary <span class=\"hljs-keyword\">DESC</span><br>LIMIT <span class=\"hljs-number\">3</span>;   <span class=\"hljs-comment\">-- 等价于 LIMIT 0, 3;</span><br></code></pre></td></tr></table></figure>\n<p><strong>要点总结:</strong></p>\n<ul>\n<li><code>LIMIT</code> 用于分页显示数据，或者只获取结果集中的一部分数据。</li>\n<li><code>OFFSET</code> 指定起始位置，<code>row_count</code> 指定返回的行数。</li>\n<li>通常与 <code>order by</code> 子句一起使用，以确保返回的是排序后的结果集的前几行。</li>\n</ul>\n<p><strong>补充说明:</strong></p>\n<ul>\n<li>在没有 <code>ORDER BY</code> 子句的情况下使用 <code>LIMIT</code>，结果的顺序是不确定的.</li>\n<li><code>LIMIT</code> 可以显著提高查询性能，特别是当处理大型数据集时.</li>\n</ul>\n<blockquote>\n<p>P31</p>\n</blockquote>\n<h1 id=\"笔记缓冲区\"><a href=\"#笔记缓冲区\" class=\"headerlink\" title=\"笔记缓冲区\"></a>笔记缓冲区</h1><h3 id=\"Domain\"><a href=\"#Domain\" class=\"headerlink\" title=\"Domain\"></a>Domain</h3><p>当某些列需要限制其取值范围, 也就是具有一定的约束条件时, 如果每次创建类似的列都重复书写, 工作量较大.</p>\n<p><code>domain</code>可以理解为对数据类型的<strong>扩展定义</strong>，它允许我们<strong>创建自定义</strong>的数据类型，并且可以为其指定约束条件。使用 domain 可以确保数据的一致性，</p>\n<ul>\n<li>基本语法</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> DOMAIN 域名 数据类型<br>[<span class=\"hljs-keyword\">DEFAULT</span> 默认值]<br>[<span class=\"hljs-keyword\">CONSTRAINT</span> 约束名称]<br>[<span class=\"hljs-keyword\">CHECK</span> (约束条件)];<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>e.g. </p>\n<ul>\n<li>```sql<br>— 创建一个表示年龄的域<br>CREATE DOMAIN age_type INTEGER<br>CONSTRAINT valid_age<br>CHECK (VALUE &gt;= 0 AND VALUE &lt;= 150);<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><br>- 使用:<br><br>```<span class=\"hljs-keyword\">sql</span><br><span class=\"hljs-comment\">-- 1. 首先创建一个域</span><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">15</span>)<br><span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check<br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">VALUE</span> ~ <span class=\"hljs-string\">&#x27;^\\d&#123;11&#125;$&#x27;</span>);  <span class=\"hljs-comment\">-- 初始约束：只允许11位数字</span><br><br><span class=\"hljs-comment\">-- 2. 创建使用该域的表</span><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> customers (<br>    id <span class=\"hljs-type\">SERIAL</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    <span class=\"hljs-type\">name</span> <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    phone phone_number<br>);<br><br><span class=\"hljs-comment\">-- 3. 插入一些数据</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;13812345678&#x27;</span>);  <span class=\"hljs-comment\">-- 成功</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;138-1234-5678&#x27;</span>);  <span class=\"hljs-comment\">-- 失败，因为包含破折号</span><br><br><span class=\"hljs-comment\">-- 4. 如果我们想修改约束，允许带破折号的电话号码格式</span><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number <br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check;  <span class=\"hljs-comment\">-- 首先删除旧的约束</span><br><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number<br><span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check    <span class=\"hljs-comment\">-- 添加新的约束</span><br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">VALUE</span> ~ <span class=\"hljs-string\">&#x27;^\\d&#123;3&#125;(-?\\d&#123;4&#125;)&#123;2&#125;$&#x27;</span>);  <span class=\"hljs-comment\">-- 新格式：允许有破折号</span><br><br><span class=\"hljs-comment\">-- 现在可以插入带破折号的电话号码了</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;138-1234-5678&#x27;</span>);  <span class=\"hljs-comment\">-- 成功</span><br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>由此可见, 约束名称的定义方便我们后续对<code>domain</code>的维护.</p>\n</blockquote>\n<h3 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h3><p>如果要经常查询大型表格中的某列属性, 可以为其添加索引(<code>index</code>). </p>\n<ul>\n<li>语法:    </li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX index_name <span class=\"hljs-keyword\">ON</span> table_name(column1, column2, ...);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> index_name 是索引的名称，table_name 是要建立索引的表，括号中是要建立索引的列名.</p>\n</blockquote>\n<ul>\n<li>作用方式:<ul>\n<li>根据给出的列, 将其构造成B+树等数据结构, 每个节点的key是属性值, value是在原表中的行的指针.</li>\n<li>因此, 将原本的线性搜索O(n)时间成本降低为了O(log n).</li>\n</ul>\n</li>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建表结构 --</span><br><span class=\"hljs-keyword\">CREATE TABLE</span> students (<br>    id <span class=\"hljs-type\">INT</span>,<br>    name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>),<br>    email <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>)<br>);<br><br><span class=\"hljs-comment\">-- 插入一些数据</span><br><span class=\"hljs-keyword\">INSERT INTO</span> students <span class=\"hljs-keyword\">VALUES</span> <br>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;zhang@zju.edu.cn&#x27;</span>),<br>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;li@zju.edu.cn&#x27;</span>),<br>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;王五&#x27;</span>, <span class=\"hljs-string\">&#x27;wang@zju.edu.cn&#x27;</span>);<br><br><span class=\"hljs-comment\">-- 创建索引 --</span><br><span class=\"hljs-keyword\">CREATE</span> INDEX idx_email <span class=\"hljs-keyword\">ON</span> students(email);<br><br><span class=\"hljs-comment\">-- 此时的索引内部结构 --</span><br>           li<span class=\"hljs-variable\">@zju</span>.edu.cn<br>          <span class=\"hljs-operator\">/</span>              \\<br>    zhang<span class=\"hljs-variable\">@zju</span>.edu.cn    wang<span class=\"hljs-variable\">@zju</span>.edu.cn<br><br><span class=\"hljs-comment\">-- 执行查询 --</span><br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> students <span class=\"hljs-keyword\">WHERE</span> email <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;zhang@zju.edu.cn&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Assertion\"><a href=\"#Assertion\" class=\"headerlink\" title=\"Assertion\"></a>Assertion</h3><p>Assertion(断言): 是数据库中的完整性约束机制, 用于<strong>预先定义</strong>数据库中必须始终满足的条件.</p>\n<p>e.g:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> assertion credits_constaint <span class=\"hljs-keyword\">check</span> (<br>    <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span>(<br>        <span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span><br>        <span class=\"hljs-keyword\">from</span> student S<br>        <span class=\"hljs-keyword\">where</span> total_cred <span class=\"hljs-operator\">&lt;&gt;</span> (<br>            <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">sum</span>(credits)<br>            <span class=\"hljs-keyword\">from</span> takes <span class=\"hljs-keyword\">natural</span> <span class=\"hljs-keyword\">join</span> course<br>            <span class=\"hljs-keyword\">where</span> takes.ID <span class=\"hljs-operator\">=</span> S.ID <br>                <span class=\"hljs-keyword\">and</span> grade <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not null</span> <br>                <span class=\"hljs-keyword\">and</span> grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span><br>        )<br>    )<br>)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>在最外层，通过<code>create assertion</code>语句创建断言并使用<code>not exists</code>确保没有违规记录；中间层主要关注学生表中的总学分字段；而最内层则通过复杂的子查询来计算学生实际获得的有效学分总和(成绩存在且不为<code>false</code>).</p>\n<p><code>&lt;&gt;</code>表示不等于.</p>\n</blockquote>\n<p>虽然断言是一个强大的数据完整性保证机制，但MySQL并不支持这一特性。这主要是出于性能考虑：断言需要在相关表发生变化时进行复杂的检查，这可能会显著影响数据库的操作效率。作为替代方案，MySQL通常会使用<strong>触发器（trigger）</strong>来实现类似的功能。</p>\n<h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><ul>\n<li>语法:</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">trigger</span> trigger_name before<span class=\"hljs-operator\">/</span>after trigger_event <span class=\"hljs-keyword\">of</span> table_name <span class=\"hljs-keyword\">on</span> attribute<br><span class=\"hljs-keyword\">referencing</span> xxx<br><span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">each</span> <span class=\"hljs-type\">row</span><br><span class=\"hljs-keyword\">when</span> xxxx<br><span class=\"hljs-keyword\">begin</span> <br>xxxx(<span class=\"hljs-keyword\">SQL</span> operation)<br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h3><ol>\n<li><strong>权限控制的重要性</strong></li>\n</ol>\n<p>在数据库系统中，不同用户往往需要不同级别的访问权限。例如，普通员工可能只需要查询权限，而部门主管可能需要更新数据的权限。为了确保数据安全和隐私保护，数据库系统提供了完善的权限控制机制，包括读取(read)、插入(insert)、更新(update)和删除(delete)这四种基本权限。</p>\n<ol>\n<li><strong>基本授权语法</strong></li>\n</ol>\n<p>SQL提供了灵活的授权语句来管理用户权限。最基本的授权使用<code>GRANT</code>语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-operator\">&lt;</span>privilege_list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation_name <span class=\"hljs-keyword\">or</span> view_name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-operator\">&lt;</span>user_list<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>这里的<code>&lt;user_list&gt;</code>既可以是具体的用户名，也可以是关键字<code>PUBLIC</code>（表示授权给所有用户）。特别地，当我们需要允许用户具有转授权的能力时，可以在授权语句末尾添加<code>WITH GRANT OPTION</code>子句。</p>\n<ol>\n<li><strong>权限管理的高级特性</strong></li>\n</ol>\n<p>为了更灵活地管理权限，SQL还提供了权限回收机制和角色管理：</p>\n<ul>\n<li>权限回收使用<code>REVOKE</code>语句：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-operator\">&lt;</span>privilege_list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation_name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-operator\">&lt;</span>user_list<span class=\"hljs-operator\">&gt;</span> [RESTRICT<span class=\"hljs-operator\">|</span>CASCADE]<br></code></pre></td></tr></table></figure>\n<p>其中<code>RESTRICT</code>表示仅回收<strong>直接授予</strong>的权限，而<code>CASCADE</code>则会同时回收该用户<strong>转授给其他</strong>用户的权限。</p>\n<ul>\n<li>角色管理通过<code>CREATE ROLE</code>实现：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> ROLE manager;<br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">ON</span> employees <span class=\"hljs-keyword\">TO</span> manager;<br><span class=\"hljs-keyword\">GRANT</span> manager <span class=\"hljs-keyword\">TO</span> user1, user2;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><strong>实际应用示例</strong></li>\n</ol>\n<p>假设我们正在管理一个大学教务系统，可能会有如下权限设置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建教师角色</span><br><span class=\"hljs-keyword\">CREATE</span> ROLE teacher;<br><br><span class=\"hljs-comment\">-- 给教师角色授予查看和修改成绩的权限</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">ON</span> student_grades <span class=\"hljs-keyword\">TO</span> teacher;<br><br><span class=\"hljs-comment\">-- 给具体教师授予角色</span><br><span class=\"hljs-keyword\">GRANT</span> teacher <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;prof_zhang&#x27;</span>, <span class=\"hljs-string\">&#x27;prof_li&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 给教务主管额外的权限，并允许其转授权限</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> PRIVILEGES <span class=\"hljs-keyword\">ON</span> student_grades <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;academic_dean&#x27;</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">GRANT</span> OPTION;<br><br><span class=\"hljs-comment\">-- 如果教师离职，收回其权限</span><br><span class=\"hljs-keyword\">REVOKE</span> teacher <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">&#x27;prof_zhang&#x27;</span> CASCADE;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ALL PRIVILEGES</code>表示授予所有的权限.</p>\n</blockquote>\n","more":"<h1 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h1><p><img src=\"数据库系统.assets/image-20250225103821388.png\" alt=\"image-20250225103821388\" style=\"zoom:50%;\" /></p>\n<p>概念:</p>\n<ul>\n<li><strong>DBMS</strong>: database-management system, </li>\n<li><strong>Different levels</strong> <ul>\n<li>Physical:  数据如何存储;</li>\n<li>Logical: data如何在数据库中组织(内部关系)<figure class=\"highlight pascal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pascal\"><span class=\"hljs-keyword\">type</span> instructor = <span class=\"hljs-keyword\">record</span><br>    ID: <span class=\"hljs-keyword\">string</span>;        <span class=\"hljs-comment\">// ID字段，字符串类型</span><br>    <span class=\"hljs-keyword\">name</span>: <span class=\"hljs-keyword\">string</span>;      <span class=\"hljs-comment\">// 姓名字段，字符串类型</span><br>    dept_name: <span class=\"hljs-keyword\">string</span>; <span class=\"hljs-comment\">// 部门名称字段，字符串类型</span><br>    salary: integer;   <span class=\"hljs-comment\">// 薪资字段，整数类型</span><br><span class=\"hljs-keyword\">end</span>;<br></code></pre></td></tr></table></figure></li>\n<li>View: 可以根据用户需求定义可见的数据结构;</li>\n</ul>\n</li>\n</ul>\n<p><strong>Data Models</strong></p>\n<ul>\n<li>Relational model: 关系型数据库;</li>\n<li>Entity-Relationship data model(E-R) : 实体-关系型数据库;<ul>\n<li>实体是现实世界中可区分的对象, 属性是实体的特征描述;</li>\n</ul>\n</li>\n<li>Object-based data models : 对象型数据库;</li>\n<li>Semistructured data model(<strong>XML</strong> 和 <strong>JSON</strong>) : 半结构化数据库;<ul>\n<li>灵活性体现在: 嵌套结构, 可选字段, 混合类型等.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Instances and Schemas</strong></p>\n<ul>\n<li>模式 <strong>Schema</strong> : 数据的组织方式<ul>\n<li>逻辑模式 Logical Schema: 对数据库结构的描述;<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> Customer (<br>    customer_id <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    email <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    registration_date <span class=\"hljs-type\">DATE</span><br>);<br></code></pre></td></tr></table></figure></li>\n<li>物理模式 Physical Schema: 描述数据实际存储的方式;<ul>\n<li>比如使用的索引结构(B+树, 哈希表等), 缓冲区的管理策略等.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实例 <strong>Instance</strong>: 实际存储的数据  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> Customer <span class=\"hljs-keyword\">VALUES</span><br>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;zhang@email.com&#x27;</span>, <span class=\"hljs-string\">&#x27;2024-01-15&#x27;</span>),<br>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;li@email.com&#x27;</span>, <span class=\"hljs-string\">&#x27;2024-02-01&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n<li>物理数据独立性 <strong>Physical Data Independence</strong> <ul>\n<li>指的是允许用户在不影响数据库逻辑结构的情况下, 改变物理存储方式.</li>\n<li>比如数据存储的位置, 索引结构等的改变.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>Data Definition Language (<strong>DDL</strong>) </p>\n<ul>\n<li>作用: 定义数据库的结构, 包括表, 索引, 视图等;</li>\n<li>e.g:<ul>\n<li>基本表的结构定义:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> instructor (<br>    ID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),           <span class=\"hljs-comment\">-- 固定长度5个字符</span><br>    name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),     <span class=\"hljs-comment\">-- 可变长度，最多20个字符</span><br>    dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>)   <span class=\"hljs-comment\">-- 总长8位，小数点后2位</span><br>);<br></code></pre></td></tr></table></figure></li>\n<li>完整性约束:<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> instructor (<br>        ID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">PRIMARY KEY</span>,  <span class=\"hljs-comment\">-- 主键约束</span><br>        name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT NULL</span>,  <span class=\"hljs-comment\">-- 非空约束</span><br>        dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">REFERENCES</span> department(dept_name),  <span class=\"hljs-comment\">-- 外键约束</span><br>        salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">CHECK</span> (salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>)  <span class=\"hljs-comment\">-- 值约束</span><br>    );<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>使用DDL创建数据库对象时, 上述的定义将会被存储在称为数据字典(<strong>Data dictionary</strong>)的结构当中, 包括以下元数据:</p>\n<ul>\n<li>模式信息</li>\n<li>完整性约束<ul>\n<li>主键, 引用完整性, 值约束</li>\n</ul>\n</li>\n<li>授权信息  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 授权示例</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">ON</span> instructor <span class=\"hljs-keyword\">TO</span> user1;<br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">UPDATE</span> (salary) <span class=\"hljs-keyword\">ON</span> instructor <span class=\"hljs-keyword\">TO</span> payroll_admin;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<p>Data Manipulation Language (<strong>DML</strong>)</p>\n<ul>\n<li>指的是用于处理和操纵对应模型的数据的语言;</li>\n<li>根据是否需要用户声明 <code>how to get those data</code>分为 <strong>two classes</strong>:<ul>\n<li><strong>Procedural</strong> : 需要声明;</li>\n<li><strong>Declarative</strong>: 无需声明<ul>\n<li>SQL 就是其中被广泛应用的类型之一.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Relational-Model\"><a href=\"#Relational-Model\" class=\"headerlink\" title=\"Relational Model\"></a>Relational Model</h1><p>基本概念:</p>\n<ul>\n<li>属性(attribute) 也就是列;</li>\n<li>元组(tuple) 也就是行;</li>\n<li>$R = (A_1,A_2,\\dots,A_n)$ 为关系的范式;</li>\n<li><code>NULL</code>表示未知, 而非不存在. 是所有类型属性的值域的一员.</li>\n</ul>\n<h2 id=\"keys\"><a href=\"#keys\" class=\"headerlink\" title=\"keys\"></a>keys</h2><p><strong>superkey</strong>: </p>\n<ul>\n<li>定义: values for K are sufficient to identify a unique tuple of each possible relation r(R) $\\Longrightarrow$ K is a  ~(超键) of R.</li>\n<li>超键在推断的时候, 可能存在冗余的属性.</li>\n</ul>\n<p><strong>candidate key</strong>(候选键): 超键K is <strong>minimal</strong> $\\Rightarrow$ K is ~</p>\n<p><strong>primary key</strong>(主键): 我们从候选键中选择一个key作为主键.</p>\n<p><strong>foreign key</strong>(外键): </p>\n<ul>\n<li>R1 的一个或一组列的值(的范围)与 R2 的主键值(的范围)相匹配<br>$\\Rightarrow$ R1 的这个或这组列，称为指向 R2 的外键。</li>\n</ul>\n<p><strong>Referential Integrity Constraint</strong>: </p>\n<ul>\n<li>即 参照完整性约束;</li>\n<li>指 引用关系表R1以被引用关系表R2, R1的外键的值必须在R2中存在.</li>\n<li><em>e.g</em>  存在订单表和客户表, 订单表中的“客户ID”列是外键，它引用客户表中的“客户ID”列(主键), 要求订单表中的“客户ID”值必须在客户表中存在.</li>\n</ul>\n<hr>\n<h2 id=\"Relational-algebra\"><a href=\"#Relational-algebra\" class=\"headerlink\" title=\"Relational algebra\"></a>Relational algebra</h2><p>关系代数(relational algebra), 元组关系演算(tuple relational calculus), 域关系演算(domain relational calculus) 相互等价. 我们将重点关注<strong>关系代数</strong>.</p>\n<h3 id=\"Basic-Op\"><a href=\"#Basic-Op\" class=\"headerlink\" title=\"Basic Op.\"></a>Basic Op.</h3><p>关系代数包含以下六种基本操作:</p>\n<ul>\n<li><strong><em>select</em></strong> $\\sigma$: 选取满足条件的元组;<ul>\n<li>$\\sigma _{\\rho}(r)$, 其中$\\rho$由一系列的<code>term</code>在 $\\wedge$,$\\vee$,$\\neg$的符号连接下组成.</li>\n<li><code>term</code>由列与列(或常值)的比较运算得到;</li>\n<li>e.g: <script type=\"math/tex\">\\sigma _{salary\\ >\\ 30000}(instructor)</script></li>\n</ul>\n</li>\n<li><strong><em>project</em></strong> $\\pi$ : 投影以选取指定的属性;<ul>\n<li>$\\pi_{A,B}(R)$: 只保留R中的A,B列;</li>\n</ul>\n</li>\n<li><strong><em>union</em></strong> $\\cup$: 将不同的关系相结合<ul>\n<li><strong>要求</strong>: 不同关系的属性数量和对应的类型保持一致;</li>\n<li><strong>结果</strong>: 自动<strong>去除重复</strong>的元组.</li>\n</ul>\n</li>\n<li><strong><em>rename</em></strong> $\\rho$: 用于重命名属性或者表名;<ul>\n<li>$\\rho_{(A_1, \\dots, A_n)}(R)$: 将R中的属性重命名为$A_1,\\dots,A_n$;</li>\n<li>$\\rho_{R_1}(R_2)$: 将R_2的表名重命名为R_1;</li>\n<li>$\\rho_{S(B1,B2,…,Bn)}(R)$  — 将关系R重命名为S，并重命名其属性</li>\n</ul>\n</li>\n<li><strong><em>set difference</em></strong> $-$: 在一个关系中删除另一个关系中存在的元组;<ul>\n<li><strong>要求</strong>: 关系相容, 即具有相同的属性个数和类型</li>\n<li>如果两个关系有相同的属性, 则将其重命名为不同的名称;</li>\n</ul>\n</li>\n<li><strong><em>cartesian product</em></strong> $\\times$: 笛卡尔积, 将不同表格中的数据进行组合匹配<ul>\n<li><strong>结果</strong>: 属性数量是二者之和, 元组数量是二者之积</li>\n<li>可以事先对参与计算的表进行$\\sigma$ 等计算, 减小计算成本.</li>\n</ul>\n</li>\n</ul>\n<p><strong>e.g</strong></p>\n<ul>\n<li><p>Find all courses taught in the Fall 2009 semester,but<br><strong>not in</strong> the Spring 2010 semester:</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{course\\_id}(\\sigma_{semester=\"Fall\"\\  \\wedge \\ year = 2009}(section)) - \\\\\n\\pi_{course\\_id}(\\sigma_{semester=\"spring\"\\  \\wedge \\ year = 2010}(section))</script></li>\n<li><p>Find the largest salary in the university</p>\n<ul>\n<li><strong>Step1</strong>: 将员工表重命名为<code>d</code>然后与自身<code>i</code>进行笛卡尔积, 得到的元组, 筛选出<code>i</code>的工资较少的元组集合, 利用 $\\pi$ 投影获得工资部分<br><img src=\"assets/2025-02-22-17-27-31.png\" alt=\"\"><blockquote>\n<p>去除了工资本身最大的元组</p>\n</blockquote>\n</li>\n<li><strong>Step2</strong>: 对原表投影得到工资部分, 然后对第一步得到的集合取差<br><img src=\"assets/2025-02-22-17-31-07.png\" alt=\"\"></li>\n<li><strong>可视化:</strong><br><img src=\"assets/2025-02-22-17-32-24.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Additional-Op\"><a href=\"#Additional-Op\" class=\"headerlink\" title=\"Additional Op.\"></a>Additional Op.</h3><p>关系代数包含以下扩展操作：</p>\n<ul>\n<li><p><strong><em>set intersection</em></strong> $\\cap$：获取两个关系的公共元组</p>\n<ul>\n<li><strong>要求</strong>：关系相容，具有相同的属性结构</li>\n<li><strong>结果</strong>：包含同时出现在两个关系中的元组</li>\n<li>e.g: $r \\cap s$ 表示同时存在于r和s中的元组</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nr \\cap s = r -(r-s)</script></li>\n</ul>\n<ul>\n<li><p><strong><em>natural join</em></strong> $\\bowtie$：基于<strong>共同属性</strong>的自动连接</p>\n<ul>\n<li>识别并匹配具有相同名称的属性, 结果中只选取相同名称属性<strong>对应值相等</strong>的部分;</li>\n<li>其他连接的“满足连接条件”指的就是自然连接$\\bowtie $ </li>\n</ul>\n<p>e.g. </p>\n<p><img src=\"数据库系统.assets/image-20250224214646008.png\" alt=\"image-20250224214646008\" style=\"zoom:50%;\" /></p>\n<ul>\n<li><strong>theta join</strong>:  $r \\bowtie<em>\\theta s := \\sigma</em>\\theta (r \\times s)$ , 先对作笛卡尔积, 然后取用满足条件$\\theta$的部分.    </li>\n</ul>\n</li>\n<li><p><strong><em>semijoin</em></strong> $\\ltimes$：半连接操作</p>\n<ul>\n<li>结果仅保留<strong>左表中</strong>满足连接条件的元组</li>\n<li>属性仅包含左表的所有属性</li>\n<li>e.g: $student \\ltimes takes$ 返回选过课的<strong>学生信息</strong></li>\n<li>$ r \\ltimes<em>\\theta s := \\pi_R(r\\bowtie</em>\\theta s)$</li>\n</ul>\n</li>\n<li><p><strong><em>assignment</em></strong> $\\leftarrow$：将查询结果赋值给临时关系</p>\n<ul>\n<li>用于简化复杂查询</li>\n<li>可以重复使用中间结果</li>\n<li>e.g: $temp \\leftarrow \\pi_{ID,name}(instructor)$</li>\n</ul>\n</li>\n<li><p><strong><em>outer join</em></strong>：<strong>保留未匹配</strong>元组的连接操作, 避免信息缺失(均在$\\bowtie$的基础上, 即笛卡尔积的结果)</p>\n<ul>\n<li>左外连接 $\\leftarrow\\bowtie$：保留左表未匹配的元组</li>\n<li>右外连接 $\\bowtie\\rightarrow$：保留右表未匹配的元组</li>\n<li>全外连接 $\\leftarrow\\bowtie\\rightarrow$：保留两表中未匹配的元组</li>\n<li>未匹配的属性值<strong>填充NULL</strong></li>\n<li>e.g. <img src=\"数据库系统.assets/image-20250224220313846.png\" alt=\"image-20250224220313846\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p><strong><em>division</em></strong> $\\div$： $ r \\div s$ </p>\n<ul>\n<li>用于查找满足所有条件的元组</li>\n<li>更具体地说, 寻找r中的tuple使得与s关系的所有元组的笛卡尔积都在r中;</li>\n<li><strong>要求</strong>: $s \\sub r$ </li>\n</ul>\n<blockquote>\n<p>[!note]</p>\n<p><img src=\"数据库系统.assets/image-20250225121938529.png\" alt=\"image-20250224223816689\" style=\"zoom:50%; float: left;\" /></p>\n</blockquote>\n<p><strong>e.g.</strong> </p>\n<p><img src=\"数据库系统.assets/image-20250224221730846.png\" alt=\"image-20250224221730846\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n<h3 id=\"Aggregate\"><a href=\"#Aggregate\" class=\"headerlink\" title=\"Aggregate\"></a>Aggregate</h3><p><strong>聚合函数</strong>: avg, min, max, sum ,count.</p>\n<ul>\n<li>除了<code>count</code>, 其他函数对于<strong>属性的类型</strong>有要求(可以计算).</li>\n</ul>\n<p><strong>聚合操作</strong>: $<em>{G_1,G_2\\dots}\\mathcal{G}</em>{F_i(A_i)}(E)$ </p>\n<ul>\n<li>$G_i$是待聚合的属性, 可以为空;</li>\n<li>$F_i$是聚合函数, $A_i$是属性名.</li>\n</ul>\n<p>e.g.:</p>\n<p><img src=\"数据库系统.assets/image-20250224224824019.png\" alt=\"image-20250224224824019\" style=\"zoom:50%;\" /></p>\n<p>由于聚合操作得到的列没有自己的名字, 为了方便起见, SQL允许我们直接使用关键字<code>as</code>来快速<code>rename</code>. 比如对于上述在表<code>instructor</code>上的聚合操作, 将结果命名为<code>avg_sal</code>的指令:</p>\n<script type=\"math/tex; mode=display\">\n_{dept\\_name}\\ \\mathcal{G}_{avg(salary)\\ as \\ avg\\_sal}(instructor)</script><h3 id=\"Multiset\"><a href=\"#Multiset\" class=\"headerlink\" title=\"Multiset\"></a>Multiset</h3><p>pure relational algebra 中不存在重复的元组.</p>\n<p>但是在多重集(multiset)当中允许元组重复. </p>\n<ul>\n<li><p>多重集的关系代数:</p>\n<ul>\n<li>选择: 即使给出一个元组, 也选中所有符合条件的元组;</li>\n<li>投影: 同理;</li>\n<li><strong>cross product:</strong> 也会将重复的元组多次计算.<ul>\n<li>m copies of t1 in r, and n copies of t2 in s , then $ m \\times n$ copies of t1.t2 in $r \\times s$ .</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他操作:</p>\n<ul>\n<li><strong>union</strong>: m + n copies;</li>\n<li><strong>intersection</strong>: min(m, n) copies;</li>\n<li><strong>difference</strong>: min(0, m-n) copies.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h1><h3 id=\"Domain-Types\"><a href=\"#Domain-Types\" class=\"headerlink\" title=\"Domain Types\"></a>Domain Types</h3><ul>\n<li>Char(n): 定长字符串，用户指定长度为 n。</li>\n<li>Varchar(n): 变长字符串，用户指定最大长度为 n。</li>\n<li>Int: 整数 (机器相关的整数的有限子集)。</li>\n<li>Smallint: 小整数 (机器相关的整数域子集)。</li>\n<li>Numeric(p,d): 定点数，用户指定精度，总共 p 位数字，其中小数点后 d 位。 例如：number(3,1) 允许精确存储 44.5，但不允许 444.5 或 0.32。</li>\n<li>Real, Double precision: 浮点数和双精度浮点数，精度与机器相关。</li>\n<li>Float(n): 浮点数，用户指定至少 n 位数字的精度。</li>\n</ul>\n<p>关于时间的类型:</p>\n<ul>\n<li>Date: 日期，包含（4 位数）年份、月份和日期。例如：date ‘2005-7-27’</li>\n<li>Time: 一天中的时间，以小时、分钟和秒为单位。例如：time ‘09:00:30’  time ‘09:00:30.75’</li>\n<li>Timestamp: 日期加上一天中的时间。例如：timestamp ‘2005-7-27 09:00:30.75’</li>\n<li>Interval: 一段时间。例如：interval ‘1’ day。从另一个日期/时间/时间戳值中减去一个日期/时间/时间戳值会得到一个 interval 值。Interval 值可以添加到日期/时间/时间戳值。</li>\n<li>Date, time 函数:<ul>\n<li>current_date()</li>\n<li>current_time()</li>\n<li>year(x), month(x), day(x), hour(x), minute(x), second(x)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Common-Operations\"><a href=\"#Common-Operations\" class=\"headerlink\" title=\"Common Operations\"></a>Common Operations</h2><h3 id=\"1-创建表-CREATE-TABLE\"><a href=\"#1-创建表-CREATE-TABLE\" class=\"headerlink\" title=\"1. 创建表 (CREATE TABLE)\"></a>1. 创建表 (CREATE TABLE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> table_name (<br>    column1 datatype <span class=\"hljs-keyword\">constraint</span>,<br>    column2 datatype <span class=\"hljs-keyword\">constraint</span>,<br>    column3 datatype,<br>    ....<br>);<br></code></pre></td></tr></table></figure>\n<p><strong>e.g.:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE TABLE</span> Employees (<br>    EmployeeID <span class=\"hljs-type\">int</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    FirstName <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-keyword\">NOT NULL</span>,<br>    LastName <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>),<br>    Salary <span class=\"hljs-type\">decimal</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>),<br>    HireDate <span class=\"hljs-type\">date</span><br>);<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>Employees</code>: 表名</li>\n<li><code>EmployeeID</code>: 列名，<code>int</code> 类型，<code>PRIMARY KEY</code> (主键)</li>\n<li><code>FirstName</code>: 列名，<code>varchar(255)</code> 类型，<code>NOT NULL</code> (非空约束)</li>\n<li><code>Salary</code>: 列名，<code>decimal(10, 2)</code> 类型 (总共 10 位数字，小数点后 2 位)</li>\n<li><code>HireDate</code>: 列名，<code>date</code> 类型</li>\n</ul>\n<h3 id=\"2-插入数据-INSERT-INTO\"><a href=\"#2-插入数据-INSERT-INTO\" class=\"headerlink\" title=\"2. 插入数据 (INSERT INTO)\"></a>2. 插入数据 (INSERT INTO)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> table_name (column1, column2, column3, ...)<br><span class=\"hljs-keyword\">VALUES</span> (value1, value2, value3, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">INSERT INTO</span> Employees (EmployeeID, FirstName, LastName, Salary, HireDate)<br><span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;John&#x27;</span>, <span class=\"hljs-string\">&#x27;Doe&#x27;</span>, <span class=\"hljs-number\">60000.00</span>, <span class=\"hljs-string\">&#x27;2023-01-15&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"3-查询数据-SELECT\"><a href=\"#3-查询数据-SELECT\" class=\"headerlink\" title=\"3. 查询数据 (SELECT)\"></a>3. 查询数据 (SELECT)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> column1, column2, ...<br><span class=\"hljs-keyword\">FROM</span> table_name<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;  <span class=\"hljs-comment\">-- 可选</span><br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> FirstName, LastName, Salary<br><span class=\"hljs-keyword\">FROM</span> Employees<br><span class=\"hljs-keyword\">WHERE</span> Salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">50000</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>选择 <code>Employees</code> 表中 <code>Salary</code> 大于 50000 的员工的 <code>FirstName</code>, <code>LastName</code>, 和 <code>Salary</code>。</li>\n</ul>\n<h3 id=\"4-更新数据-UPDATE\"><a href=\"#4-更新数据-UPDATE\" class=\"headerlink\" title=\"4. 更新数据 (UPDATE)\"></a>4. 更新数据 (UPDATE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">UPDATE</span> table_name<br><span class=\"hljs-keyword\">SET</span> column1 <span class=\"hljs-operator\">=</span> value1, column2 <span class=\"hljs-operator\">=</span> value2, ...<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">UPDATE</span> Employees<br><span class=\"hljs-keyword\">SET</span> Salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">65000.00</span><br><span class=\"hljs-keyword\">WHERE</span> EmployeeID <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>将 <code>EmployeeID</code> 为 1 的员工的 <code>Salary</code> 更新为 65000.00。</li>\n</ul>\n<h3 id=\"5-删除数据-DELETE\"><a href=\"#5-删除数据-DELETE\" class=\"headerlink\" title=\"5. 删除数据 (DELETE)\"></a>5. 删除数据 (DELETE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> table_name<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> Employees<br><span class=\"hljs-keyword\">WHERE</span> EmployeeID <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>删除 <code>EmployeeID</code> 为 1 的员工记录.</li>\n</ul>\n<h3 id=\"6-修改表结构-ALTER-TABLE\"><a href=\"#6-修改表结构-ALTER-TABLE\" class=\"headerlink\" title=\"6. 修改表结构 (ALTER TABLE)\"></a>6. 修改表结构 (ALTER TABLE)</h3><p><strong>语法 (添加列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">ADD</span> column_name datatype <span class=\"hljs-keyword\">constraint</span>;<br></code></pre></td></tr></table></figure>\n<p><strong>语法 (修改列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">COLUMN</span> column_name datatype;  <br></code></pre></td></tr></table></figure>\n<p><strong>语法 (删除列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> table_name<br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">COLUMN</span> column_name; <br></code></pre></td></tr></table></figure>\n<p><strong>示例 (添加列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">ADD</span> Department <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>);<br></code></pre></td></tr></table></figure>\n<p><strong>示例 (修改列 - SQL Server):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">COLUMN</span> Department <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">100</span>);<br></code></pre></td></tr></table></figure>\n<p><strong>示例 (删除列):</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">ALTER TABLE</span> Employees<br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">COLUMN</span> Department;<br></code></pre></td></tr></table></figure>\n<h3 id=\"7-删除表-DROP-TABLE\"><a href=\"#7-删除表-DROP-TABLE\" class=\"headerlink\" title=\"7. 删除表 (DROP TABLE)\"></a>7. 删除表 (DROP TABLE)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">TABLE</span> Employees;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>删除名为 <code>Employees</code> 的表.</li>\n</ul>\n<p>除此之外, 如果我们希望保留表的结构, 只是删除表内部的内容, 可以使用<code>drop from table_name</code>.</p>\n<h3 id=\"8-常用约束-Constraints\"><a href=\"#8-常用约束-Constraints\" class=\"headerlink\" title=\"8. 常用约束 (Constraints)\"></a>8. 常用约束 (Constraints)</h3><ul>\n<li><code>PRIMARY KEY</code>:  唯一标识表中每一行的列。</li>\n<li><code>NOT NULL</code>:  确保列不能包含 NULL 值。</li>\n<li><code>UNIQUE</code>:  确保列中的所有值都是不同的。</li>\n<li><code>FOREIGN KEY</code>:  在一个表中引用另一个表中的 PRIMARY KEY。</li>\n<li><code>CHECK</code>:  限制可以放入列中的值的范围。</li>\n<li><code>DEFAULT</code>:  如果在没有指定值的情况下插入行，则设置列的默认值。</li>\n</ul>\n<p>e.g. </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create table</span> instructor(<br>\tID <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>  name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">not null</span>,<br>  dept_name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>  salary <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">default</span> <span class=\"hljs-number\">0</span>,<br>  <span class=\"hljs-keyword\">primary key</span> (ID),<br>  <span class=\"hljs-keyword\">foreign key</span>(dept_name) <span class=\"hljs-keyword\">references</span> department<br>);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将主键简写成: <code>ID char(5) primary key,</code></p>\n</blockquote>\n<p>e.g. 外键的约束:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">foreign key</span>(dept_name) <span class=\"hljs-keyword\">references</span> department)<br>\t<span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">delete</span> cascade <br>\t<span class=\"hljs-keyword\">on</span> <span class=\"hljs-keyword\">update</span> cascade,<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>cascade</code>表示当<code>department</code>表当中的对应条目被删除/更新时, 同样删除/更新<code>course</code>表中的内容;</p>\n<p>此外, 还有其他的约束条件可供选择: <code>set null</code>和<code>set default</code>分别表示操作之后将其设置为空或者默认值; <code>restrict</code>表示限制操作(避免存在于<code>course</code>中的条目在<code>department</code>当中被删除或者更新).</p>\n</blockquote>\n<h3 id=\"9-索引-INDEX\"><a href=\"#9-索引-INDEX\" class=\"headerlink\" title=\"9. 索引 (INDEX)\"></a>9. 索引 (INDEX)</h3><p><strong>语法:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX index_name<br><span class=\"hljs-keyword\">ON</span> table_name (column1, column2, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX idx_lastname<br><span class=\"hljs-keyword\">ON</span> Employees (LastName);<br></code></pre></td></tr></table></figure>\n<ul>\n<li>在 <code>Employees</code> 表的 <code>LastName</code> 列上创建一个名为 <code>idx_lastname</code> 的索引，以提高查询效率。</li>\n</ul>\n<h2 id=\"Query-Structure\"><a href=\"#Query-Structure\" class=\"headerlink\" title=\"Query Structure\"></a>Query Structure</h2><p>DML( data-manipulation language ) 允许我们对元组进行增删改查的操作:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> A1,A2...<br><span class=\"hljs-keyword\">from</span> r1, r2...<br><span class=\"hljs-keyword\">where</span> P<br></code></pre></td></tr></table></figure>\n<p>其中, $A_i$ 表示属性, $R_i$表示关系, $P$表示约束条件.</p>\n<blockquote>\n<p>SQL的name对于大小写<strong>不敏感</strong>.</p>\n</blockquote>\n<ul>\n<li><p><code>select</code>: 选择操作对应于关系代数中的<strong>投影</strong></p>\n<ul>\n<li>使用<code>select distinct</code>消除结果中的重复元组(<code>all</code>则强调不移除);</li>\n<li><code>select *</code>表示投影获得全部的属性;</li>\n<li>属性中支持基本的四则运算: <code>select salary/2</code>;</li>\n</ul>\n</li>\n<li><p><code>from</code>: 列出语句中涉及的关系, 对应于关系代数中的<strong>笛卡尔积</strong></p>\n<ul>\n<li>可以使用声明<code>natural join</code>, 也即是将关系根据相同属性的值进行组合.<br>e.g.<br><img src=\"数据库系统.assets/image-20250228111935730.png\" alt=\"image-20250228111935730\" style=\"zoom:30%;\" /></li>\n<li></li>\n</ul>\n</li>\n<li><p><code>where</code>: 对应于关系代数中的选择 $\\sigma$ </p>\n<ul>\n<li><p>使用 <code>and</code>,<code>or</code>,<code>not</code>对应逻辑运算;</p>\n</li>\n<li><p>支持只用<code>between</code>进行比较运算, <code>&lt;&gt;</code>表示不相等;</p>\n<p>e.g: <code>where salary between 3000 and 4000</code>.</p>\n</li>\n<li><p>同样支持<strong>元组</strong>的比较:</p>\n<p>e.g:   <img src=\"数据库系统.assets/image-20250228111447627.png\" alt=\"image-20250228111447627\" style=\"zoom:50%;\" /></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Other\"><a href=\"#Other\" class=\"headerlink\" title=\"Other\"></a>Other</h2><h3 id=\"Rename\"><a href=\"#Rename\" class=\"headerlink\" title=\"Rename\"></a>Rename</h3><ul>\n<li><code>as</code>: 使用~进行重命名操作<ul>\n<li>可以忽略关键字<code>as</code> (i.e <code>instructor as T</code>等价于<code>instructor T</code>) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>SQL为字符串匹配设置了<code>%</code>和<code>_</code>操作, 需要与<code>like</code>搭配使用:</p>\n<ul>\n<li><code>%</code>: 匹配任意字符串;</li>\n<li><code>_</code>: 匹配任意的<strong>字符</strong></li>\n</ul>\n<blockquote>\n<p>如果字符串中包含了实际的 <code>%</code> 或 <code>_</code> 字符，可以使用 <code>ESCAPE</code> 关键字指定一个转义字符，用于转义这些特殊字符.</p>\n</blockquote>\n<p>e.g. 名字当中包含了子串<code>dar</code>: </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">where</span> name <span class=\"hljs-keyword\">like</span>  <span class=\"hljs-string\">&#x27;%dar%&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>e.g. 匹配字符串 “100 %” 的几种方法 (假设转义字符为 <code>\\</code> 和 <code>#</code>):</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 \\\\%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;\\\\&#x27;</span>  <span class=\"hljs-comment\">-- 使用反斜杠作为转义字符</span><br><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 %&#x27;</span>                <span class=\"hljs-comment\">-- 如果数据库支持直接匹配，或者百分号不需要转义</span><br><span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100 #%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;#&#x27;</span>    <span class=\"hljs-comment\">-- 使用井号作为转义字符</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<p>组合使用的例子:</p>\n<ul>\n<li>恰好有3个字符的字符串: <code>_ _ _</code></li>\n<li>至少有3个字符的字符串: <code>_ _ _ %</code></li>\n</ul>\n<h3 id=\"Order\"><a href=\"#Order\" class=\"headerlink\" title=\"Order\"></a><code>Order</code></h3><p>使用关键字<code>order</code>可以帮助我们将得到的元组进行按照属性的字典序进行排序:</p>\n<ul>\n<li><code>order by name</code>: 按照名称的字典序排序;</li>\n<li><p>可以使用<code>desc</code>和<code>asc</code>分别强调按照降序和升序来排序:<br>e.g. <code>order by name desc</code></p>\n</li>\n<li><p>支持组合的排序: <code>order by dept_name, name</code>.</p>\n</li>\n</ul>\n<h3 id=\"Limit\"><a href=\"#Limit\" class=\"headerlink\" title=\"Limit\"></a><code>Limit</code></h3><ul>\n<li><strong>作用:</strong> 用于限制 <code>SELECT</code> 语句返回的行数;</li>\n<li><p><strong>参数:</strong> 接受一个或两个数字参数，必须是非负整数常量。</p>\n<ul>\n<li><code>LIMIT row_count</code>:  返回从结果集开始的前 <code>row_count</code> 行。</li>\n<li><code>LIMIT offset, row_count</code>: 从结果集的 <code>offset</code> 行开始（<code>offset</code>从 0 开始计数），返回 <code>row_count</code> 行。  等价于 <code>LIMIT row_count OFFSET offset</code>。</li>\n</ul>\n</li>\n<li><p><strong>等价关系:</strong> <code>LIMIT row_count</code> 等价于 <code>LIMIT 0, row_count</code>;</p>\n</li>\n</ul>\n<p><strong>e.g.:</strong> 列出薪水最高的 3 位 instructors 的姓名:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> salary <span class=\"hljs-keyword\">DESC</span><br>LIMIT <span class=\"hljs-number\">3</span>;   <span class=\"hljs-comment\">-- 等价于 LIMIT 0, 3;</span><br></code></pre></td></tr></table></figure>\n<p><strong>要点总结:</strong></p>\n<ul>\n<li><code>LIMIT</code> 用于分页显示数据，或者只获取结果集中的一部分数据。</li>\n<li><code>OFFSET</code> 指定起始位置，<code>row_count</code> 指定返回的行数。</li>\n<li>通常与 <code>order by</code> 子句一起使用，以确保返回的是排序后的结果集的前几行。</li>\n</ul>\n<p><strong>补充说明:</strong></p>\n<ul>\n<li>在没有 <code>ORDER BY</code> 子句的情况下使用 <code>LIMIT</code>，结果的顺序是不确定的.</li>\n<li><code>LIMIT</code> 可以显著提高查询性能，特别是当处理大型数据集时.</li>\n</ul>\n<blockquote>\n<p>P31</p>\n</blockquote>\n<h1 id=\"笔记缓冲区\"><a href=\"#笔记缓冲区\" class=\"headerlink\" title=\"笔记缓冲区\"></a>笔记缓冲区</h1><h3 id=\"Domain\"><a href=\"#Domain\" class=\"headerlink\" title=\"Domain\"></a>Domain</h3><p>当某些列需要限制其取值范围, 也就是具有一定的约束条件时, 如果每次创建类似的列都重复书写, 工作量较大.</p>\n<p><code>domain</code>可以理解为对数据类型的<strong>扩展定义</strong>，它允许我们<strong>创建自定义</strong>的数据类型，并且可以为其指定约束条件。使用 domain 可以确保数据的一致性，</p>\n<ul>\n<li>基本语法</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> DOMAIN 域名 数据类型<br>[<span class=\"hljs-keyword\">DEFAULT</span> 默认值]<br>[<span class=\"hljs-keyword\">CONSTRAINT</span> 约束名称]<br>[<span class=\"hljs-keyword\">CHECK</span> (约束条件)];<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>e.g. </p>\n<ul>\n<li>```sql<br>— 创建一个表示年龄的域<br>CREATE DOMAIN age_type INTEGER<br>CONSTRAINT valid_age<br>CHECK (VALUE &gt;= 0 AND VALUE &lt;= 150);<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><br>- 使用:<br><br>```<span class=\"hljs-keyword\">sql</span><br><span class=\"hljs-comment\">-- 1. 首先创建一个域</span><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">15</span>)<br><span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check<br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">VALUE</span> ~ <span class=\"hljs-string\">&#x27;^\\d&#123;11&#125;$&#x27;</span>);  <span class=\"hljs-comment\">-- 初始约束：只允许11位数字</span><br><br><span class=\"hljs-comment\">-- 2. 创建使用该域的表</span><br><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> customers (<br>    id <span class=\"hljs-type\">SERIAL</span> <span class=\"hljs-keyword\">PRIMARY KEY</span>,<br>    <span class=\"hljs-type\">name</span> <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>),<br>    phone phone_number<br>);<br><br><span class=\"hljs-comment\">-- 3. 插入一些数据</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;13812345678&#x27;</span>);  <span class=\"hljs-comment\">-- 成功</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;138-1234-5678&#x27;</span>);  <span class=\"hljs-comment\">-- 失败，因为包含破折号</span><br><br><span class=\"hljs-comment\">-- 4. 如果我们想修改约束，允许带破折号的电话号码格式</span><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number <br><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check;  <span class=\"hljs-comment\">-- 首先删除旧的约束</span><br><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">DOMAIN</span> phone_number<br><span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">CONSTRAINT</span> phone_format_check    <span class=\"hljs-comment\">-- 添加新的约束</span><br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">VALUE</span> ~ <span class=\"hljs-string\">&#x27;^\\d&#123;3&#125;(-?\\d&#123;4&#125;)&#123;2&#125;$&#x27;</span>);  <span class=\"hljs-comment\">-- 新格式：允许有破折号</span><br><br><span class=\"hljs-comment\">-- 现在可以插入带破折号的电话号码了</span><br><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> customers (<span class=\"hljs-type\">name</span>, phone) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;138-1234-5678&#x27;</span>);  <span class=\"hljs-comment\">-- 成功</span><br><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>由此可见, 约束名称的定义方便我们后续对<code>domain</code>的维护.</p>\n</blockquote>\n<h3 id=\"Index\"><a href=\"#Index\" class=\"headerlink\" title=\"Index\"></a>Index</h3><p>如果要经常查询大型表格中的某列属性, 可以为其添加索引(<code>index</code>). </p>\n<ul>\n<li>语法:    </li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> INDEX index_name <span class=\"hljs-keyword\">ON</span> table_name(column1, column2, ...);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p> index_name 是索引的名称，table_name 是要建立索引的表，括号中是要建立索引的列名.</p>\n</blockquote>\n<ul>\n<li>作用方式:<ul>\n<li>根据给出的列, 将其构造成B+树等数据结构, 每个节点的key是属性值, value是在原表中的行的指针.</li>\n<li>因此, 将原本的线性搜索O(n)时间成本降低为了O(log n).</li>\n</ul>\n</li>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建表结构 --</span><br><span class=\"hljs-keyword\">CREATE TABLE</span> students (<br>    id <span class=\"hljs-type\">INT</span>,<br>    name <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">50</span>),<br>    email <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">100</span>)<br>);<br><br><span class=\"hljs-comment\">-- 插入一些数据</span><br><span class=\"hljs-keyword\">INSERT INTO</span> students <span class=\"hljs-keyword\">VALUES</span> <br>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-string\">&#x27;zhang@zju.edu.cn&#x27;</span>),<br>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-string\">&#x27;li@zju.edu.cn&#x27;</span>),<br>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;王五&#x27;</span>, <span class=\"hljs-string\">&#x27;wang@zju.edu.cn&#x27;</span>);<br><br><span class=\"hljs-comment\">-- 创建索引 --</span><br><span class=\"hljs-keyword\">CREATE</span> INDEX idx_email <span class=\"hljs-keyword\">ON</span> students(email);<br><br><span class=\"hljs-comment\">-- 此时的索引内部结构 --</span><br>           li<span class=\"hljs-variable\">@zju</span>.edu.cn<br>          <span class=\"hljs-operator\">/</span>              \\<br>    zhang<span class=\"hljs-variable\">@zju</span>.edu.cn    wang<span class=\"hljs-variable\">@zju</span>.edu.cn<br><br><span class=\"hljs-comment\">-- 执行查询 --</span><br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> students <span class=\"hljs-keyword\">WHERE</span> email <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;zhang@zju.edu.cn&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Assertion\"><a href=\"#Assertion\" class=\"headerlink\" title=\"Assertion\"></a>Assertion</h3><p>Assertion(断言): 是数据库中的完整性约束机制, 用于<strong>预先定义</strong>数据库中必须始终满足的条件.</p>\n<p>e.g:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> assertion credits_constaint <span class=\"hljs-keyword\">check</span> (<br>    <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span>(<br>        <span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span><br>        <span class=\"hljs-keyword\">from</span> student S<br>        <span class=\"hljs-keyword\">where</span> total_cred <span class=\"hljs-operator\">&lt;&gt;</span> (<br>            <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">sum</span>(credits)<br>            <span class=\"hljs-keyword\">from</span> takes <span class=\"hljs-keyword\">natural</span> <span class=\"hljs-keyword\">join</span> course<br>            <span class=\"hljs-keyword\">where</span> takes.ID <span class=\"hljs-operator\">=</span> S.ID <br>                <span class=\"hljs-keyword\">and</span> grade <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not null</span> <br>                <span class=\"hljs-keyword\">and</span> grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span><br>        )<br>    )<br>)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>在最外层，通过<code>create assertion</code>语句创建断言并使用<code>not exists</code>确保没有违规记录；中间层主要关注学生表中的总学分字段；而最内层则通过复杂的子查询来计算学生实际获得的有效学分总和(成绩存在且不为<code>false</code>).</p>\n<p><code>&lt;&gt;</code>表示不等于.</p>\n</blockquote>\n<p>虽然断言是一个强大的数据完整性保证机制，但MySQL并不支持这一特性。这主要是出于性能考虑：断言需要在相关表发生变化时进行复杂的检查，这可能会显著影响数据库的操作效率。作为替代方案，MySQL通常会使用<strong>触发器（trigger）</strong>来实现类似的功能。</p>\n<h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><ul>\n<li>语法:</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">trigger</span> trigger_name before<span class=\"hljs-operator\">/</span>after trigger_event <span class=\"hljs-keyword\">of</span> table_name <span class=\"hljs-keyword\">on</span> attribute<br><span class=\"hljs-keyword\">referencing</span> xxx<br><span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">each</span> <span class=\"hljs-type\">row</span><br><span class=\"hljs-keyword\">when</span> xxxx<br><span class=\"hljs-keyword\">begin</span> <br>xxxx(<span class=\"hljs-keyword\">SQL</span> operation)<br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Authorization\"><a href=\"#Authorization\" class=\"headerlink\" title=\"Authorization\"></a>Authorization</h3><ol>\n<li><strong>权限控制的重要性</strong></li>\n</ol>\n<p>在数据库系统中，不同用户往往需要不同级别的访问权限。例如，普通员工可能只需要查询权限，而部门主管可能需要更新数据的权限。为了确保数据安全和隐私保护，数据库系统提供了完善的权限控制机制，包括读取(read)、插入(insert)、更新(update)和删除(delete)这四种基本权限。</p>\n<ol>\n<li><strong>基本授权语法</strong></li>\n</ol>\n<p>SQL提供了灵活的授权语句来管理用户权限。最基本的授权使用<code>GRANT</code>语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-operator\">&lt;</span>privilege_list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation_name <span class=\"hljs-keyword\">or</span> view_name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-operator\">&lt;</span>user_list<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n<p>这里的<code>&lt;user_list&gt;</code>既可以是具体的用户名，也可以是关键字<code>PUBLIC</code>（表示授权给所有用户）。特别地，当我们需要允许用户具有转授权的能力时，可以在授权语句末尾添加<code>WITH GRANT OPTION</code>子句。</p>\n<ol>\n<li><strong>权限管理的高级特性</strong></li>\n</ol>\n<p>为了更灵活地管理权限，SQL还提供了权限回收机制和角色管理：</p>\n<ul>\n<li>权限回收使用<code>REVOKE</code>语句：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">REVOKE</span> <span class=\"hljs-operator\">&lt;</span>privilege_list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation_name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-operator\">&lt;</span>user_list<span class=\"hljs-operator\">&gt;</span> [RESTRICT<span class=\"hljs-operator\">|</span>CASCADE]<br></code></pre></td></tr></table></figure>\n<p>其中<code>RESTRICT</code>表示仅回收<strong>直接授予</strong>的权限，而<code>CASCADE</code>则会同时回收该用户<strong>转授给其他</strong>用户的权限。</p>\n<ul>\n<li>角色管理通过<code>CREATE ROLE</code>实现：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> ROLE manager;<br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">ON</span> employees <span class=\"hljs-keyword\">TO</span> manager;<br><span class=\"hljs-keyword\">GRANT</span> manager <span class=\"hljs-keyword\">TO</span> user1, user2;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><strong>实际应用示例</strong></li>\n</ol>\n<p>假设我们正在管理一个大学教务系统，可能会有如下权限设置：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建教师角色</span><br><span class=\"hljs-keyword\">CREATE</span> ROLE teacher;<br><br><span class=\"hljs-comment\">-- 给教师角色授予查看和修改成绩的权限</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">SELECT</span>, <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">ON</span> student_grades <span class=\"hljs-keyword\">TO</span> teacher;<br><br><span class=\"hljs-comment\">-- 给具体教师授予角色</span><br><span class=\"hljs-keyword\">GRANT</span> teacher <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;prof_zhang&#x27;</span>, <span class=\"hljs-string\">&#x27;prof_li&#x27;</span>;<br><br><span class=\"hljs-comment\">-- 给教务主管额外的权限，并允许其转授权限</span><br><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-keyword\">ALL</span> PRIVILEGES <span class=\"hljs-keyword\">ON</span> student_grades <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;academic_dean&#x27;</span> <span class=\"hljs-keyword\">WITH</span> <span class=\"hljs-keyword\">GRANT</span> OPTION;<br><br><span class=\"hljs-comment\">-- 如果教师离职，收回其权限</span><br><span class=\"hljs-keyword\">REVOKE</span> teacher <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">&#x27;prof_zhang&#x27;</span> CASCADE;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ALL PRIVILEGES</code>表示授予所有的权限.</p>\n</blockquote>\n"},{"_content":"# 使用终端进行调试(以LLDB调试器为例)\n\n## 可调试文件的编译\n\n```cpp\ng++ -std=c++11 -g main.cpp -o main\n```\n\n`-g`表示编译时生成调试信息，这样调试器可以将源代码与编译后的机器代码关联起来。\n\n对于多文件项目，可以一次性编译多个源文件：\n\n```cpp\ng++ -std=c++11 -g file1.cpp file2.cpp -o program\n```\n\n例如：\n```cpp\ng++ -std=c++11 -g pdadd.cpp personal_dairy.cpp -o pdadd_manual\n```\n\n## 启动调试器\n\n```shell\nlldb main\n```\n\n## 基本调试命令\n\n| 功能                 | 命令                | 简写          | 示例          |\n| -------------------- | ------------------- | ------------- | ------------- |\n| 运行程序             | `run [参数]`        | `r [参数]`    | `r input.txt` |\n| 退出调试器           | `quit`              | `q`           | `q`           |\n| 继续执行             | `continue`          | `c`           | `c`           |\n| 单步执行(不进入函数) | `next`              | `n`           | `n`           |\n| 单步执行(进入函数)   | `step`              | `s`           | `s`           |\n| 运行至当前函数返回   | `finish`            | `f`           | `f`           |\n| 查看变量值           | `print 变量名`      | `p 变量名`    | `p count`     |\n| 查看表达式结果       | `expression 表达式` | `expr 表达式` | `expr a + b`  |\n| 查看当前源代码       | `source list`       | `l`           | `l`           |\n\n## 断点管理\n\n| 功能             | 命令                                                         | 简写                      | 示例                           |\n| ---------------- | ------------------------------------------------------------ | ------------------------- | ------------------------------ |\n| 按行号设置断点   | `breakpoint set --file 文件名 --line 行号`                   | `b 文件名:行号`           | `b main.cpp:15`                |\n| 按函数名设置断点 | `breakpoint set --name 函数名`                               | `b 函数名`                | `b main`                       |\n| 按方法名设置断点 | `breakpoint set --method 方法名`                             | `b -M 方法名`             | `b -M PersonalDiary::addEntry` |\n| 设置条件断点     | `breakpoint set --file 文件名 --line 行号 --condition '条件'` | `b 文件名:行号 -c '条件'` | `b main.cpp:20 -c 'x > 5'`     |\n| 列出所有断点     | `breakpoint list`                                            | `br l`                    | `br l`                         |\n| 删除断点         | `breakpoint delete 编号`                                     | `br del 编号`             | `br del 1`                     |\n| 禁用/启用断点    | `breakpoint disable/enable 编号`                             | `br dis/en 编号`          | `br dis 2`                     |\n\n## 查看程序状态\n\n| 功能             | 命令                            | 简写            | 示例            |\n| ---------------- | ------------------------------- | --------------- | --------------- |\n| 查看调用栈       | `thread backtrace`              | `bt`            | `bt`            |\n| 切换栈帧         | `frame select 编号`             | `fr s 编号`     | `fr s 2`        |\n| 查看特定行源代码 | `source list -f 文件名 -l 行号` | `l 文件名:行号` | `l main.cpp:30` |\n| 查看所有线程     | `thread list`                   | -               | `thread list`   |\n| 查看当前线程     | `thread info`                   | -               | `thread info`   |\n\n## 监视变量\n\n| 功能           | 命令                                           | 简写 | 示例                                          |\n| -------------- | ---------------------------------------------- | ---- | --------------------------------------------- |\n| 设置写入监视点 | `watchpoint set variable -w write 变量名`      | -    | `watchpoint set variable -w write count`      |\n| 设置读写监视点 | `watchpoint set variable -w read_write 变量名` | -    | `watchpoint set variable -w read_write total` |\n| 列出监视点     | `watchpoint list`                              | -    | `watchpoint list`                             |\n| 删除监视点     | `watchpoint delete 编号`                       | -    | `watchpoint delete 1`                         |\n\n## 进阶调试功能\n\n| 功能                 | 命令                                                      | 简写        | 示例                                                        |\n| -------------------- | --------------------------------------------------------- | ----------- | ----------------------------------------------------------- |\n| 在当前上下文执行代码 | `expression 代码`                                         | `expr 代码` | `expr count = 0`                                            |\n| 查看寄存器           | `register read`                                           | -           | `register read`                                             |\n| 查看特定寄存器       | `register read 寄存器名`                                  | -           | `register read rip`                                         |\n| 查看内存内容         | `memory read --size 大小 --format 格式 --count 数量 地址` | `m read`    | `memory read --size 4 --format x --count 10 0x7fff5fbff000` |\n| 反汇编当前函数       | `disassemble --frame`                                     | `dis -f`    | `dis -f`                                                    |\n| 运行到指定行         | `thread until 行号`                                       | -           | `thread until 45`                                           |\n| 设置变量值           | `expression 变量名 = 值`                                  | -           | `expression counter = 100`                                  |\n\n## 实际调试示例\n\n```bash\n# 启动调试器\nlldb pdadd_manual\n\n# 在main函数设置断点\n(lldb) b main\n\n# 运行程序\n(lldb) r\n\n# 程序在main停止后，查看源代码\n(lldb) l\n\n# 在类方法上设置断点\n(lldb) b \"PersonalDiary::addEntry\"\n\n# 单步执行\n(lldb) n\n\n# 查看变量\n(lldb) p entryText\n\n# 设置条件断点\n(lldb) b personal_dairy.cpp:50 -c 'entries.size() > 10'\n\n# 继续执行\n(lldb) c\n\n# 查看调用栈\n(lldb) bt\n\n# 切换到上一层栈帧\n(lldb) fr s 1\n\n# 在当前上下文修改变量\n(lldb) expr count = 0\n\n# 运行到函数返回\n(lldb) f\n```\n\n## 调试技巧\n\n1. **断点策略**：在可能出错的地方设置断点，而不是在程序开始处一步步执行\n2. **条件断点**：当特定条件满足时才触发断点，可以节省时间\n3. **查看数据结构**：使用`p`命令查看复杂数据结构，如`p *this`查看当前对象\n4. **监视变量**：当追踪特定变量何时被修改时，使用监视点比断点更有效\n5. **调用栈分析**：出现问题时，使用`bt`查看完整调用栈，了解程序执行路径\n6. **临时修改**：使用`expr`命令可以在调试过程中临时修改变量值进行测试\n\n## 常见错误及调试方法\n\n| 错误类型                   | 调试方法                                            |\n| -------------------------- | --------------------------------------------------- |\n| 段错误(Segmentation Fault) | 设置断点，查看指针是否为空或访问越界                |\n| 内存泄漏                   | 结合valgrind等工具，或监控对象创建与销毁            |\n| 逻辑错误                   | 设置条件断点，监视关键变量的变化                    |\n| 死循环                     | 在循环体内设置断点，观察循环变量是否正常变化        |\n| 并发问题                   | 使用`thread list`和`thread backtrace`分析多线程状态 |\n\n通过熟练掌握这些调试命令和技巧，可以大大提高定位和解决程序问题的效率。\n","source":"_drafts/temp_notes/调试.md","raw":"# 使用终端进行调试(以LLDB调试器为例)\n\n## 可调试文件的编译\n\n```cpp\ng++ -std=c++11 -g main.cpp -o main\n```\n\n`-g`表示编译时生成调试信息，这样调试器可以将源代码与编译后的机器代码关联起来。\n\n对于多文件项目，可以一次性编译多个源文件：\n\n```cpp\ng++ -std=c++11 -g file1.cpp file2.cpp -o program\n```\n\n例如：\n```cpp\ng++ -std=c++11 -g pdadd.cpp personal_dairy.cpp -o pdadd_manual\n```\n\n## 启动调试器\n\n```shell\nlldb main\n```\n\n## 基本调试命令\n\n| 功能                 | 命令                | 简写          | 示例          |\n| -------------------- | ------------------- | ------------- | ------------- |\n| 运行程序             | `run [参数]`        | `r [参数]`    | `r input.txt` |\n| 退出调试器           | `quit`              | `q`           | `q`           |\n| 继续执行             | `continue`          | `c`           | `c`           |\n| 单步执行(不进入函数) | `next`              | `n`           | `n`           |\n| 单步执行(进入函数)   | `step`              | `s`           | `s`           |\n| 运行至当前函数返回   | `finish`            | `f`           | `f`           |\n| 查看变量值           | `print 变量名`      | `p 变量名`    | `p count`     |\n| 查看表达式结果       | `expression 表达式` | `expr 表达式` | `expr a + b`  |\n| 查看当前源代码       | `source list`       | `l`           | `l`           |\n\n## 断点管理\n\n| 功能             | 命令                                                         | 简写                      | 示例                           |\n| ---------------- | ------------------------------------------------------------ | ------------------------- | ------------------------------ |\n| 按行号设置断点   | `breakpoint set --file 文件名 --line 行号`                   | `b 文件名:行号`           | `b main.cpp:15`                |\n| 按函数名设置断点 | `breakpoint set --name 函数名`                               | `b 函数名`                | `b main`                       |\n| 按方法名设置断点 | `breakpoint set --method 方法名`                             | `b -M 方法名`             | `b -M PersonalDiary::addEntry` |\n| 设置条件断点     | `breakpoint set --file 文件名 --line 行号 --condition '条件'` | `b 文件名:行号 -c '条件'` | `b main.cpp:20 -c 'x > 5'`     |\n| 列出所有断点     | `breakpoint list`                                            | `br l`                    | `br l`                         |\n| 删除断点         | `breakpoint delete 编号`                                     | `br del 编号`             | `br del 1`                     |\n| 禁用/启用断点    | `breakpoint disable/enable 编号`                             | `br dis/en 编号`          | `br dis 2`                     |\n\n## 查看程序状态\n\n| 功能             | 命令                            | 简写            | 示例            |\n| ---------------- | ------------------------------- | --------------- | --------------- |\n| 查看调用栈       | `thread backtrace`              | `bt`            | `bt`            |\n| 切换栈帧         | `frame select 编号`             | `fr s 编号`     | `fr s 2`        |\n| 查看特定行源代码 | `source list -f 文件名 -l 行号` | `l 文件名:行号` | `l main.cpp:30` |\n| 查看所有线程     | `thread list`                   | -               | `thread list`   |\n| 查看当前线程     | `thread info`                   | -               | `thread info`   |\n\n## 监视变量\n\n| 功能           | 命令                                           | 简写 | 示例                                          |\n| -------------- | ---------------------------------------------- | ---- | --------------------------------------------- |\n| 设置写入监视点 | `watchpoint set variable -w write 变量名`      | -    | `watchpoint set variable -w write count`      |\n| 设置读写监视点 | `watchpoint set variable -w read_write 变量名` | -    | `watchpoint set variable -w read_write total` |\n| 列出监视点     | `watchpoint list`                              | -    | `watchpoint list`                             |\n| 删除监视点     | `watchpoint delete 编号`                       | -    | `watchpoint delete 1`                         |\n\n## 进阶调试功能\n\n| 功能                 | 命令                                                      | 简写        | 示例                                                        |\n| -------------------- | --------------------------------------------------------- | ----------- | ----------------------------------------------------------- |\n| 在当前上下文执行代码 | `expression 代码`                                         | `expr 代码` | `expr count = 0`                                            |\n| 查看寄存器           | `register read`                                           | -           | `register read`                                             |\n| 查看特定寄存器       | `register read 寄存器名`                                  | -           | `register read rip`                                         |\n| 查看内存内容         | `memory read --size 大小 --format 格式 --count 数量 地址` | `m read`    | `memory read --size 4 --format x --count 10 0x7fff5fbff000` |\n| 反汇编当前函数       | `disassemble --frame`                                     | `dis -f`    | `dis -f`                                                    |\n| 运行到指定行         | `thread until 行号`                                       | -           | `thread until 45`                                           |\n| 设置变量值           | `expression 变量名 = 值`                                  | -           | `expression counter = 100`                                  |\n\n## 实际调试示例\n\n```bash\n# 启动调试器\nlldb pdadd_manual\n\n# 在main函数设置断点\n(lldb) b main\n\n# 运行程序\n(lldb) r\n\n# 程序在main停止后，查看源代码\n(lldb) l\n\n# 在类方法上设置断点\n(lldb) b \"PersonalDiary::addEntry\"\n\n# 单步执行\n(lldb) n\n\n# 查看变量\n(lldb) p entryText\n\n# 设置条件断点\n(lldb) b personal_dairy.cpp:50 -c 'entries.size() > 10'\n\n# 继续执行\n(lldb) c\n\n# 查看调用栈\n(lldb) bt\n\n# 切换到上一层栈帧\n(lldb) fr s 1\n\n# 在当前上下文修改变量\n(lldb) expr count = 0\n\n# 运行到函数返回\n(lldb) f\n```\n\n## 调试技巧\n\n1. **断点策略**：在可能出错的地方设置断点，而不是在程序开始处一步步执行\n2. **条件断点**：当特定条件满足时才触发断点，可以节省时间\n3. **查看数据结构**：使用`p`命令查看复杂数据结构，如`p *this`查看当前对象\n4. **监视变量**：当追踪特定变量何时被修改时，使用监视点比断点更有效\n5. **调用栈分析**：出现问题时，使用`bt`查看完整调用栈，了解程序执行路径\n6. **临时修改**：使用`expr`命令可以在调试过程中临时修改变量值进行测试\n\n## 常见错误及调试方法\n\n| 错误类型                   | 调试方法                                            |\n| -------------------------- | --------------------------------------------------- |\n| 段错误(Segmentation Fault) | 设置断点，查看指针是否为空或访问越界                |\n| 内存泄漏                   | 结合valgrind等工具，或监控对象创建与销毁            |\n| 逻辑错误                   | 设置条件断点，监视关键变量的变化                    |\n| 死循环                     | 在循环体内设置断点，观察循环变量是否正常变化        |\n| 并发问题                   | 使用`thread list`和`thread backtrace`分析多线程状态 |\n\n通过熟练掌握这些调试命令和技巧，可以大大提高定位和解决程序问题的效率。\n","slug":"temp_notes/调试","published":0,"date":"2025-02-26T13:05:16.032Z","updated":"2025-02-26T13:11:23.897Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cm7og11vk00009dqghl2u7j70","content":"<h1 id=\"使用终端进行调试-以LLDB调试器为例\"><a href=\"#使用终端进行调试-以LLDB调试器为例\" class=\"headerlink\" title=\"使用终端进行调试(以LLDB调试器为例)\"></a>使用终端进行调试(以LLDB调试器为例)</h1><h2 id=\"可调试文件的编译\"><a href=\"#可调试文件的编译\" class=\"headerlink\" title=\"可调试文件的编译\"></a>可调试文件的编译</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g main.cpp -o main<br></code></pre></td></tr></table></figure>\n<p><code>-g</code>表示编译时生成调试信息，这样调试器可以将源代码与编译后的机器代码关联起来。</p>\n<p>对于多文件项目，可以一次性编译多个源文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g file<span class=\"hljs-number\">1.</span>cpp file<span class=\"hljs-number\">2.</span>cpp -o program<br></code></pre></td></tr></table></figure>\n<p>例如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g pdadd.cpp personal_dairy.cpp -o pdadd_manual<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"启动调试器\"><a href=\"#启动调试器\" class=\"headerlink\" title=\"启动调试器\"></a>启动调试器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">lldb main<br></code></pre></td></tr></table></figure>\n<h2 id=\"基本调试命令\"><a href=\"#基本调试命令\" class=\"headerlink\" title=\"基本调试命令\"></a>基本调试命令</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运行程序</td>\n<td><code>run [参数]</code></td>\n<td><code>r [参数]</code></td>\n<td><code>r input.txt</code></td>\n</tr>\n<tr>\n<td>退出调试器</td>\n<td><code>quit</code></td>\n<td><code>q</code></td>\n<td><code>q</code></td>\n</tr>\n<tr>\n<td>继续执行</td>\n<td><code>continue</code></td>\n<td><code>c</code></td>\n<td><code>c</code></td>\n</tr>\n<tr>\n<td>单步执行(不进入函数)</td>\n<td><code>next</code></td>\n<td><code>n</code></td>\n<td><code>n</code></td>\n</tr>\n<tr>\n<td>单步执行(进入函数)</td>\n<td><code>step</code></td>\n<td><code>s</code></td>\n<td><code>s</code></td>\n</tr>\n<tr>\n<td>运行至当前函数返回</td>\n<td><code>finish</code></td>\n<td><code>f</code></td>\n<td><code>f</code></td>\n</tr>\n<tr>\n<td>查看变量值</td>\n<td><code>print 变量名</code></td>\n<td><code>p 变量名</code></td>\n<td><code>p count</code></td>\n</tr>\n<tr>\n<td>查看表达式结果</td>\n<td><code>expression 表达式</code></td>\n<td><code>expr 表达式</code></td>\n<td><code>expr a + b</code></td>\n</tr>\n<tr>\n<td>查看当前源代码</td>\n<td><code>source list</code></td>\n<td><code>l</code></td>\n<td><code>l</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"断点管理\"><a href=\"#断点管理\" class=\"headerlink\" title=\"断点管理\"></a>断点管理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按行号设置断点</td>\n<td><code>breakpoint set --file 文件名 --line 行号</code></td>\n<td><code>b 文件名:行号</code></td>\n<td><code>b main.cpp:15</code></td>\n</tr>\n<tr>\n<td>按函数名设置断点</td>\n<td><code>breakpoint set --name 函数名</code></td>\n<td><code>b 函数名</code></td>\n<td><code>b main</code></td>\n</tr>\n<tr>\n<td>按方法名设置断点</td>\n<td><code>breakpoint set --method 方法名</code></td>\n<td><code>b -M 方法名</code></td>\n<td><code>b -M PersonalDiary::addEntry</code></td>\n</tr>\n<tr>\n<td>设置条件断点</td>\n<td><code>breakpoint set --file 文件名 --line 行号 --condition &#39;条件&#39;</code></td>\n<td><code>b 文件名:行号 -c &#39;条件&#39;</code></td>\n<td><code>b main.cpp:20 -c &#39;x &gt; 5&#39;</code></td>\n</tr>\n<tr>\n<td>列出所有断点</td>\n<td><code>breakpoint list</code></td>\n<td><code>br l</code></td>\n<td><code>br l</code></td>\n</tr>\n<tr>\n<td>删除断点</td>\n<td><code>breakpoint delete 编号</code></td>\n<td><code>br del 编号</code></td>\n<td><code>br del 1</code></td>\n</tr>\n<tr>\n<td>禁用/启用断点</td>\n<td><code>breakpoint disable/enable 编号</code></td>\n<td><code>br dis/en 编号</code></td>\n<td><code>br dis 2</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"查看程序状态\"><a href=\"#查看程序状态\" class=\"headerlink\" title=\"查看程序状态\"></a>查看程序状态</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查看调用栈</td>\n<td><code>thread backtrace</code></td>\n<td><code>bt</code></td>\n<td><code>bt</code></td>\n</tr>\n<tr>\n<td>切换栈帧</td>\n<td><code>frame select 编号</code></td>\n<td><code>fr s 编号</code></td>\n<td><code>fr s 2</code></td>\n</tr>\n<tr>\n<td>查看特定行源代码</td>\n<td><code>source list -f 文件名 -l 行号</code></td>\n<td><code>l 文件名:行号</code></td>\n<td><code>l main.cpp:30</code></td>\n</tr>\n<tr>\n<td>查看所有线程</td>\n<td><code>thread list</code></td>\n<td>-</td>\n<td><code>thread list</code></td>\n</tr>\n<tr>\n<td>查看当前线程</td>\n<td><code>thread info</code></td>\n<td>-</td>\n<td><code>thread info</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"监视变量\"><a href=\"#监视变量\" class=\"headerlink\" title=\"监视变量\"></a>监视变量</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置写入监视点</td>\n<td><code>watchpoint set variable -w write 变量名</code></td>\n<td>-</td>\n<td><code>watchpoint set variable -w write count</code></td>\n</tr>\n<tr>\n<td>设置读写监视点</td>\n<td><code>watchpoint set variable -w read_write 变量名</code></td>\n<td>-</td>\n<td><code>watchpoint set variable -w read_write total</code></td>\n</tr>\n<tr>\n<td>列出监视点</td>\n<td><code>watchpoint list</code></td>\n<td>-</td>\n<td><code>watchpoint list</code></td>\n</tr>\n<tr>\n<td>删除监视点</td>\n<td><code>watchpoint delete 编号</code></td>\n<td>-</td>\n<td><code>watchpoint delete 1</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"进阶调试功能\"><a href=\"#进阶调试功能\" class=\"headerlink\" title=\"进阶调试功能\"></a>进阶调试功能</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在当前上下文执行代码</td>\n<td><code>expression 代码</code></td>\n<td><code>expr 代码</code></td>\n<td><code>expr count = 0</code></td>\n</tr>\n<tr>\n<td>查看寄存器</td>\n<td><code>register read</code></td>\n<td>-</td>\n<td><code>register read</code></td>\n</tr>\n<tr>\n<td>查看特定寄存器</td>\n<td><code>register read 寄存器名</code></td>\n<td>-</td>\n<td><code>register read rip</code></td>\n</tr>\n<tr>\n<td>查看内存内容</td>\n<td><code>memory read --size 大小 --format 格式 --count 数量 地址</code></td>\n<td><code>m read</code></td>\n<td><code>memory read --size 4 --format x --count 10 0x7fff5fbff000</code></td>\n</tr>\n<tr>\n<td>反汇编当前函数</td>\n<td><code>disassemble --frame</code></td>\n<td><code>dis -f</code></td>\n<td><code>dis -f</code></td>\n</tr>\n<tr>\n<td>运行到指定行</td>\n<td><code>thread until 行号</code></td>\n<td>-</td>\n<td><code>thread until 45</code></td>\n</tr>\n<tr>\n<td>设置变量值</td>\n<td><code>expression 变量名 = 值</code></td>\n<td>-</td>\n<td><code>expression counter = 100</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"实际调试示例\"><a href=\"#实际调试示例\" class=\"headerlink\" title=\"实际调试示例\"></a>实际调试示例</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 启动调试器</span><br>lldb pdadd_manual<br><br><span class=\"hljs-comment\"># 在main函数设置断点</span><br>(lldb) b main<br><br><span class=\"hljs-comment\"># 运行程序</span><br>(lldb) r<br><br><span class=\"hljs-comment\"># 程序在main停止后，查看源代码</span><br>(lldb) l<br><br><span class=\"hljs-comment\"># 在类方法上设置断点</span><br>(lldb) b <span class=\"hljs-string\">&quot;PersonalDiary::addEntry&quot;</span><br><br><span class=\"hljs-comment\"># 单步执行</span><br>(lldb) n<br><br><span class=\"hljs-comment\"># 查看变量</span><br>(lldb) p entryText<br><br><span class=\"hljs-comment\"># 设置条件断点</span><br>(lldb) b personal_dairy.cpp:50 -c <span class=\"hljs-string\">&#x27;entries.size() &gt; 10&#x27;</span><br><br><span class=\"hljs-comment\"># 继续执行</span><br>(lldb) c<br><br><span class=\"hljs-comment\"># 查看调用栈</span><br>(lldb) bt<br><br><span class=\"hljs-comment\"># 切换到上一层栈帧</span><br>(lldb) fr s 1<br><br><span class=\"hljs-comment\"># 在当前上下文修改变量</span><br>(lldb) <span class=\"hljs-built_in\">expr</span> count = 0<br><br><span class=\"hljs-comment\"># 运行到函数返回</span><br>(lldb) f<br></code></pre></td></tr></table></figure>\n<h2 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h2><ol>\n<li><strong>断点策略</strong>：在可能出错的地方设置断点，而不是在程序开始处一步步执行</li>\n<li><strong>条件断点</strong>：当特定条件满足时才触发断点，可以节省时间</li>\n<li><strong>查看数据结构</strong>：使用<code>p</code>命令查看复杂数据结构，如<code>p *this</code>查看当前对象</li>\n<li><strong>监视变量</strong>：当追踪特定变量何时被修改时，使用监视点比断点更有效</li>\n<li><strong>调用栈分析</strong>：出现问题时，使用<code>bt</code>查看完整调用栈，了解程序执行路径</li>\n<li><strong>临时修改</strong>：使用<code>expr</code>命令可以在调试过程中临时修改变量值进行测试</li>\n</ol>\n<h2 id=\"常见错误及调试方法\"><a href=\"#常见错误及调试方法\" class=\"headerlink\" title=\"常见错误及调试方法\"></a>常见错误及调试方法</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>错误类型</th>\n<th>调试方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>段错误(Segmentation Fault)</td>\n<td>设置断点，查看指针是否为空或访问越界</td>\n</tr>\n<tr>\n<td>内存泄漏</td>\n<td>结合valgrind等工具，或监控对象创建与销毁</td>\n</tr>\n<tr>\n<td>逻辑错误</td>\n<td>设置条件断点，监视关键变量的变化</td>\n</tr>\n<tr>\n<td>死循环</td>\n<td>在循环体内设置断点，观察循环变量是否正常变化</td>\n</tr>\n<tr>\n<td>并发问题</td>\n<td>使用<code>thread list</code>和<code>thread backtrace</code>分析多线程状态</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>通过熟练掌握这些调试命令和技巧，可以大大提高定位和解决程序问题的效率。</p>\n","excerpt":"","more":"<h1 id=\"使用终端进行调试-以LLDB调试器为例\"><a href=\"#使用终端进行调试-以LLDB调试器为例\" class=\"headerlink\" title=\"使用终端进行调试(以LLDB调试器为例)\"></a>使用终端进行调试(以LLDB调试器为例)</h1><h2 id=\"可调试文件的编译\"><a href=\"#可调试文件的编译\" class=\"headerlink\" title=\"可调试文件的编译\"></a>可调试文件的编译</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g main.cpp -o main<br></code></pre></td></tr></table></figure>\n<p><code>-g</code>表示编译时生成调试信息，这样调试器可以将源代码与编译后的机器代码关联起来。</p>\n<p>对于多文件项目，可以一次性编译多个源文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g file<span class=\"hljs-number\">1.</span>cpp file<span class=\"hljs-number\">2.</span>cpp -o program<br></code></pre></td></tr></table></figure>\n<p>例如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">g++ -std=c+<span class=\"hljs-number\">+11</span> -g pdadd.cpp personal_dairy.cpp -o pdadd_manual<br></code></pre></td></tr></table></figure></p>\n<h2 id=\"启动调试器\"><a href=\"#启动调试器\" class=\"headerlink\" title=\"启动调试器\"></a>启动调试器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">lldb main<br></code></pre></td></tr></table></figure>\n<h2 id=\"基本调试命令\"><a href=\"#基本调试命令\" class=\"headerlink\" title=\"基本调试命令\"></a>基本调试命令</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>运行程序</td>\n<td><code>run [参数]</code></td>\n<td><code>r [参数]</code></td>\n<td><code>r input.txt</code></td>\n</tr>\n<tr>\n<td>退出调试器</td>\n<td><code>quit</code></td>\n<td><code>q</code></td>\n<td><code>q</code></td>\n</tr>\n<tr>\n<td>继续执行</td>\n<td><code>continue</code></td>\n<td><code>c</code></td>\n<td><code>c</code></td>\n</tr>\n<tr>\n<td>单步执行(不进入函数)</td>\n<td><code>next</code></td>\n<td><code>n</code></td>\n<td><code>n</code></td>\n</tr>\n<tr>\n<td>单步执行(进入函数)</td>\n<td><code>step</code></td>\n<td><code>s</code></td>\n<td><code>s</code></td>\n</tr>\n<tr>\n<td>运行至当前函数返回</td>\n<td><code>finish</code></td>\n<td><code>f</code></td>\n<td><code>f</code></td>\n</tr>\n<tr>\n<td>查看变量值</td>\n<td><code>print 变量名</code></td>\n<td><code>p 变量名</code></td>\n<td><code>p count</code></td>\n</tr>\n<tr>\n<td>查看表达式结果</td>\n<td><code>expression 表达式</code></td>\n<td><code>expr 表达式</code></td>\n<td><code>expr a + b</code></td>\n</tr>\n<tr>\n<td>查看当前源代码</td>\n<td><code>source list</code></td>\n<td><code>l</code></td>\n<td><code>l</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"断点管理\"><a href=\"#断点管理\" class=\"headerlink\" title=\"断点管理\"></a>断点管理</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按行号设置断点</td>\n<td><code>breakpoint set --file 文件名 --line 行号</code></td>\n<td><code>b 文件名:行号</code></td>\n<td><code>b main.cpp:15</code></td>\n</tr>\n<tr>\n<td>按函数名设置断点</td>\n<td><code>breakpoint set --name 函数名</code></td>\n<td><code>b 函数名</code></td>\n<td><code>b main</code></td>\n</tr>\n<tr>\n<td>按方法名设置断点</td>\n<td><code>breakpoint set --method 方法名</code></td>\n<td><code>b -M 方法名</code></td>\n<td><code>b -M PersonalDiary::addEntry</code></td>\n</tr>\n<tr>\n<td>设置条件断点</td>\n<td><code>breakpoint set --file 文件名 --line 行号 --condition &#39;条件&#39;</code></td>\n<td><code>b 文件名:行号 -c &#39;条件&#39;</code></td>\n<td><code>b main.cpp:20 -c &#39;x &gt; 5&#39;</code></td>\n</tr>\n<tr>\n<td>列出所有断点</td>\n<td><code>breakpoint list</code></td>\n<td><code>br l</code></td>\n<td><code>br l</code></td>\n</tr>\n<tr>\n<td>删除断点</td>\n<td><code>breakpoint delete 编号</code></td>\n<td><code>br del 编号</code></td>\n<td><code>br del 1</code></td>\n</tr>\n<tr>\n<td>禁用/启用断点</td>\n<td><code>breakpoint disable/enable 编号</code></td>\n<td><code>br dis/en 编号</code></td>\n<td><code>br dis 2</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"查看程序状态\"><a href=\"#查看程序状态\" class=\"headerlink\" title=\"查看程序状态\"></a>查看程序状态</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>查看调用栈</td>\n<td><code>thread backtrace</code></td>\n<td><code>bt</code></td>\n<td><code>bt</code></td>\n</tr>\n<tr>\n<td>切换栈帧</td>\n<td><code>frame select 编号</code></td>\n<td><code>fr s 编号</code></td>\n<td><code>fr s 2</code></td>\n</tr>\n<tr>\n<td>查看特定行源代码</td>\n<td><code>source list -f 文件名 -l 行号</code></td>\n<td><code>l 文件名:行号</code></td>\n<td><code>l main.cpp:30</code></td>\n</tr>\n<tr>\n<td>查看所有线程</td>\n<td><code>thread list</code></td>\n<td>-</td>\n<td><code>thread list</code></td>\n</tr>\n<tr>\n<td>查看当前线程</td>\n<td><code>thread info</code></td>\n<td>-</td>\n<td><code>thread info</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"监视变量\"><a href=\"#监视变量\" class=\"headerlink\" title=\"监视变量\"></a>监视变量</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置写入监视点</td>\n<td><code>watchpoint set variable -w write 变量名</code></td>\n<td>-</td>\n<td><code>watchpoint set variable -w write count</code></td>\n</tr>\n<tr>\n<td>设置读写监视点</td>\n<td><code>watchpoint set variable -w read_write 变量名</code></td>\n<td>-</td>\n<td><code>watchpoint set variable -w read_write total</code></td>\n</tr>\n<tr>\n<td>列出监视点</td>\n<td><code>watchpoint list</code></td>\n<td>-</td>\n<td><code>watchpoint list</code></td>\n</tr>\n<tr>\n<td>删除监视点</td>\n<td><code>watchpoint delete 编号</code></td>\n<td>-</td>\n<td><code>watchpoint delete 1</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"进阶调试功能\"><a href=\"#进阶调试功能\" class=\"headerlink\" title=\"进阶调试功能\"></a>进阶调试功能</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th>简写</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>在当前上下文执行代码</td>\n<td><code>expression 代码</code></td>\n<td><code>expr 代码</code></td>\n<td><code>expr count = 0</code></td>\n</tr>\n<tr>\n<td>查看寄存器</td>\n<td><code>register read</code></td>\n<td>-</td>\n<td><code>register read</code></td>\n</tr>\n<tr>\n<td>查看特定寄存器</td>\n<td><code>register read 寄存器名</code></td>\n<td>-</td>\n<td><code>register read rip</code></td>\n</tr>\n<tr>\n<td>查看内存内容</td>\n<td><code>memory read --size 大小 --format 格式 --count 数量 地址</code></td>\n<td><code>m read</code></td>\n<td><code>memory read --size 4 --format x --count 10 0x7fff5fbff000</code></td>\n</tr>\n<tr>\n<td>反汇编当前函数</td>\n<td><code>disassemble --frame</code></td>\n<td><code>dis -f</code></td>\n<td><code>dis -f</code></td>\n</tr>\n<tr>\n<td>运行到指定行</td>\n<td><code>thread until 行号</code></td>\n<td>-</td>\n<td><code>thread until 45</code></td>\n</tr>\n<tr>\n<td>设置变量值</td>\n<td><code>expression 变量名 = 值</code></td>\n<td>-</td>\n<td><code>expression counter = 100</code></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"实际调试示例\"><a href=\"#实际调试示例\" class=\"headerlink\" title=\"实际调试示例\"></a>实际调试示例</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 启动调试器</span><br>lldb pdadd_manual<br><br><span class=\"hljs-comment\"># 在main函数设置断点</span><br>(lldb) b main<br><br><span class=\"hljs-comment\"># 运行程序</span><br>(lldb) r<br><br><span class=\"hljs-comment\"># 程序在main停止后，查看源代码</span><br>(lldb) l<br><br><span class=\"hljs-comment\"># 在类方法上设置断点</span><br>(lldb) b <span class=\"hljs-string\">&quot;PersonalDiary::addEntry&quot;</span><br><br><span class=\"hljs-comment\"># 单步执行</span><br>(lldb) n<br><br><span class=\"hljs-comment\"># 查看变量</span><br>(lldb) p entryText<br><br><span class=\"hljs-comment\"># 设置条件断点</span><br>(lldb) b personal_dairy.cpp:50 -c <span class=\"hljs-string\">&#x27;entries.size() &gt; 10&#x27;</span><br><br><span class=\"hljs-comment\"># 继续执行</span><br>(lldb) c<br><br><span class=\"hljs-comment\"># 查看调用栈</span><br>(lldb) bt<br><br><span class=\"hljs-comment\"># 切换到上一层栈帧</span><br>(lldb) fr s 1<br><br><span class=\"hljs-comment\"># 在当前上下文修改变量</span><br>(lldb) <span class=\"hljs-built_in\">expr</span> count = 0<br><br><span class=\"hljs-comment\"># 运行到函数返回</span><br>(lldb) f<br></code></pre></td></tr></table></figure>\n<h2 id=\"调试技巧\"><a href=\"#调试技巧\" class=\"headerlink\" title=\"调试技巧\"></a>调试技巧</h2><ol>\n<li><strong>断点策略</strong>：在可能出错的地方设置断点，而不是在程序开始处一步步执行</li>\n<li><strong>条件断点</strong>：当特定条件满足时才触发断点，可以节省时间</li>\n<li><strong>查看数据结构</strong>：使用<code>p</code>命令查看复杂数据结构，如<code>p *this</code>查看当前对象</li>\n<li><strong>监视变量</strong>：当追踪特定变量何时被修改时，使用监视点比断点更有效</li>\n<li><strong>调用栈分析</strong>：出现问题时，使用<code>bt</code>查看完整调用栈，了解程序执行路径</li>\n<li><strong>临时修改</strong>：使用<code>expr</code>命令可以在调试过程中临时修改变量值进行测试</li>\n</ol>\n<h2 id=\"常见错误及调试方法\"><a href=\"#常见错误及调试方法\" class=\"headerlink\" title=\"常见错误及调试方法\"></a>常见错误及调试方法</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>错误类型</th>\n<th>调试方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>段错误(Segmentation Fault)</td>\n<td>设置断点，查看指针是否为空或访问越界</td>\n</tr>\n<tr>\n<td>内存泄漏</td>\n<td>结合valgrind等工具，或监控对象创建与销毁</td>\n</tr>\n<tr>\n<td>逻辑错误</td>\n<td>设置条件断点，监视关键变量的变化</td>\n</tr>\n<tr>\n<td>死循环</td>\n<td>在循环体内设置断点，观察循环变量是否正常变化</td>\n</tr>\n<tr>\n<td>并发问题</td>\n<td>使用<code>thread list</code>和<code>thread backtrace</code>分析多线程状态</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>通过熟练掌握这些调试命令和技巧，可以大大提高定位和解决程序问题的效率。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm79tw4vu0003dwqgd3zr8i0p","category_id":"cm79tw4vv0006dwqg9zul4ljj","_id":"cm79tw4vw000gdwqg2lrfasq9"},{"post_id":"cm79tw4vu0005dwqg8u0z9cdd","category_id":"cm79tw4vw000bdwqgdqoyd7p9","_id":"cm79tw4vx000mdwqg842o0gzc"},{"post_id":"cm79tw4vv000adwqggpb183fx","category_id":"cm79tw4vw000hdwqgb1l3bw3i","_id":"cm79tw4vx000udwqgh5qo4b7s"},{"post_id":"cm79tw4vw000edwqg4g5mcmci","category_id":"cm79tw4vw000hdwqgb1l3bw3i","_id":"cm79tw4vy000ydwqg9idddu9o"},{"post_id":"cm79tw4vw000jdwqgab715y8e","category_id":"cm79tw4vx000tdwqgdwp170vg","_id":"cm79tw4vy0015dwqgfi0sa1vk"},{"post_id":"cm79tw4vy0010dwqgep7z2dyf","category_id":"cm79tw4vx000tdwqgdwp170vg","_id":"cm79tw4vy0019dwqgcy63c5se"},{"post_id":"cm79tw4vw000ldwqge2t80pjh","category_id":"cm79tw4vx000tdwqgdwp170vg","_id":"cm79tw4vy001adwqga0ps1i5l"},{"post_id":"cm79tw4vx000pdwqg9m389gpi","category_id":"cm79tw4vy0014dwqgcn005bi6","_id":"cm79tw4vz001fdwqg4g0zb978"},{"post_id":"cm79tw4vy0013dwqg4h4k91s0","category_id":"cm79tw4vy0014dwqgcn005bi6","_id":"cm79tw4vz001idwqg6gsw9b1m"},{"post_id":"cm79tw4vy0017dwqge5pibh1g","category_id":"cm79tw4vy0014dwqgcn005bi6","_id":"cm79tw4vz001ldwqgev4d6m6b"},{"post_id":"cm79tw4w00022dwqg3wok0aew","category_id":"cm79tw4vy0014dwqgcn005bi6","_id":"cm79tw4w00027dwqghn5t6021"},{"post_id":"cm79tw4w00023dwqg1xkjfpj4","category_id":"cm79tw4vx000tdwqgdwp170vg","_id":"cm79tw4w00028dwqgfx9ehhio"},{"post_id":"cm79tw4w00026dwqg4y6afm9z","category_id":"cm79tw4vx000tdwqgdwp170vg","_id":"cm79tw4w1002cdwqgaikhevnh"},{"post_id":"cm7ct9xz70000cpqg8i450sb5","category_id":"cm7ct9xz80001cpqgdvxvg02f","_id":"cm7ct9xza0004cpqgc7821tyl"}],"PostTag":[{"post_id":"cm79tw4vu0003dwqgd3zr8i0p","tag_id":"cm79tw4vv0007dwqg40mb5c33","_id":"cm79tw4vw000ddwqgfkk38715"},{"post_id":"cm79tw4vu0005dwqg8u0z9cdd","tag_id":"cm79tw4vw000cdwqgd1rcacu4","_id":"cm79tw4vw000kdwqg3k374t59"},{"post_id":"cm79tw4vv0008dwqgeitn63ic","tag_id":"cm79tw4vw000idwqgcrv6ey9o","_id":"cm79tw4vx000qdwqgbpi469km"},{"post_id":"cm79tw4vw000ldwqge2t80pjh","tag_id":"cm79tw4vw000idwqgcrv6ey9o","_id":"cm79tw4vx000sdwqg0p6q5pil"},{"post_id":"cm79tw4vv000adwqggpb183fx","tag_id":"cm79tw4vx000odwqg33o67g0c","_id":"cm79tw4vy0012dwqg1avj97j6"},{"post_id":"cm79tw4vv000adwqggpb183fx","tag_id":"cm79tw4vx000vdwqgc44l4g5c","_id":"cm79tw4vy0016dwqgbvcl1ach"},{"post_id":"cm79tw4vw000edwqg4g5mcmci","tag_id":"cm79tw4vx000odwqg33o67g0c","_id":"cm79tw4vz001ddwqggm8u25ew"},{"post_id":"cm79tw4vw000edwqg4g5mcmci","tag_id":"cm79tw4vy0018dwqg5wrjhd3x","_id":"cm79tw4vz001gdwqg3333crla"},{"post_id":"cm79tw4vw000jdwqgab715y8e","tag_id":"cm79tw4vy001cdwqg697f6u0i","_id":"cm79tw4vz001kdwqg3eaceixh"},{"post_id":"cm79tw4vw000jdwqgab715y8e","tag_id":"cm79tw4vz001hdwqgciwk75xu","_id":"cm79tw4vz001mdwqgbh6h3vo3"},{"post_id":"cm79tw4vx000pdwqg9m389gpi","tag_id":"cm79tw4vz001jdwqg2ln6a2cr","_id":"cm79tw4vz001pdwqgbduy5cf7"},{"post_id":"cm79tw4vx000pdwqg9m389gpi","tag_id":"cm79tw4vz001ndwqg5dfu7648","_id":"cm79tw4vz001qdwqg1utpdffi"},{"post_id":"cm79tw4vy0010dwqgep7z2dyf","tag_id":"cm79tw4vz001odwqg7slp2g4b","_id":"cm79tw4vz001tdwqge35g1fb0"},{"post_id":"cm79tw4vy0010dwqgep7z2dyf","tag_id":"cm79tw4vz001rdwqggn1kdrtd","_id":"cm79tw4vz001udwqgcqp4a2in"},{"post_id":"cm79tw4vy0013dwqg4h4k91s0","tag_id":"cm79tw4vz001ndwqg5dfu7648","_id":"cm79tw4vz001xdwqg3su19wv8"},{"post_id":"cm79tw4vy0013dwqg4h4k91s0","tag_id":"cm79tw4vz001vdwqghj9ygqhw","_id":"cm79tw4vz001ydwqg2f2o0z3l"},{"post_id":"cm79tw4vy0017dwqge5pibh1g","tag_id":"cm79tw4vz001wdwqg10kw274i","_id":"cm79tw4vz0020dwqgedp0fq6c"},{"post_id":"cm79tw4vy0017dwqge5pibh1g","tag_id":"cm79tw4vz001zdwqgdkqa2ahq","_id":"cm79tw4vz0021dwqg4nv088fd"},{"post_id":"cm79tw4w00026dwqg4y6afm9z","tag_id":"cm79tw4vz001odwqg7slp2g4b","_id":"cm79tw4w0002adwqg8f7oco9z"},{"post_id":"cm79tw4w00026dwqg4y6afm9z","tag_id":"cm79tw4vz001rdwqggn1kdrtd","_id":"cm79tw4w1002bdwqg2lcig2lk"},{"post_id":"cm79tw4w00022dwqg3wok0aew","tag_id":"cm79tw4vz001ndwqg5dfu7648","_id":"cm79tw4w1002ddwqgf3u5hguc"},{"post_id":"cm79tw4w00022dwqg3wok0aew","tag_id":"cm79tw4w00024dwqg90a3bkjk","_id":"cm79tw4w1002edwqg57wjemoe"},{"post_id":"cm79tw4w00023dwqg1xkjfpj4","tag_id":"cm79tw4vz001odwqg7slp2g4b","_id":"cm79tw4w1002fdwqgbwl205x5"},{"post_id":"cm79tw4w00023dwqg1xkjfpj4","tag_id":"cm79tw4w00029dwqgdyyt1a1d","_id":"cm79tw4w1002gdwqggmtu8l59"},{"post_id":"cm7ct9xz70000cpqg8i450sb5","tag_id":"cm7ct9xza0002cpqg16mn9yf2","_id":"cm7ct9xza0003cpqgh1lj9h5q"}],"Tag":[{"name":"追番","_id":"cm79tw4vv0007dwqg40mb5c33"},{"name":"心理学","_id":"cm79tw4vw000cdwqgd1rcacu4"},{"name":"杂记","_id":"cm79tw4vw000idwqgcrv6ey9o"},{"name":"短诗","_id":"cm79tw4vx000odwqg33o67g0c"},{"name":"她","_id":"cm79tw4vx000vdwqgc44l4g5c"},{"name":"自然","_id":"cm79tw4vy0018dwqg5wrjhd3x"},{"name":"前后端交互","_id":"cm79tw4vy001cdwqg697f6u0i"},{"name":"网站开发","_id":"cm79tw4vz001hdwqgciwk75xu"},{"name":"ssh","_id":"cm79tw4vz001jdwqg2ln6a2cr"},{"name":"服务器","_id":"cm79tw4vz001ndwqg5dfu7648"},{"name":"前端","_id":"cm79tw4vz001odwqg7slp2g4b"},{"name":"CSS","_id":"cm79tw4vz001rdwqggn1kdrtd"},{"name":"多会话管理","_id":"cm79tw4vz001vdwqghj9ygqhw"},{"name":"python","_id":"cm79tw4vz001wdwqg10kw274i"},{"name":"环境配置","_id":"cm79tw4vz001zdwqgdkqa2ahq"},{"name":"PAT","_id":"cm79tw4w00024dwqg90a3bkjk"},{"name":"JS","_id":"cm79tw4w00029dwqgdyyt1a1d"},{"name":"latex","_id":"cm7ct9xza0002cpqg16mn9yf2"}]}}