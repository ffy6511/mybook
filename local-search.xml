<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Re0!</title>
    <link href="/2025/01/18/Re0/"/>
    <url>/2025/01/18/Re0/</url>
    
    <content type="html"><![CDATA[<p>为了寻找合适的封面，用一天半从零开始刷了Re0新编集的13话+ OVA1 + 16集的sp</p><p>真是辛苦自己了😳（）</p><p><img src = "/img/2025-01-18-17-06-50.png" width = "30%" class = "smallImg"></p><p><br><br>刚出宅邸篇的时候看得是真坐牢😥——感觉486真是自信过头、又完全没有脑袋, 真是太弱了.<br>于是本打算转而去玩铲铲, 但是恰好遇到铲铲要更新😬, <del>勉为其难</del>再看几话吧.</p><p>终于到了白鲸篇, 看着486从一次次的死亡打击中逐渐崩溃:<br><img src="/img/2025-01-18-17-13-45.png" alt=""></p><blockquote><p><del>这不是熬夜熬多了的我吗</del></p></blockquote><p>到最后与雷姆的“私奔”对话中完成心态的转变:<br><img src="/img/re0-2025-01-18-17-16-53.png" alt=""><br>也是为男主的 <strong>增强</strong> 感到十分的欣慰.😌<br><img src="/img/2025-01-18-17-11-36.png" alt=""></p><p style = "    font-size: 0.9em;      color: grey;    text-align : center;">当然 不是这种增强🤭 </p><p><hr></p><p style = " font-size : 1.3em; text-align: center;">但是我的雷姆呢!🤬😐 感觉都没有动力追第二季了🙃</p><p><img src="/img/re0-2025-01-18-17-40-27.png" alt=""></p><style>.post-content img:not(.smallImg){    width: 70%;    height: auto;    display: block;    margin: 1rem auto;}</style>]]></content>
    
    
    <categories>
      
      <category>生活碎碎念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>追番</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协议切换与认证配置</title>
    <link href="/2025/01/18/%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/18/%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-远程仓库认证：从-SSH-到-HTTPS"><a href="#Git-远程仓库认证：从-SSH-到-HTTPS" class="headerlink" title="Git 远程仓库认证：从 SSH 到 HTTPS"></a>Git 远程仓库认证：从 SSH 到 HTTPS</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。</p><h2 id="认证机制解析"><a href="#认证机制解析" class="headerlink" title="认证机制解析"></a>认证机制解析</h2><h3 id="双层认证架构"><a href="#双层认证架构" class="headerlink" title="双层认证架构"></a>双层认证架构</h3><ol><li><p><strong>服务器层认证</strong></p><ul><li>用于验证用户对服务器的访问权限</li><li>通常通过 SSH 密钥或密码完成</li></ul></li><li><p><strong>仓库层认证</strong></p><ul><li>验证用户对特定 Git 仓库的操作权限</li><li>独立于服务器认证系统</li><li>确保代码安全性和提交者身份</li></ul></li></ol><h3 id="SSH-vs-HTTPS"><a href="#SSH-vs-HTTPS" class="headerlink" title="SSH vs HTTPS"></a>SSH vs HTTPS</h3><ol><li><p><strong>SSH 协议</strong></p><ul><li>优势：<ul><li>更安全，使用密钥对进行加密</li><li>配置一次可永久使用</li><li>可以避免每次输入密码</li></ul></li><li>劣势：<ul><li>可能被防火墙阻止（22端口）</li><li>在某些企业网络中可能无法使用</li><li>配置相对复杂</li></ul></li></ul></li><li><p><strong>HTTPS 协议</strong></p><ul><li>优势：<ul><li>几乎总是可用（443端口）</li><li>穿透防火墙能力强</li><li>配置简单</li></ul></li><li>劣势：<ul><li>需要管理凭证</li><li>可能需要频繁输入认证信息</li></ul></li></ul></li></ol><h2 id="连接问题分析"><a href="#连接问题分析" class="headerlink" title="连接问题分析"></a>连接问题分析</h2><h3 id="SSH-超时问题解析"><a href="#SSH-超时问题解析" class="headerlink" title="SSH 超时问题解析"></a>SSH 超时问题解析</h3><p>SSH 连接可能出现超时的原因：</p><ol><li><p><strong>网络限制</strong></p><ul><li>企业防火墙可能会阻止或限制 SSH 连接</li><li>某些网络环境会定期切断长时间的 SSH 连接</li></ul></li><li><p><strong>代理影响</strong></p><ul><li>SSH 不会自动使用系统代理</li><li>需要额外配置 SSH 的代理设置</li></ul></li><li><p><strong>防火墙策略</strong></p><ul><li>22 端口经常被封锁</li><li>某些地区可能限制 SSH 协议</li></ul></li></ol><h3 id="HTTPS-连接优势"><a href="#HTTPS-连接优势" class="headerlink" title="HTTPS 连接优势"></a>HTTPS 连接优势</h3><ol><li><p><strong>标准 Web 端口</strong></p><ul><li>使用 443 端口，几乎总是开放的</li><li>与普通网页浏览使用相同的端口</li></ul></li><li><p><strong>代理兼容</strong></p><ul><li>自动使用系统代理设置</li><li>更好的网络兼容性</li></ul></li><li><p><strong>连接特性</strong></p><ul><li>非持久连接，每次请求独立</li><li>不受长连接限制影响</li></ul></li></ol><h2 id="协议转换实践"><a href="#协议转换实践" class="headerlink" title="协议转换实践"></a>协议转换实践</h2><p>在尝试直接<code>git push</code>时显示:<br><img src="/img/2025-01-18-12-58-38.png" alt=""><br>通过执行命令<code>git remote -v</code>查看当前远程仓库的地址:<br><img src="/img/2025-01-18-13-01-29.png" alt=""></p><blockquote><p><code>git@</code>的前缀格式说明是通过<code>ssh</code>的方式, 我们尝试修改为<code>https</code>的协议来解决超时问题.</p></blockquote><p>更新仓库的URL:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote set-url origin https://github.com/用户名/仓库名.git<br></code></pre></td></tr></table></figure><br>e.g.:<br><img src="/img/2025-01-18-13-03-21.png" alt=""></p><blockquote><p>在更新之后执行<code>get remote -v</code>, 检查发现已经转换为<code>HTTPS</code>.</p></blockquote><h3 id="配置凭证管理"><a href="#配置凭证管理" class="headerlink" title="配置凭证管理"></a>配置凭证管理</h3><p>此时依旧无法直接<code>git push</code>, 因为仓库层认证的密码验证方式已经不受<code>github</code>支持, 如果尝试通过用户名-密码的方式验证, 将会失败:<br><img src="/img/2025-01-18-13-09-11.png" alt=""></p><p>因此我们需要通过 <strong>个人访问令牌</strong>(PAT) 的方式来鉴权.</p><ol><li><p><strong>配置凭证管理:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 永久存储凭证</span><br>git config --global credential.helper store<br><br><span class="hljs-comment"># 或临时缓存（如15分钟）</span><br>git config --global credential.helper <span class="hljs-string">&#x27;cache --timeout=900&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果不希望影响其他仓库, 去除<code>--global</code>即可.</p></blockquote></li><li><p><strong>获取PAT</strong>:</p><ol><li>访问 GitHub Settings;</li><li>下滑到底部,进入 <code>Developer settings</code>;</li><li>选择 <code>Personal access tokens</code> → <code>Tokens (classic)</code>;</li><li>在右上角选择生成新的<code>access token</code>;</li><li>生成新令牌并设置适当的权限范围 (至少勾选<code>repo</code>).<br><img src="/img/2025-01-18-13-15-38.png" alt=""><blockquote><p>在生成PAT之后立即复制并保存.</p></blockquote></li></ol></li></ol><h3 id="通过PAT鉴权"><a href="#通过PAT鉴权" class="headerlink" title="通过PAT鉴权"></a>通过PAT鉴权</h3><p>此时, 我们可以<code>git push</code>然后利用PAT来鉴权:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br>Username: &lt;GitHub用户名&gt;<br>Password: &lt;个人访问令牌&gt;<br></code></pre></td></tr></table></figure><br>e.g.<br><img src="/img/2025-01-18-13-23-22.png" alt=""></p><h2 id="安全相关建议"><a href="#安全相关建议" class="headerlink" title="安全相关建议"></a>安全相关建议</h2><h3 id="凭证管理"><a href="#凭证管理" class="headerlink" title="凭证管理"></a>凭证管理</h3><ol><li><p><strong>凭证存储位置</strong></p><ul><li>Linux/Mac: <code>~/.git-credentials</code></li><li>Windows: <code>%USERPROFILE%\.git-credentials</code></li></ul></li><li><p><strong>安全建议</strong></p><ul><li>定期更新访问令牌</li><li>在共享环境使用临时缓存</li><li>及时清理凭证缓存</li></ul></li></ol><h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除全局凭证配置</span><br>git config --global --<span class="hljs-built_in">unset</span> credential.helper<br><br><span class="hljs-comment"># 删除凭证文件</span><br><span class="hljs-built_in">rm</span> ~/.git-credentials  <span class="hljs-comment"># Linux/Mac</span><br>del <span class="hljs-string">&quot;%USERPROFILE%\.git-credentials&quot;</span>  <span class="hljs-comment"># Windows</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通用技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>PAT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux</title>
    <link href="/2025/01/17/Tmux/"/>
    <url>/2025/01/17/Tmux/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~<br><img src = "/img/不死鸟.jpg" width = "70%"></p></blockquote><h1 id="Tmux-入门指南：多会话终端管理利器"><a href="#Tmux-入门指南：多会话终端管理利器" class="headerlink" title="Tmux 入门指南：多会话终端管理利器"></a>Tmux 入门指南：多会话终端管理利器</h1><h2 id="什么是-Tmux？"><a href="#什么是-Tmux？" class="headerlink" title="什么是 Tmux？"></a>什么是 Tmux？</h2><p>Tmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。</p><h2 id="为什么需要-Tmux？"><a href="#为什么需要-Tmux？" class="headerlink" title="为什么需要 Tmux？"></a>为什么需要 Tmux？</h2><p>在以下场景中，tmux 特别有用：</p><ol><li><p><strong>远程服务器管理</strong></p><ul><li>SSH 连接意外断开时，tmux 会话仍然保持运行</li><li>可以随时重新连接到之前的工作环境</li></ul></li><li><p><strong>多任务管理</strong></p><ul><li>在同一个终端窗口中同时运行多个程序</li><li>方便地在不同任务之间切换</li></ul></li><li><p><strong>结对编程</strong></p><ul><li>多人可以同时连接到同一个 tmux 会话</li><li>实时查看和协作编辑</li></ul></li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>tmux 采用三层架构：</p><ul><li><strong>会话（Session）</strong>：最顶层的概念，包含多个窗口</li><li><strong>窗口（Window）</strong>：类似于浏览器的标签页</li><li><strong>窗格（Pane）</strong>：窗口内的分割区域</li></ul><h2 id="常用操作指南"><a href="#常用操作指南" class="headerlink" title="常用操作指南"></a>常用操作指南</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>不同系统的安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># MacOS</span><br>brew install tmux<br><br><span class="hljs-comment"># Ubuntu/Debian</span><br><span class="hljs-built_in">sudo</span> apt install tmux<br><br><span class="hljs-comment"># CentOS/RHEL</span><br><span class="hljs-built_in">sudo</span> yum install tmux<br></code></pre></td></tr></table></figure><h3 id="2-会话管理"><a href="#2-会话管理" class="headerlink" title="2. 会话管理"></a>2. 会话管理</h3><h4 id="启动新会话"><a href="#启动新会话" class="headerlink" title="启动新会话"></a>启动新会话</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建默认会话</span><br>tmux<br><br><span class="hljs-comment"># 创建命名会话</span><br>tmux new -s session_name<br></code></pre></td></tr></table></figure><h4 id="会话操作"><a href="#会话操作" class="headerlink" title="会话操作"></a>会话操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 断开当前会话</span><br>Ctrl+b d<br><br><span class="hljs-comment"># 列出所有会话</span><br>tmux <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 连接到指定会话</span><br>tmux attach -t session_name<br><br><span class="hljs-comment"># 关闭指定会话</span><br>tmux kill-session -t session_name<br></code></pre></td></tr></table></figure><h3 id="3-窗口管理"><a href="#3-窗口管理" class="headerlink" title="3. 窗口管理"></a>3. 窗口管理</h3><p>所有命令都需要先按前缀键 <code>Ctrl+b</code>：</p><ul><li><code>c</code>: 创建新窗口</li><li><code>&amp;</code>: 关闭当前窗口</li><li><code>p</code>: 切换到上一个窗口</li><li><code>n</code>: 切换到下一个窗口</li><li><code>数字键</code>: 切换到指定编号的窗口</li></ul><h3 id="4-窗格操作"><a href="#4-窗格操作" class="headerlink" title="4. 窗格操作"></a>4. 窗格操作</h3><p>同样需要先按前缀键 <code>Ctrl+b</code>：</p><ul><li><code>%</code>: 垂直分割窗格</li><li><code>&quot;</code>: 水平分割窗格</li><li><code>方向键</code>: 在窗格之间移动</li><li><code>x</code>: 关闭当前窗格</li><li><code>z</code>: 最大化/还原当前窗格</li></ul><h2 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h2><h3 id="1-自定义配置"><a href="#1-自定义配置" class="headerlink" title="1. 自定义配置"></a>1. 自定义配置</h3><p>创建 <code>~/.tmux.conf</code> 文件来自定义 tmux 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改前缀键为 Ctrl+a</span><br><span class="hljs-built_in">set</span> -g prefix C-a<br>unbind C-b<br><span class="hljs-built_in">bind</span> C-a send-prefix<br><br><span class="hljs-comment"># 开启鼠标支持</span><br><span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># 设置窗口编号从 1 开始</span><br><span class="hljs-built_in">set</span> -g base-index 1<br></code></pre></td></tr></table></figure><h3 id="2-复制模式"><a href="#2-复制模式" class="headerlink" title="2. 复制模式"></a>2. 复制模式</h3><ol><li>按 <code>Ctrl+b [</code> 进入复制模式</li><li>使用方向键移动光标</li><li>按 <code>Space</code> 开始选择</li><li>按 <code>Enter</code> 复制选中内容</li><li>按 <code>Ctrl+b ]</code> 粘贴</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li><strong>使用有意义的会话名</strong>：便于识别和管理</li><li><strong>合理使用窗格</strong>：避免过度分割</li><li><strong>保持配置文件的整洁</strong>：注释清晰，逻辑分明</li><li><strong>定期保存重要会话</strong>：使用插件或脚本自动保存</li></ol><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><ol><li><p><strong>无法创建会话</strong></p><ul><li>检查 tmux 是否正确安装</li><li>确认用户权限</li></ul></li><li><p><strong>快捷键不响应</strong></p><ul><li>确认是否正确按下前缀键</li><li>检查配置文件是否有冲突</li></ul></li><li><p><strong>会话丢失</strong></p><ul><li>使用 <code>tmux ls</code> 检查会话状态</li><li>查看系统日志寻找错误信息</li></ul></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>tmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://github.com/tmux/tmux/wiki">Tmux 官方文档</a></li><li><a href="https://tmuxcheatsheet.com/">Tmux 速查表</a></li><li><a href="https://github.com/rothgar/awesome-tmux">Awesome Tmux</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>通用技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>多会话管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH隧道</title>
    <link href="/2025/01/17/SSH%E9%9A%A7%E9%81%93/"/>
    <url>/2025/01/17/SSH%E9%9A%A7%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h1 id="通过-SSH-隧道实现远程服务器使用本地代理"><a href="#通过-SSH-隧道实现远程服务器使用本地代理" class="headerlink" title="通过 SSH 隧道实现远程服务器使用本地代理"></a>通过 SSH 隧道实现远程服务器使用本地代理</h1><p>在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。</p><h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><p>SSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-title">[</span><span class="hljs-comment">远程服务器</span><span class="hljs-title">]</span> &lt;<span class="hljs-literal">---</span> <span class="hljs-comment">SSH隧道</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-title">[</span><span class="hljs-comment">本地电脑</span><span class="hljs-title">]</span> &lt;<span class="hljs-literal">---</span> <span class="hljs-comment">代理</span> <span class="hljs-literal">---</span>&gt; <span class="hljs-title">[</span><span class="hljs-comment">互联网</span><span class="hljs-title">]</span><br></code></pre></td></tr></table></figure><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h3><ul><li>本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）</li><li>能够通过 SSH 连接到远程服务器</li><li>确保本地代理软件正常工作</li></ul><h3 id="2-建立-SSH-隧道"><a href="#2-建立-SSH-隧道" class="headerlink" title="2. 建立 SSH 隧道"></a>2. 建立 SSH 隧道</h3><p>在本地电脑的终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-R 7890:127.0.0.1:7890</code>：将远程服务器的 7890 端口转发到本地的 7890 端口</li><li><code>-o ServerAliveInterval=60</code>：每 60 秒发送一次心跳包</li><li><code>-o ServerAliveCountMax=3</code>：最多允许丢失 3 次心跳包</li></ul><p><br></p><p>然后根据提示输入服务器用户的密码:<br><img src="/img/2025-01-18-11-45-41.png" alt=""></p><h3 id="3-配置服务器代理"><a href="#3-配置服务器代理" class="headerlink" title="3. 配置服务器代理"></a>3. 配置服务器代理</h3><p>在服务器终端中执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890<br></code></pre></td></tr></table></figure><h3 id="4-验证代理是否生效"><a href="#4-验证代理是否生效" class="headerlink" title="4. 验证代理是否生效"></a>4. 验证代理是否生效</h3><p>在服务器上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -v https://github.com<br></code></pre></td></tr></table></figure><p>如果能够正常访问，说明代理配置成功。</p><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><p>如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编辑 ~/.bashrc 或 ~/.zshrc</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890&#x27;</span> &gt;&gt; ~/.bashrc<br><br><span class="hljs-comment"># 重新加载配置</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>安全性考虑</strong>：SSH 隧道是加密的，相对安全</li><li><strong>连接维护</strong>：保持 SSH 连接不断开，否则代理会失效</li><li><strong>带宽限制</strong>：代理流量会经过你的本地电脑，注意带宽占用</li><li><strong>临时使用</strong>：这种方法适合临时使用，长期使用建议直接在服务器上配置代理</li></ol><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><ol><li><p><strong>隧道无法建立</strong></p><ul><li>检查本地代理是否正常运行</li><li>确认端口号是否正确</li><li>检查服务器防火墙设置</li></ul></li><li><p><strong>代理失效</strong></p><ul><li>SSH 连接是否断开</li><li>本地代理软件是否正常运行</li><li>环境变量是否正确设置</li></ul></li></ol><h3 id="Clash设置"><a href="#Clash设置" class="headerlink" title="Clash设置"></a>Clash设置</h3><p>在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:<br>以mac的ClashX Pro为例, 在<code>更多设置</code>中<br><img src="/img/2025-01-17-14-00-36.png" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。</p>]]></content>
    
    
    <categories>
      
      <category>通用技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CORS</title>
    <link href="/2025/01/16/CORS/"/>
    <url>/2025/01/16/CORS/</url>
    
    <content type="html"><![CDATA[<h1 id="跨域资源共享（CORS）技术指南"><a href="#跨域资源共享（CORS）技术指南" class="headerlink" title="跨域资源共享（CORS）技术指南"></a>跨域资源共享（CORS）技术指南</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#概述">概述</a></li><li><a href="#技术背景">技术背景</a></li><li><a href="#配置方案">配置方案</a></li><li><a href="#最佳实践">最佳实践</a></li><li><a href="#问题排查">问题排查</a></li><li><a href="#参考文献">参考文献</a></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。</p><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><h3 id="同源策略基础"><a href="#同源策略基础" class="headerlink" title="同源策略基础"></a>同源策略基础</h3><p>同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">基准URL：http://example.com/page.html<br><br>跨域场景：<br>- http://api.example.com/data     // 子域名差异<br>- https://example.com/data        // 协议差异<br>- http://example.com:8080/data    // 端口差异<br></code></pre></td></tr></table></figure><h2 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h2><h3 id="环境变量驱动的CORS配置"><a href="#环境变量驱动的CORS配置" class="headerlink" title="环境变量驱动的CORS配置"></a>环境变量驱动的CORS配置</h3><p>以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_cors <span class="hljs-keyword">import</span> CORS<br><br>app = Flask(__name__)<br><br><span class="hljs-comment"># 从环境变量获取前端URL，如果没有设置则使用默认值</span><br>FRONTEND_URL = os.environ.get(<span class="hljs-string">&#x27;FRONTEND_URL&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>)<br><br><span class="hljs-comment"># CORS配置实现</span><br>CORS(app, resources=&#123;<br>    <span class="hljs-string">r&quot;/api/*&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;origins&quot;</span>: FRONTEND_URL,<br>        <span class="hljs-string">&quot;methods&quot;</span>: [<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>],<br>        <span class="hljs-string">&quot;allow_headers&quot;</span>: [<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;X-Requested-With&quot;</span>],<br>        <span class="hljs-string">&quot;supports_credentials&quot;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&quot;expose_headers&quot;</span>: [<span class="hljs-string">&quot;Content-Disposition&quot;</span>]<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h3><p>让我们逐行分析这个配置：</p><ol><li><strong>环境变量设置</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">FRONTEND_URL = os.environ.get(<span class="hljs-string">&#x27;FRONTEND_URL&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><ul><li>使用<code>os.environ.get()</code>获取环境变量</li><li>提供默认值<code>&#39;http://localhost:3000&#39;</code>作为本地开发环境的配置</li><li>可以通过环境变量轻松切换不同环境的配置</li></ul><ol><li><strong>CORS配置参数</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure></li></ol><ul><li>动态设置允许的源，基于环境变量</li><li>避免了硬编码的问题</li><li>支持不同部署环境的灵活配置</li></ul><ol><li><strong>HTTP方法配置</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;methods&quot;</span>: [<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>]<br></code></pre></td></tr></table></figure></li></ol><ul><li>明确定义允许的HTTP方法</li><li>包含了RESTful API所需的全部方法</li><li><code>OPTIONS</code>用于预检请求（preflight request）</li></ul><ol><li><strong>请求头配置</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;allow_headers&quot;</span>: [<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;X-Requested-With&quot;</span>]<br></code></pre></td></tr></table></figure></li></ol><ul><li><code>Content-Type</code>：允许设置请求的内容类型</li><li><code>Authorization</code>：支持身份验证令牌</li><li><code>X-Requested-With</code>：用于标识AJAX请求</li></ul><ol><li><strong>凭证支持</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;supports_credentials&quot;</span>: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li></ol><ul><li>允许跨域请求携带凭证（如Cookie）</li><li>对需要身份验证的API至关重要</li></ul><ol><li><strong>响应头暴露</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;expose_headers&quot;</span>: [<span class="hljs-string">&quot;Content-Disposition&quot;</span>]<br></code></pre></td></tr></table></figure></li></ol><ul><li>允许客户端访问<code>Content-Disposition</code>响应头</li><li>通常用于文件下载功能</li></ul><h3 id="环境变量配置示例"><a href="#环境变量配置示例" class="headerlink" title="环境变量配置示例"></a>环境变量配置示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开发环境</span><br><span class="hljs-built_in">export</span> FRONTEND_URL=http://localhost:3000<br><br><span class="hljs-comment"># 测试环境</span><br><span class="hljs-built_in">export</span> FRONTEND_URL=http://test.example.com<br><br><span class="hljs-comment"># 生产环境</span><br><span class="hljs-built_in">export</span> FRONTEND_URL=https://www.example.com<br></code></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="环境变量管理建议"><a href="#环境变量管理建议" class="headerlink" title="环境变量管理建议"></a>环境变量管理建议</h3><ol><li><strong>开发环境</strong></li></ol><ul><li>使用<code>.env</code>文件管理本地开发环境变量</li><li>将<code>.env</code>文件加入<code>.gitignore</code></li></ul><ol><li><strong>生产环境</strong></li></ol><ul><li>使用容器化部署时通过环境变量注入</li><li>使用配置管理系统统一管理环境变量</li></ul><h3 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h3><ol><li><p><strong>避免过于宽松的配置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不推荐</span><br><span class="hljs-string">&quot;origins&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>  <br><br><span class="hljs-comment"># 推荐</span><br><span class="hljs-string">&quot;origins&quot;</span>: FRONTEND_URL<br></code></pre></td></tr></table></figure></li><li><p><strong>合理设置凭证策略</strong></p></li></ol><ul><li>仅在必要时启用<code>supports_credentials</code></li><li>确保前端配置匹配（<code>credentials: &#39;include&#39;</code>）</li></ul><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="常见错误及解决方案"><a href="#常见错误及解决方案" class="headerlink" title="常见错误及解决方案"></a>常见错误及解决方案</h3><ol><li><strong>CORS策略违规</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Access to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; <br>has been blocked by CORS policy<br></code></pre></td></tr></table></figure>解决方案：</li></ol><ul><li>检查环境变量是否正确设置</li><li>验证前端请求URL与配置是否匹配</li><li>确认所有必要的请求头都已配置</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://fetch.spec.whatwg.org/?locale=zh_CN">W3C CORS Specification</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN Web Docs - Cross-Origin Resource Sharing</a></li><li><a href="https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN">Flask-CORS Official Documentation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端交互</tag>
      
      <tag>网站开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pip-tools</title>
    <link href="/2025/01/15/pip-tools/"/>
    <url>/2025/01/15/pip-tools/</url>
    
    <content type="html"><![CDATA[<h1 id="Python依赖管理利器：pip-tools完全指南"><a href="#Python依赖管理利器：pip-tools完全指南" class="headerlink" title="Python依赖管理利器：pip-tools完全指南"></a>Python依赖管理利器：pip-tools完全指南</h1><blockquote><p> 本文由 <em>Claude 3.5 Sonnet</em> 协助生成.</p></blockquote><p><img src="https://img.shields.io/badge/Python-3.6+-blue.svg" alt="Python Version"><br><img src="https://img.shields.io/badge/pip--tools-6.13.0-green.svg" alt="pip-tools"></p><p>在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致”在我这里能运行”的经典问题。<br><img src="/img/2025-01-16-23-58-21.png" width="70%" /><br>针对上述问题, 本文将详细介绍如何使用 <code>pip-tools</code>，实现精确的依赖版本控制。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#为什么需要-pip-tools">为什么需要 pip-tools？</a></li><li><a href="#环境准备">环境准备</a></li><li><a href="#pip-tools-的安装与使用">pip-tools 的安装与使用</a></li><li><a href="#最佳实践">最佳实践</a></li><li><a href="#常见问题解决">常见问题解决</a></li><li><a href="#高级用法">高级用法</a></li></ol><h2 id="为什么需要-pip-tools？"><a href="#为什么需要-pip-tools？" class="headerlink" title="为什么需要 pip-tools？"></a>为什么需要 pip-tools？</h2><p>传统的依赖管理方式存在以下问题：</p><ul><li><code>requirements.txt</code> 手动维护容易出错</li><li>间接依赖版本难以控制</li><li>团队成员环境不一致</li><li>依赖更新流程繁琐</li></ul><p><code>pip-tools</code> 通过以下特性解决这些问题：</p><ul><li>自动生成完整的依赖关系</li><li>锁定所有依赖的具体版本</li><li>支持开发环境和生产环境分离</li><li>提供简单的依赖更新机制</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="1-创建虚拟环境"><a href="#1-创建虚拟环境" class="headerlink" title="1. 创建虚拟环境"></a>1. 创建虚拟环境</h3><p>首先，我们需要创建一个独立的 Python 虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 virtualenv（如果还没有安装）</span><br>pip install virtualenv<br><br><span class="hljs-comment"># 创建虚拟环境</span><br>virtualenv venv<br><br><span class="hljs-comment"># 激活虚拟环境</span><br><span class="hljs-comment"># Linux/macOS:</span><br><span class="hljs-built_in">source</span> venv/bin/activate<br><span class="hljs-comment"># Windows:</span><br>.\venv\Scripts\activate<br></code></pre></td></tr></table></figure><h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h3><p>推荐的项目结构如下：</p><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mizar">my_project/<br>├── venv/<br>├── <span class="hljs-keyword">requirements</span>.<span class="hljs-keyword">in</span><br>├── <span class="hljs-keyword">requirements</span>.txt<br>├── <span class="hljs-keyword">requirements</span>-dev.<span class="hljs-keyword">in</span>   # 可选：开发环境依赖<br>├── <span class="hljs-keyword">requirements</span>-dev.txt  # 可选：开发环境依赖锁定文件<br>└── src/<br></code></pre></td></tr></table></figure><h2 id="pip-tools-的安装与使用"><a href="#pip-tools-的安装与使用" class="headerlink" title="pip-tools 的安装与使用"></a>pip-tools 的安装与使用</h2><h3 id="1-安装-pip-tools"><a href="#1-安装-pip-tools" class="headerlink" title="1. 安装 pip-tools"></a>1. 安装 pip-tools</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pip-tools<br></code></pre></td></tr></table></figure><h3 id="2-创建依赖文件"><a href="#2-创建依赖文件" class="headerlink" title="2. 创建依赖文件"></a>2. 创建依赖文件</h3><p>创建 <code>requirements.in</code> 文件，列出直接依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># requirements.in</span><br>flask<br>python-dotenv<br>openai<br>markdown-it-py<br>fairy-doc[cpu]<br></code></pre></td></tr></table></figure><blockquote><p>注意, 此处不同的依赖包必须分行呈现.</p></blockquote><h3 id="3-生成锁定文件"><a href="#3-生成锁定文件" class="headerlink" title="3. 生成锁定文件"></a>3. 生成锁定文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 requirements.txt</span><br>pip-compile requirements.in<br><br><span class="hljs-comment"># 如果有开发依赖</span><br>pip-compile requirements-dev.in<br></code></pre></td></tr></table></figure><p>生成的 <code>requirements.txt</code> 示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#</span><br><span class="hljs-comment"># This file is autogenerated by pip-compile</span><br><span class="hljs-comment"># To update, run:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#    pip-compile requirements.in</span><br><span class="hljs-comment">#</span><br>flask==2.3.3<br>  --<span class="hljs-built_in">hash</span>=sha256:...<br>python-dotenv==1.0.0<br>  --<span class="hljs-built_in">hash</span>=sha256:...<br>openai==0.27.8<br>  --<span class="hljs-built_in">hash</span>=sha256:...<br>markdown-it-py==3.0.0<br>  --<span class="hljs-built_in">hash</span>=sha256:...<br>fairy-doc[cpu]==1.2.0<br>  --<span class="hljs-built_in">hash</span>=sha256:...<br></code></pre></td></tr></table></figure><h3 id="4-安装依赖"><a href="#4-安装依赖" class="headerlink" title="4. 安装依赖"></a>4. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装所有依赖</span><br>pip-sync requirements.txt<br><br><span class="hljs-comment"># 如果同时需要开发依赖</span><br>pip-sync requirements.txt requirements-dev.txt<br></code></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># requirements.in</span><br>flask&gt;=2.0.0,&lt;3.0.0  <span class="hljs-comment"># 指定版本范围</span><br>python-dotenv~=1.0.0  <span class="hljs-comment"># 允许补丁版本更新</span><br>openai==0.27.8       <span class="hljs-comment"># 锁定具体版本</span><br></code></pre></td></tr></table></figure><h3 id="2-依赖分组"><a href="#2-依赖分组" class="headerlink" title="2. 依赖分组"></a>2. 依赖分组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># requirements-dev.in</span><br>-r requirements.in    <span class="hljs-comment"># 包含基础依赖</span><br>pytest               <span class="hljs-comment"># 测试框架</span><br>black                <span class="hljs-comment"># 代码格式化</span><br>flake8               <span class="hljs-comment"># 代码检查</span><br></code></pre></td></tr></table></figure><h3 id="3-更新依赖"><a href="#3-更新依赖" class="headerlink" title="3. 更新依赖"></a>3. 更新依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新单个包</span><br>pip-compile --upgrade-package flask requirements.in<br><br><span class="hljs-comment"># 更新所有包</span><br>pip-compile --upgrade requirements.in<br></code></pre></td></tr></table></figure><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h2><h3 id="1-依赖冲突"><a href="#1-依赖冲突" class="headerlink" title="1. 依赖冲突"></a>1. 依赖冲突</h3><p>如果遇到依赖冲突，可以：</p><ul><li>检查 <code>requirements.in</code> 中的版本约束</li><li>使用 <code>pip-compile --verbose</code> 查看详细信息</li><li>考虑降级某些包的版本</li></ul><h3 id="2-Hash-不匹配"><a href="#2-Hash-不匹配" class="headerlink" title="2. Hash 不匹配"></a>2. Hash 不匹配</h3><p>如果出现 hash 不匹配：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure></p><h3 id="3-环境不一致"><a href="#3-环境不一致" class="headerlink" title="3. 环境不一致"></a>3. 环境不一致</h3><p>确保团队成员：</p><ul><li>使用相同的 Python 版本</li><li>严格执行 <code>pip-sync</code></li><li>不要手动 <code>pip install</code></li></ul><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="1-自定义输出格式"><a href="#1-自定义输出格式" class="headerlink" title="1. 自定义输出格式"></a>1. 自定义输出格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成带注释的依赖文件</span><br>pip-compile --annotate requirements.in<br><br><span class="hljs-comment"># 生成带 hashes 的依赖文件</span><br>pip-compile --generate-hashes requirements.in<br></code></pre></td></tr></table></figure><h3 id="2-多环境配置"><a href="#2-多环境配置" class="headerlink" title="2. 多环境配置"></a>2. 多环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开发环境</span><br>pip-compile requirements-dev.in<br><br><span class="hljs-comment"># 生产环境</span><br>pip-compile requirements.in --output-file requirements-prod.txt<br></code></pre></td></tr></table></figure><h3 id="3-依赖更新策略"><a href="#3-依赖更新策略" class="headerlink" title="3. 依赖更新策略"></a>3. 依赖更新策略</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只更新安全相关的包</span><br>pip-compile --upgrade-package flask --upgrade-package <span class="hljs-string">&quot;requests&gt;=2.31.0&quot;</span><br><br><span class="hljs-comment"># 保持现有版本</span><br>pip-compile --no-upgrade requirements.in<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过使用 <code>pip-tools</code>，我们可以：</p><ul><li>实现精确的依赖版本控制</li><li>简化依赖管理流程</li><li>确保团队环境一致性</li><li>提高项目的可维护性</li></ul><p>希望这篇指南能帮助你更好地管理 Python 项目的依赖！<br><img src = "/img/great.jpg" width = "70%"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/jazzband/pip-tools">pip-tools 官方文档</a></li><li><a href="https://packaging.python.org/">Python Packaging User Guide</a></li><li><a href="https://www.python.org/dev/peps/pep-0508/">PEP 508 – Dependency specification for Python Software Packages</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>通用技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晚霞</title>
    <link href="/2025/01/09/poets/%E6%99%9A%E9%9C%9E/"/>
    <url>/2025/01/09/poets/%E6%99%9A%E9%9C%9E/</url>
    
    <content type="html"><![CDATA[<p><br></p><p style = "     font-size: 1.3em;    text-align: center;    line-height: 2em;">白昼飞红了她的<span style = "color: #fe4017">脸颊</span> <br>以隐匿于远山之后的凝望<br>  默默期待着  <br>月色的降临🌔</p><p><img src = "/img/晚霞.jpg" width = "70%"></p>]]></content>
    
    
    <categories>
      
      <category>随机掉落的文字碎片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短诗</tag>
      
      <tag>自然</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2025/01/09/JavaScript/"/>
    <url>/2025/01/09/JavaScript/</url>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「<strong>料理的加护</strong>」下, 尽可能将JS处理得更加<strong>可口</strong>一些)<br><img src="/img/料理的加护.jpg" width = "35%"></p></blockquote><h1 id="创建JS代码块"><a href="#创建JS代码块" class="headerlink" title="创建JS代码块"></a>创建JS代码块</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="var-or-let"><a href="#var-or-let" class="headerlink" title="var or let?"></a><code>var</code> or <code>let</code>?</h3><p><code>var</code>先于<code>let</code>的产生, 后者是现代版本的JS中新的关键字.</p><p>使用<code>var</code>, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是<code>let</code>并不适用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">myName = <span class="hljs-string">&quot;Chris&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName);<br>&#125;<br><br><span class="hljs-title function_">logName</span>(); <span class="hljs-comment">//输出&quot;Chris&quot;</span><br><br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;Aniya&quot;</span>;<br><span class="hljs-title function_">logName</span>(); <span class="hljs-comment">//输出&quot;Aniya&quot;</span><br></code></pre></td></tr></table></figure></p><p>除此之外, 可以使用<code>var</code>前后声明相同的变量, 这并不会报错:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;Chris&quot;</span>;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p><p>而<code>let</code>只能声明一次:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot;Chris&quot;</span>;<br>myName = <span class="hljs-string">&quot;Bob&quot;</span>;<br></code></pre></td></tr></table></figure></p><p>因此, 在代码编写中应尽量<strong>多使用</strong><code>let</code>而非<code>var</code>, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.</p><h3 id="变量命名的规则"><a href="#变量命名的规则" class="headerlink" title="变量命名的规则"></a>变量命名的规则</h3><p>与C语言类似, 建议以 <strong>字母、数字、下划线</strong> 组成的标识符来命名变量.</p><ul><li>不可用<code>_</code>开头, 因为可能被JS设计为特殊的含义;</li><li>不可用数字开头, 否则引发错误;</li><li>大小写敏感;</li><li>建议采用 <strong>小写驼峰命名法</strong> ,即小写整个命名的第一个字母然后大写剩下单词的首字符;</li><li>避免使用保留字, 比如<code>var</code>,<code>let</code>,<code>for</code>等.</li></ul><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myAge = <span class="hljs-number">20</span> ;<span class="hljs-comment">// 数字</span><br><span class="hljs-keyword">let</span> dolphinGoodbye = <span class="hljs-string">&quot;So long and thanks for all the fish&quot;</span>; <span class="hljs-comment">// 字符串</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-number">6</span> &lt; <span class="hljs-number">3</span>; <span class="hljs-comment">//boolean</span><br><br><span class="hljs-comment">//数组类型</span><br><span class="hljs-keyword">let</span> myNameArray = [<span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Jim&quot;</span>];<br><span class="hljs-keyword">let</span> myNumberArray = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">40</span>];<br><br><span class="hljs-comment">//对象类型</span><br><span class="hljs-keyword">let</span> dog = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Spot&quot;</span>, <span class="hljs-attr">breed</span>: <span class="hljs-string">&quot;Dalmatian&quot;</span> &#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>对象类型的访问与结构体相似, <code>dog.name;</code></p></blockquote><p>在上面的几种变量类型中, 我们都采用<code>let</code>关键字声明变量, 这体现了JS是一种 <strong>动态类型语言</strong> ,即无需指定变量包含的数据类型.</p><p>同时, 这也意味着我们可以像<code>python</code>一样对同一个变量先后赋值不同类型的值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myNumber = <span class="hljs-string">&quot;500&quot;</span>;<br><span class="hljs-keyword">typeof</span> myNumber;<br><span class="hljs-comment">// 输出 &#x27;string&#x27;</span><br><br>myNumber = <span class="hljs-number">500</span>; <br><span class="hljs-keyword">typeof</span> myNumber;<br><span class="hljs-comment">//输出&#x27;number&#x27;</span><br></code></pre></td></tr></table></figure></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>$\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">exampleFunction</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">exampleFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数内&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于 <strong>提升</strong> 的存在, 上述的函数调用不会出错.</p></blockquote></li></ul><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在编写函数时, 可以通过在参数名称后添加<code>=</code>, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeding</span>(<span class="hljs-params">name = <span class="hljs-string">&quot;my friend&quot;</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><span class="hljs-title function_">hello</span>(); <span class="hljs-comment">//Hello, my friend!</span><br><span class="hljs-title function_">hello</span>(<span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">//Hello, world!</span><br></code></pre></td></tr></table></figure></p><p><br></p><p>事件处理函数的默认接受值是<code>event</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span><br>onclick<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>nothing here<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>)</span><br><span class="language-javascript">para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;p&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">btn.<span class="hljs-property">onclick</span> = click;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">string</span>)&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;clicked!&quot;</span>)</span><br><span class="language-javascript">  para.<span class="hljs-property">textContent</span> = string;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p><ol><li>上述的<code>btn</code>在点击之后调用函数<code>click</code>, 该函数需要一个参数<code>string</code>, 由于<code>btn.onclick = click;</code>的绑定方式, 我们无法指定传参的值, 因此点击之后的<code>para</code>的内容显示为: <code>[object PointerEvent]</code>;</li><li><code>textContent</code>是属性而非方法, 因此采用赋值实现;</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">string</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;clicked!&quot;</span>)<br>  para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;You have clicked the button!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>将上述的绑定方式如此改写, 可以在<code>btn</code>外对<code>string</code>进行赋值, 然后点击按钮可以传入指定参数供后续处理.</p></blockquote><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在了解箭头函数的作用之前, 需要先介绍 $\underline{匿名函数}$:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 匿名函数</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p><blockquote><p>正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.</p></blockquote><p>如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logKey</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You pressed &quot;<span class="hljs-subst">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;<br><br>textBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, logKey);<br></code></pre></td></tr></table></figure><br>这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">textBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You pressed &quot;<span class="hljs-subst">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p><blockquote><p>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.</p></blockquote><p>而<strong>箭头函数</strong>则是在此情况下更简洁的函数定义方式:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">textBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You pressed &quot;<span class="hljs-subst">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br><br><span class="hljs-comment">//如果函数只接受一个参数, 也可以省略参数周围的括号</span><br>textBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`You pressed &quot;<span class="hljs-subst">$&#123;event.key&#125;</span>&quot;.`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>如果只包含一行的<code>return</code>,则可以忽略<code>&#123;&#125;</code>和<code>return</code>关键字:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> originals = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">const</span> doubled = originals.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure></p><blockquote><p><code>item =&gt; item * 2</code>等价于:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doubleItem</span>(<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h4 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textBox&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> textBox = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#textBox&quot;</span>);<br><span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#output&quot;</span>);<br><br>textBox.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  output.<span class="hljs-property">textContent</span> = <span class="hljs-string">`You pressed &quot;<span class="hljs-subst">$&#123;event.key&#125;</span>&quot;.`</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>通过监听输入框的keydown事件, 输出按下的键盘按键.</p><h3 id="函数作用域和冲突"><a href="#函数作用域和冲突" class="headerlink" title="函数作用域和冲突"></a>函数作用域和冲突</h3><p>$\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p><ul><li>全局作用域: 脚本模式运行所有代码的默认作用域;</li><li>模块作用域: 模块模式中运行代码的作用域;</li><li>函数作用域: 由函数创建的作用域</li></ul><p>和C语言相似, 在函数外部<code>let</code>定义的变量, 以及<code>const</code>定义的常量可以在函数内部访问.</p><p>如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Excerpt from my HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;first.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;second.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>  greeting();<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p><blockquote><p>如果两个JS文件都定义了<code>greeting</code>函数, 则只有第一个文件中的函数才会被调用.</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数字和操作符"><a href="#数字和操作符" class="headerlink" title="数字和操作符"></a>数字和操作符</h3><p>大部分与C语言相同, 概括需要注意的差异:</p><ul><li>JS当中只有一种数字类型 — <code>number</code>, 对于整型或者浮点数的初始化得到的量, 由<code>typeof</code>均得到<code>number</code>;</li><li>算术运算符: 求幂为<code>**</code>;</li><li>常量无法使用自增或自减,<del>好像也是C语言的 忘了</del></li><li><code>===</code>表示严格等于, <code>!==</code>表示不等于;<blockquote><p>同时存在<code>==</code>和<code>!=</code>来判断是否相等, 但是它们只是测试 <strong>值</strong> 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用<code>===</code>和<code>!==</code>来避免类型不一致的错误.</p></blockquote></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>创建字符串<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myString = <span class="hljs-string">&quot;A string&quot;</span>;<br><span class="hljs-keyword">const</span> constString = myString;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(constString);<br><span class="hljs-comment">//A string</span><br></code></pre></td></tr></table></figure><br>可以使用单引号,双引号和<strong>反引号</strong>来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> single = <span class="hljs-string">&#x27;单引号&#x27;</span>;<br><span class="hljs-keyword">const</span> double = <span class="hljs-string">&quot;双引号&quot;</span>;<br><span class="hljs-keyword">const</span> backtick = <span class="hljs-string">`反引号`</span>;<br></code></pre></td></tr></table></figure></p><p>反引号包裹的字符串称为$\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:</p><ul><li>可以嵌入 <strong>JavaScript</strong>;</li><li>可以声明<strong>多行</strong>的模板字面量.</li></ul><h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><p>字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\underline{串联法}$:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;克里斯&quot;</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`你好，<span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p><blockquote><p>在模板字面量中用<code>$&#123;&#125;</code>包装JS的变量或者表达式.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> one = <span class="hljs-string">&quot;你好，&quot;</span>;<br><span class="hljs-keyword">const</span> two = <span class="hljs-string">&quot;请问最近如何？&quot;</span>;<br><span class="hljs-keyword">const</span> joined = <span class="hljs-string">`<span class="hljs-subst">$&#123;one&#125;</span><span class="hljs-subst">$&#123;two&#125;</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(joined); <span class="hljs-comment">// &quot;你好，请问最近如何？&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>连接2个变量.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> song = <span class="hljs-string">&quot;青花瓷&quot;</span>;<br><span class="hljs-keyword">const</span> score = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">const</span> highestScore = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> output = <span class="hljs-string">`我喜欢歌曲《<span class="hljs-subst">$&#123;song&#125;</span>》。我给它打了 <span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">  (score / highestScore) * <span class="hljs-number">100</span></span></span><br><span class="hljs-subst"><span class="hljs-string">&#125;</span> 分。`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(output); <span class="hljs-comment">// &quot;我喜欢歌曲《青花瓷》。我给它打了 90 分。&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>在模板字面量的<code>$&#123;&#125;</code>内部包含表达式.</p></blockquote><p><br><br>除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用<code>+</code>直接连接:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&quot;你好&quot;</span>;<br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;克里斯&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting + <span class="hljs-string">&quot;，&quot;</span> + name); <span class="hljs-comment">// &quot;你好，克里斯&quot;</span><br></code></pre></td></tr></table></figure></p><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>模板字符串会<strong>保留</strong>源代码中的换行符，因此可以编写跨越多行的字符串:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newline = <span class="hljs-string">`终于有一天，</span><br><span class="hljs-string">你知道了必须做的事情，而且开始……`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newline);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">终于有一天，</span><br><span class="hljs-comment">你知道了必须做的事情，而且开始……</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><p>如果希望用普通的字符串得到等效的输出, 必须在字符串中包含<code>\n</code>,而非直接跨行:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newline = <span class="hljs-string">&quot;终于有一天，\n你知道了必须做的事情，而且开始……&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newline);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">终于有一天，</span><br><span class="hljs-comment">你知道了必须做的事情，而且开始……</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></p><h4 id="显示引号"><a href="#显示引号" class="headerlink" title="显示引号"></a>显示引号</h4><ol><li>$\underline{转义}$  通过在符号前加上反斜杠<code>\</code>, 可以转义字符串中的特殊字符,包括字符串中的引号:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bigmouth = <span class="hljs-string">&#x27;I\&#x27;ve got no right to take my place…&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>换用其他字符: 在字面量内用不同于包裹字符串的引号:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> goodQuotes1 = <span class="hljs-string">&#x27;She said &quot;I think so!&quot;&#x27;</span>;<br><span class="hljs-keyword">const</span> goodQuotes2 = <span class="hljs-string">`She said &quot;I&#x27;m not going in there!&quot;`</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>对于字符串对象实例,其常用的方法:</p><ul><li><code>.length</code>: 获取字符串的长度;</li><li><code>[]</code>: 返回字符串中对应索引的字符, 索引同样从<code>0</code>开始;</li><li><code>.indexOf(&quot;&quot;)</code>: 查找子字符串<ul><li><strong>input</strong>: 希望查找的子字符串;</li><li><strong>output</strong>: 子字符串开始的下标(如果不存在则返回<code>-1</code>);</li></ul></li><li><code>.slice(indedxStart, indexEnd)</code>: 截取字符串<ul><li><strong>input</strong>: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;</li><li><strong>output</strong>: 截取的子字符串;</li></ul></li></ul><p>更多的<code>slice</code>知识:</p><ol><li>$\underline{标准化负值}$ 如果索引是个负数, 取<code>index+str.length</code>进行标准化;</li><li>如果<code>indexStart</code>大于<code>str.length</code>, 返回空字符串;</li><li>如果标准化负值之后, <code>indexStart</code>大于<code>indexEnd</code>, 也返回空字符串;</li></ol><ul><li><code>.toLowerCase()</code> &amp; <code>.toUpperCase()</code>: 转换字符串中的所有字符为小写或大写;</li><li><code>.replace(original, new)</code>: 替换字符串中<code>original</code>子字符串为<code>new</code>;<blockquote><p>此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.</p></blockquote></li></ul><h4 id="Cases"><a href="#Cases" class="headerlink" title="Cases"></a>Cases</h4><p>利用 <strong>indexOf</strong> 和 <strong>slice</strong> 方法, 获取新字符串:</p><ul><li><strong>input</strong>: <code>&quot;str3&quot;</code>三位长字符串+<code>&quot;...&quot;</code>(无关字符串)+<code>&quot;;&quot;</code>+<code>strLast</code>(剩余字符串);</li><li><strong>output</strong>: <code>&quot;str3&quot;+&quot;;&quot;+strLast</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> stations = [<span class="hljs-string">&#x27;MAN675847583748sjt567654;Manchester Piccadilly&#x27;</span>,<br>                <span class="hljs-string">&#x27;GNF576746573fhdg4737dh4;Greenfield&#x27;</span>,<br>                <span class="hljs-string">&#x27;LIV5hg65hd737456236dch46dg4;Liverpool Lime Street&#x27;</span>,<br>                <span class="hljs-string">&#x27;SYB4f65hf75f736463;Stalybridge&#x27;</span>,<br>                <span class="hljs-string">&#x27;HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield&#x27;</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; stations.<span class="hljs-property">length</span>; i++)&#123;<br>    <span class="hljs-keyword">var</span> input = stations[i];<br>    <span class="hljs-keyword">var</span> str3 = input.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">var</span> strLast = input.<span class="hljs-title function_">slice</span>(input.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;;&quot;</span>)+<span class="hljs-number">1</span>); <span class="hljs-comment">//indexOf获取;位置</span><br>    <span class="hljs-keyword">var</span> output = str3 + <span class="hljs-string">&quot;;&quot;</span> + strLast;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>通过 <strong>indexOf</strong> 根据子字符串筛选字符串数组:</p><ul><li><strong>input</strong>: 可能包含 <em>Christmas</em> 的字符串数组;</li><li><strong>output</strong>: 包含 <em>Christmas</em> 的字符串数组;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.output ul&#x27;</span>);<br>list.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">var</span> greetings = [<span class="hljs-string">&#x27;Happy Birthday!&#x27;</span>,<br>                 <span class="hljs-string">&#x27;Merry Christmas my love&#x27;</span>,<br>                 <span class="hljs-string">&#x27;A happy Christmas to all the family&#x27;</span>,<br>                 <span class="hljs-string">&#x27;You\&#x27;re all I want for Christmas&#x27;</span>,<br>                 <span class="hljs-string">&#x27;Get well soon&#x27;</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; greetings.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-keyword">var</span> input = greetings[i];<br>  <span class="hljs-keyword">if</span>(greetings[i].<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Christmas&#x27;</span>) !== -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">var</span> result = input;<br>    <span class="hljs-keyword">var</span> listItem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>    listItem.<span class="hljs-property">textContent</span> = result;<br>    list.<span class="hljs-title function_">appendChild</span>(listItem);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h3><h4 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h4><p>非常神奇, 在JS当中, 数字和字符串可以直接通过函数<code>Number()</code>和<code>String()</code>进行转换, 与C语言不同.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myString = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-keyword">const</span> myNum = <span class="hljs-title class_">Number</span>(myString);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myNum);<br><span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myNum);<br><span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myNum2 = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">const</span> myString2 = <span class="hljs-title class_">String</span>(myNum2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> myString2);<br><span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myString2);<br><span class="hljs-comment">// &quot;123&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>对于浮点数同样成立.</p></blockquote><h4 id="前后拼接"><a href="#前后拼接" class="headerlink" title="前后拼接"></a>前后拼接</h4><p>使用<code>+</code>将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Front &quot;</span>;<br><span class="hljs-keyword">const</span> number = <span class="hljs-number">242</span>;<br><span class="hljs-keyword">const</span> combine = name + number;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combine); <span class="hljs-comment">//Front 242</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(combine));  <span class="hljs-comment">//string</span><br></code></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>存储任意类型元素—字符串，数字，对象，变量，<strong>另一个数组</strong>;</li><li>可以 <strong>混合</strong> 元素类型:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> random = [<span class="hljs-string">&quot;tree&quot;</span>, <span class="hljs-number">795</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]];<br></code></pre></td></tr></table></figure></li><li>像访问字符串一样, 利用索引访问数组元素;</li><li>$\underline{多维数组}$ 包含数组的数组结构称为~</li></ol><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><ul><li>作用: 将一个字符串根据给定的字符分隔为字符串数组;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myData = <span class="hljs-string">&quot;Manchester,London,Liverpool,Birmingham,Leeds,Carlisle&quot;</span>;<br><span class="hljs-keyword">let</span> myArray = myData.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray);<br> <span class="hljs-comment">// [&quot;Manchester&quot;, &quot;London&quot;, &quot;Liverpool&quot;, &quot;Birmingham&quot;, &quot;Leeds&quot;, &quot;Carlisle&quot;]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p><code>split</code>的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myNewString = myArray.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>myNewString;<br></code></pre></td></tr></table></figure></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>与<code>join</code>方法相似, 但是无法自定义分隔符, 默认为<code>,</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> dogNames = [<span class="hljs-string">&quot;Rocket&quot;</span>, <span class="hljs-string">&quot;Flash&quot;</span>, <span class="hljs-string">&quot;Bella&quot;</span>, <span class="hljs-string">&quot;Slugger&quot;</span>];<br>dogNames.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//Rocket,Flash,Bella,Slugger</span><br></code></pre></td></tr></table></figure></p><h4 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push &amp; pop"></a>push &amp; pop</h4><p><code>push()</code>方法可以将1或多个元素添加到数组的 <strong>末尾</strong>:</p><ol><li>将会直接改写原来的数组,不需要重新赋值;</li><li>该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> newLength = myArray.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>,<span class="hljs-string">&quot;string&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray); <span class="hljs-comment">// [1, 2, 3, 4, 5, &quot;string&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newLength); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li></ol><p>使用<code>.pop()</code>从数组中删除最后一个元素:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">myArray.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">//&quot;string&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></p><ol><li>方法调用返回值就是删除的元素本身;</li><li>直接对原始数组操作并赋值, 不需要另外的赋值操作;</li></ol><blockquote><p>shift &amp; unshift:<br>在功能上分别与<code>push</code>和<code>pop</code>相同, 但是作用于数组的开始位置.</p></blockquote><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:</p><h3 id="天气预报"><a href="#天气预报" class="headerlink" title="天气预报"></a>天气预报</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;weather&quot;</span>&gt;</span>选择今天的天气：&lt;/label<br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;weather&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>--作出选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sunny&quot;</span>&gt;</span>晴天<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rainy&quot;</span>&gt;</span>雨天<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;snowing&quot;</span>&gt;</span>雪天<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;overcast&quot;</span>&gt;</span>阴天<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>lable</code>当中的<code>for</code>标签与<code>select</code>标签的<code>id</code>属性对应, 用于关联两个标签.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> select = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;select&quot;</span>);<br><span class="hljs-keyword">const</span> para = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;p&quot;</span>);<br><br>select.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, setWeather);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setWeather</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> choice = select.<span class="hljs-property">value</span>;<br><br>  <span class="hljs-keyword">switch</span> (choice) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sunny&quot;</span>:<br>      para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。&quot;</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;rainy&quot;</span>:<br>      para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;外面下着雨；带上雨衣和雨伞，不要在外面呆太久。&quot;</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;snowing&quot;</span>:<br>      para.<span class="hljs-property">textContent</span> =<br>        <span class="hljs-string">&quot;大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。&quot;</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;overcast&quot;</span>:<br>      para.<span class="hljs-property">textContent</span> =<br>        <span class="hljs-string">&quot;虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。&quot;</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      para.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>通过<code>querySelector</code>方法获取<code>select</code>和<code>p</code>标签;</li><li>然后为<code>select</code>标签添加事件监听器, 当内容改变时触发 <strong>change</strong> 事件, 同时调用<code>setWeather</code>函数;</li><li>进而通过 <strong>switch</strong> 语句处理不同天气的情况, 并设置相应的文字内容;<br>在线网页示例:<a href="https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html">simple-switch</a></li></ol></blockquote><h2 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h2><p>什么是$\underline{事件}$? </p><ul><li>用户选择、点击或者光标悬停在某一元素;</li><li>用户在键盘中按下某个按键;</li><li>网页结束加载;</li><li>…</li></ul><p>$\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.</p><h3 id="处理点击事件"><a href="#处理点击事件" class="headerlink" title="处理点击事件"></a>处理点击事件</h3><p>以点击事件为例, 介绍html与js如何进行事件处理的交互:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span> 改变颜色 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">random</span>(<span class="hljs-params">number</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*(number+<span class="hljs-number">1</span>));<br>  <br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>,<span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>,<span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>)`</span>;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>&#125;)<br></code></pre></td></tr></table></figure></p><ol><li><code>Math.random()</code>方法生成一个介于[0,1)之间的随机数;</li><li><code>*(number+1)</code>之后利用向下取整的方法<code>Math.floor()</code>将其转换为整数, 范围为[0,number];<blockquote><p>假如输入的number为<code>4</code>, 则<code>random(4)</code>的结果可能为<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>中的一个;<br>假设输入的number为<code>3.6</code>, 则输出的结果还是0~4中的整数.</p></blockquote></li><li><code>rndCol = `rgb($&#123;random(255)&#125;,$&#123;random(255)&#125;,$&#123;random(255)&#125;)</code> 采用的是在$\underline{模板字符串}$内部使用<code>$&#123;&#125;</code>调用函数变量的方法.</li></ol><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h3><p><code>adEventListener</code>方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.</p><p>通过<code>EventTarget.adddEventListener()</code>的方法, 将指定的监听器注册到对象上, 具体的语法如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addEventListener</span>(type, listener);<br><span class="hljs-title function_">addEventListener</span>(type, listener, options);<br><span class="hljs-title function_">addEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p><ul><li><code>type</code>: 事件类型, 如<code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>等;</li><li><code>listener</code>: 事件处理函数, 该函数将在事件发生时被调用;<ul><li>包括 <strong>回调函数</strong> 以及 实现了 <strong>EventListener 接口的对象</strong>;</li></ul></li><li><code>options</code>: 可选参数, 用于配置事件监听器的行为;<blockquote><p>可以为单个事件添加多个事件监听器.</p><h4 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h4></blockquote></li></ul><p>$\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.</p><ul><li>是一个函数, 但是只有等到特定的事件发生时才会执行.</li></ul><p>$\underline{实现了 EventListener 接口的对象}$ </p><ul><li><strong>特点</strong>: 以对象作为listener, 对象中具有名为<code>handleEvent()</code>的方法;</li><li><strong>作用</strong>: <ul><li>将事件处理封装到一个对象当中, 可以更好地组织代码;</li><li>便于在对象中保存更多的状态信息;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> listenerObject = &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-title function_">handleEvent</span>(<span class="hljs-params">event</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`事件类型是：<span class="hljs-subst">$&#123;event.type&#125;</span>，已触发 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span> 次`</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, listenerObject);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>一个指定有关 listener 属性的可选参数对象.</p><h5 id="Capture"><a href="#Capture" class="headerlink" title="Capture"></a>Capture</h5><ul><li><p>含义:</p><ul><li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;</li><li>默认为false, 表示只有在冒泡阶段才触发.</li></ul></li><li><p>区别:</p><ul><li><code>capture</code>和<code>useCapture</code>实际上指的都是 <strong>监听器是否在捕获阶段触发</strong> 的布尔值.<blockquote><p>捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.</p></blockquote></li><li>后来DOM的规范更新时引入了<code>options</code>参数, 此后<code>capture</code>取代了<code>useCapture</code>的作用.</li><li>如果<code>addEventListener</code>的第三个参数不指定对象, 只有布尔值, 那么默认是在设置<code>useCapture</code></li></ul></li></ul><blockquote><p>可以先查看<a href="#事件传播的阶段">事件传播的阶段</a>来辅助理解不同的阶段.</p></blockquote><h5 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h5><ul><li>含义:<ul><li>一个布尔值，表示 listener 在添加之后最多只调用一次;</li><li>默认为false, 表示可以多次调用.</li></ul></li><li>e.g.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;,&#123;<span class="hljs-attr">once</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><code>once</code>属性被设置为<code>true</code>, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.</p></blockquote></li></ul><h5 id="Passive"><a href="#Passive" class="headerlink" title="Passive"></a>Passive</h5><ul><li><p>含义:</p><ul><li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();</li></ul></li><li><p>作用:</p><ul><li>明确不会在<code>listener</code>中不会调用<code>preventDefault()</code>方法, 即不会阻止浏览器的<a href="#默认行为">默认行为</a>;</li><li>此时, 浏览器可以直接渲染默认行为的结果, 无需等待<code>listener</code>的执行与默认行为的检查, 从而提高了性能.</li></ul></li><li>Notice:<ul><li>如果设置<code>passive</code>为<code>true</code>, 则<code>listener</code>当中不可出现<code>preventDefault()</code>方法, 否则会报错.</li></ul></li></ul><p>e.g.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>event.<span class="hljs-title function_">preventDefault</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span>&#125;);<br></code></pre></td></tr></table></figure></p><ul><li><code>wheel</code>事件的默认行为是滚动页面;</li><li><code>event.preventDefault();</code>表示会阻止鼠标滚动带来的页面滚动;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  event.<span class="hljs-title function_">preventDefault</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;scrolling&quot;</span>);<br>&#125;,&#123;<span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p><code>passive</code>的设置与<code>listener</code>内部矛盾, 将会报错.</p></blockquote><h5 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h5><p>用于有条件地移除事件监听器, 具体使用参见<a href="#可被移除的监听器">可被移除的监听器</a>.</p><h3 id="事件传播的阶段"><a href="#事件传播的阶段" class="headerlink" title="事件传播的阶段"></a>事件传播的阶段</h3><ol><li>捕获阶段 $\underline{capture\space phase}$: 事件从根节点开始向目标节点传播;<blockquote><p>e.g. 点击事件从document开始传播, 经过html,body直到目标元素.</p></blockquote></li><li>目标阶段阶段 $\underline{target\space phase}$: 事件到达目标元素;</li><li>冒泡阶段 $\underline{bubble\space phase}$: 事件从目标元素开始沿着DOM树向上传播.</li></ol><h4 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>  parent<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#parent&#x27;</span>);<br><span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#child&#x27;</span>);<br><br>parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父元素 - 冒泡阶段&#x27;</span>);<br>&#125;);<br><br>parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>&#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);<br><br>child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子元素 - 目标阶段&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述的<code>child</code>被包裹在<code>parent</code>内部.</p><ul><li><p>当点击<code>parent</code>时将会显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;父元素 - 捕获阶段&quot;</span><br><span class="hljs-string">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;</p></blockquote></li><li><p>当点击<code>child</code>时将会显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;父元素 - 捕获阶段&quot;</span><br><span class="hljs-string">&quot;子元素 - 目标阶段&quot;</span><br><span class="hljs-string">&quot;父元素 - 冒泡阶段&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>child</code>是整个事件流的目标元素, 所以触发时机介于二者之间.</p></blockquote></li></ul><h4 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h4><ol><li><p>如果将<code>div</code>换成<code>button</code>, 则点击<code>child</code>时可能只会显示 <strong>目标</strong> 阶段的输出.</p><blockquote><p>这是因为, 不同浏览器对于<code>button</code>元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段</p></blockquote></li><li><p><code>event.stopPropagation();</code>加入该<del>咒语</del>代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">parent.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父元素 - 捕获阶段&#x27;</span>);<br>    event.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>此时, 点击<code>parent</code>时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.</p></blockquote></li></ol><h3 id="可被移除的监听器"><a href="#可被移除的监听器" class="headerlink" title="可被移除的监听器"></a>可被移除的监听器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outside&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;t1&quot;</span>&gt;</span>one<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;t2&quot;</span>&gt;</span>two<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 为 table 添加可被移除的事件监听器</span><br><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br>el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, modifyText, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br><br><span class="hljs-comment">// 改变 t2 内容的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyText</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> t2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;t2&quot;</span>);<br>  <span class="hljs-keyword">if</span> (t2.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span> === <span class="hljs-string">&quot;three&quot;</span>) &#123;<br>    t2.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span> = <span class="hljs-string">&quot;two&quot;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    t2.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span> = <span class="hljs-string">&quot;three&quot;</span>;<br>    controller.<span class="hljs-title function_">abort</span>(); <span class="hljs-comment">// 当值变为 &quot;three&quot; 后，移除监听器</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><code>AbortController</code>是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;</li><li><code>signal</code>属性是一个<code>AbortSignal</code>对象, 用于控制监听器的移除;</li><li><code>controller.abort()</code>方法用于移除监听器;</li><li>当<code>t2</code>的内容变为”three”时, 移除监听器, 使得<code>modifyText</code>函数不再执行. 此后, 点击<code>t2</code>不会触发<code>modifyText</code>函数.</li></ul></blockquote><p>具体的<strong>构造步骤:</strong></p><ol><li>创建一个<code>AbortController</code>实例: <code>const controller = new AbortController();</code></li><li>在事件监听器内的参数中添加<code>signal: controller.signal</code>选项;</li><li>在需要移除监听器的地方调用<code>controller.abort()</code>方法;</li></ol><hr><p>我们也可以直接使用<code>removeEventListener()</code>方法来移除事件监听器:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">removeEventListener</span>(type, listener);<br><span class="hljs-title function_">removeEventListener</span>(type, listener, options);<br><span class="hljs-title function_">removeEventListener</span>(type, listener, useCapture);<br></code></pre></td></tr></table></figure></p><ul><li>Notices:<ul><li>如果同一个对象上存在2个事件监听器, 且仅在<code>useCapture</code>参数存在差异, 那么需要先后2次调用<code>removeEventListener()</code>方法才能完全移除其事件监听器;</li><li>如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;</li><li><code>type</code>,<code>listener</code>参数必须完全匹配才能移除事件监听器;</li><li>对于<code>options</code>参数:<ul><li>字段相同: 一定可以移除;</li><li>字段不同: 需要与默认值false匹配才可以移除.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> &#125;);<br><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> &#125;); <span class="hljs-comment">// 成功</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">false</span> &#125;); <span class="hljs-comment">// 成功</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;); <span class="hljs-comment">// 失败</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;); <span class="hljs-comment">// 成功</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 成功</span><br>element.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, handleMouseDown, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 失败</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><p><strong>添加与移除</strong>的结合使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> body = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>);<br><span class="hljs-keyword">const</span> clickTarget = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;click-target&quot;</span>);<br><span class="hljs-keyword">const</span> mouseOverTarget = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;mouse-over-target&quot;</span>);<br><br><span class="hljs-keyword">let</span> toggle = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeBackgroundYellow</span>(<span class="hljs-params"></span>) &#123;<br>  body.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = toggle ? <span class="hljs-string">&quot;white&quot;</span> : <span class="hljs-string">&quot;yellow&quot;</span>;<br><br>  toggle = !toggle;<br>&#125;<br><br>clickTarget.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, makeBackgroundYellow, <span class="hljs-literal">false</span>);<br><br>mouseOverTarget.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  clickTarget.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, makeBackgroundYellow, <span class="hljs-literal">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></p><h3 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h3><p>在上述<code>html</code>例子下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 改变 t2 内容的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyText</span>(<span class="hljs-params">new_text</span>) &#123;<br>  <span class="hljs-keyword">const</span> t2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;t2&quot;</span>);<br>  t2.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span> = new_text;<br>&#125;<br><br><span class="hljs-comment">// 用匿名函数为 table 添加事件监听器</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br>el.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">modifyText</span>(<span class="hljs-string">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span>,<br>);<br></code></pre></td></tr></table></figure><br>通过匿名函数封装代码, 将参数传入函数<code>modifyText</code>, 使得函数可以被调用.</p><h3 id="使用箭头函数"><a href="#使用箭头函数" class="headerlink" title="使用箭头函数"></a>使用箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 改变 t2 内容的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyText</span>(<span class="hljs-params">new_text</span>) &#123;<br>  <span class="hljs-keyword">var</span> t2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;t2&quot;</span>);<br>  t2.<span class="hljs-property">firstChild</span>.<span class="hljs-property">nodeValue</span> = new_text;<br>&#125;<br><br><span class="hljs-comment">// 用箭头函数为 table 添加事件监听器</span><br><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;outside&quot;</span>);<br>el.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">modifyText</span>(<span class="hljs-string">&quot;four&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span>,<br>);<br></code></pre></td></tr></table></figure><p>通过<code>=&gt;&#123;&#125;</code>形式的箭头函数简化代码书写.</p><hr><h4 id="比较匿名与箭头"><a href="#比较匿名与箭头" class="headerlink" title="比较匿名与箭头"></a>比较匿名与箭头</h4><p>匿名函数与箭头函数在此处的应用基本相同, 但是在<code>this</code>的指向上有所不同:</p><ul><li><p>匿名函数与其他普通的JS函数:<code>this</code>指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为<code>undefined</code>);</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 在非严格模式下，this 指向 window</span><br>&#125;<br><span class="hljs-title function_">sayHello</span>();<br></code></pre></td></tr></table></figure></li><li><p>箭头函数的<code>this</code>继承自外部作用域, 即调用该方法的对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ZJU&quot;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// this 指向 obj</span><br>  &#125;,<br>&#125;;<br>obj.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：ZJU</span><br></code></pre></td></tr></table></figure></li><li><p>e.g.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ZJU&quot;</span>,<br>  <span class="hljs-attr">getNameWithAnonymous</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">getNameWithArrow</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> anonymousFn = obj.<span class="hljs-title function_">getNameWithAnonymous</span>();<br><span class="hljs-title function_">anonymousFn</span>(); <span class="hljs-comment">// 输出：undefined</span><br><br><span class="hljs-keyword">const</span> arrowFn = obj.<span class="hljs-title function_">getNameWithArrow</span>();<br><span class="hljs-title function_">arrowFn</span>(); <span class="hljs-comment">// 输出：ZJU</span><br></code></pre></td></tr></table></figure><blockquote><p>进一步完善.</p></blockquote></li></ul><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>$\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如<code>event</code>,<code>e</code>,<code>evt</code>. 它被自动传递给事件处理函数，以提供额外的功能和信息。</p><p><code>e.target</code>始终是对 <strong>事件刚刚发生的元素</strong> 的引用</p><h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><h3 id="new"><a href="#new" class="headerlink" title="new()"></a>new()</h3><p>$\underline{new}$ 用来创建对象实例的一个关键字. </p><ul><li>作用: <strong>调用</strong> 一个 构造函数, 并返回一个由该构造函数创建的对象实例.<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> constructor<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arg1</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arg1, arg2</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arg1, arg2, <span class="hljs-comment">/* …, */</span> argN</span>)<br></code></pre></td></tr></table></figure></li></ul><ol><li>如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即<code>new foo</code> 等价于 <code>new foo()</code>;</li><li>构造函数内部的<code>this</code>将被绑定到新建的对象实例上;</li></ol><ul><li>e.g. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">color, brand</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;   <span class="hljs-comment">// 将 color 赋值给新对象</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">brand</span> = brand;   <span class="hljs-comment">// 将 brand 赋值给新对象</span><br>&#125;<br><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;Toyota&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">color</span>); <span class="hljs-comment">// 输出 &quot;red&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">brand</span>); <span class="hljs-comment">// 输出 &quot;Toyota&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>使用<code>new()</code>的<strong>步骤</strong>:</p><ol><li>定义构造函数;</li><li>使用<code>new()</code>并传入构造函数的参数;</li><li>将返回的对象实例赋值给一个变量;</li></ol><h4 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h4><ul><li><p>为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">car1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;black&quot;</span> <span class="hljs-comment">//为car1新增color属性</span><br></code></pre></td></tr></table></figure><p><br></p></li><li><p>添加共享属性到构造函数中的<code>prototype</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params"></span>) &#123;&#125;<br>car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>car2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">color</span>); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;原色&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;原色&#x27;</span><br><br>car1.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;黑色&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;黑色&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(car1).<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;原色&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(car2).<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;原色&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car1.<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;黑色&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(car2.<span class="hljs-property">color</span>); <span class="hljs-comment">// &#x27;原色&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>此处的构造函数名为<code>Car</code>, 因此通过<code>Car.prototype</code>可以访问到构造函数的原型对象;</li><li><code>getPrototypeOf</code> 表示获取对象的<strong>原型对象</strong>, 因此此处均为最初定义的 <strong>原色</strong>.</li></ul></blockquote></li></ul><h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>函数通过<code>new.target</code>属性可以判断是否通过<code>new</code>关键字调用, 即构造.</p><ul><li>如果函数是正常调用, 则返回<code>undefined</code>;</li><li><p>如果函数是通过<code>new</code>调用, 返回被调用的构造函数.</p></li><li><p>e.g.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">color</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>    <span class="hljs-comment">// 以函数的形式被调用。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;color&#125;</span>车`</span>;<br>  &#125;<br>  <span class="hljs-comment">// 通过 new 被调用。</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;红&quot;</span>); <span class="hljs-comment">// a 是“红车”</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;红&quot;</span>); <span class="hljs-comment">// b 是 `Car &#123; color: &quot;红&quot; &#125;`</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="对象类型与实例"><a href="#对象类型与实例" class="headerlink" title="对象类型与实例"></a>对象类型与实例</h4><p>$\underline{对象类型}$ 通过构造函数可以创建一个对象类型:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model, year</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> = year;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>$\underline{对象实例}$ 通过使用<code>new()</code>方法, 由对象类型构造一个对象实例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;鹰牌&quot;</span>, <span class="hljs-string">&quot;Talon TSi&quot;</span>, <span class="hljs-number">1993</span>);<br></code></pre></td></tr></table></figure></p><h4 id="类与new"><a href="#类与new" class="headerlink" title="类与new"></a>类与new</h4><p>在JS当中, 类 <strong>必须</strong> 通过<code>new</code>调用.</p><blockquote><p>可以优先阅读<a href="#类">类相关的知识</a></p></blockquote><ul><li>e.g. <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-comment">//构造函数</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>  <span class="hljs-comment">//实例方法</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>对于上述的类, 必须使用如下的调用方式:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Dog&quot;</span>); <span class="hljs-comment">// 正常</span><br></code></pre></td></tr></table></figure>而下面这样类似于普通函数的调用方式会抛出错误:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Cat&quot;</span>); <span class="hljs-comment">// TypeError:  Class constructor Animal cannot be invoked without &#x27;new&#x27;</span><br></code></pre></td></tr></table></figure><br></li></ul><p>在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">animal.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出 &quot;你好，我的名字是Dog&quot;</span><br></code></pre></td></tr></table></figure></p><hr><p>下面给出与普通函数的区别:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">model</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model;<br>&#125;<br><br><span class="hljs-keyword">const</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Toyota&quot;</span>); <span class="hljs-comment">// 正常</span><br><span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;Honda&quot;</span>); <span class="hljs-comment">// 不抛出错误，但 this 会指向全局对象.</span><br><span class="hljs-keyword">const</span> anotherCar = <span class="hljs-title class_">Car</span>(<span class="hljs-string">&quot;cat&quot;</span>); <span class="hljs-comment">//此时全局对象下的model值为 &quot;cat&quot;, 覆盖了上一行的定义.</span><br></code></pre></td></tr></table></figure><br>总结:</p><ul><li>以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;</li><li>如果以new方法构造得到对象实例, 依旧正常.</li></ul><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h2><p>$\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.</p><ul><li>比如存在以下的默认行为:<ul><li>滚动事件：触摸屏上滑动手指，页面会滚动;</li><li>拖拽文件到浏览器：浏览器会尝试加载文件;</li><li>点击链接 <code>(&lt;a href=&quot;...&quot;&gt;)</code>：跳转到指定的 URL;</li></ul></li></ul><p>$\underline{阻止默认行为}$ 使用 <code>event.preventDefault()</code> 方法可以阻止事件的默认行为.</p><ul><li><p>e.g: 阻止链接跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;a&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止点击链接时的默认行为</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;链接被点击，但没有跳转&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>作用:</p><ul><li>通过阻止默认行为, 可以实现自定义逻辑.</li></ul></li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li><code>this</code>可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;</li><li><code>this</code> 指向的是<strong>当前函数的调用者</strong>，而不是函数内部定义的变量.</li></ul><p><br></p><ul><li>e.g.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;b in the obj&quot;</span>,<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b in the function&quot;</span>; <span class="hljs-comment">// 函数作用域</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class="hljs-title function_">f</span>();<br></code></pre></td></tr></table></figure><blockquote><p>此处的<code>f</code></p></blockquote></li></ul><h3 id="函数上下文中的this"><a href="#函数上下文中的this" class="headerlink" title="函数上下文中的this"></a>函数上下文中的this</h3><ul><li><code>this</code>参数的值取决于函数<strong>如何</strong>被调用, 而不是函数如何被定义.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对象可以作为第一个参数传递给 &#x27;call&#x27; 或 &#x27;apply&#x27;，</span><br><span class="hljs-comment">// 并且 &#x27;this&#x27; 将被绑定到它。</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;Custom&quot;</span> &#125;;<br><br><span class="hljs-comment">// 使用 var 声明的变量成为 &#x27;globalThis&#x27; 的属性。</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;Global&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">whatsThis</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>; <span class="hljs-comment">// &#x27;this&#x27; 取决于函数如何被调用</span><br>&#125;<br><br><span class="hljs-title function_">whatsThis</span>(); <span class="hljs-comment">// &#x27;Global&#x27;; 在非严格模式下，&#x27;this&#x27; 参数默认为 &#x27;globalThis&#x27;</span><br>obj.<span class="hljs-property">whatsThis</span> = whatsThis;<br>obj.<span class="hljs-title function_">whatsThis</span>(); <span class="hljs-comment">// &#x27;Custom&#x27;; &#x27;this&#x27; 参数被绑定到 obj</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>同样是调用函数<code>whatsThis()</code>, 但是<code>this</code>参数被绑定到不同的对象上, 导致返回值不同;</li><li>在非严格模式下, <code>this</code>参数默认指向<code>globalThis</code>, 即全局对象;</li><li>对于典型函数, <code>this</code>指向函数访问的对象;</li></ol><ul><li><p>e.g. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;b in the obj&quot;</span>,<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b in the function&quot;</span>; <span class="hljs-comment">// 函数作用域</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 访问 this.b</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> b = <span class="hljs-string">&quot;b outside of the func&quot;</span>;<br><br>obj.<span class="hljs-title function_">f</span>();<br></code></pre></td></tr></table></figure><blockquote><p>此处<code>f</code>作为<code>obj</code>对象的方法被调用, 因此普通函数的<code>this</code>指向<code>obj</code>.</p></blockquote></li><li><p>e.g. 直接调用的普通函数<code>this</code>指向全局:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> funcA = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> &#125;; <span class="hljs-comment">// 普通函数，this 由调用方式决定</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">funcA</span>()); <span class="hljs-comment">// 访问 this.a</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;a in the global&quot;</span>;<br>obj.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// &quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>此处的<code>funcA</code>并没有类似于作为对象的属性调用(<code>obj.funcA()</code>), 因此其<code>this</code>指向全局作用域(<code>window</code>), 输出<code>undefined</code>, 而是直接调用的形式, 因此其<code>this</code>指向全局作用域.</li></ul></blockquote></li></ul><h3 id="对this传值"><a href="#对this传值" class="headerlink" title="对this传值"></a>对this传值</h3><p>使用<code>call()</code>以及<code>apply()</code>方法可以将<code>this</code>绑定到其他对象上.</p><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><ul><li>形式: <code>func.call(thisArg, arg1, arg2, ...)</code></li><li>e.g:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">c, d</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> + c + d;<br>&#125;<br><br><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-comment">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class="hljs-comment">// 剩余的参数被绑定到命名参数。</span><br>add.<span class="hljs-title function_">call</span>(o, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><ul><li>形式: <code>func.apply(thisArg, [argsArray])</code></li><li>e.g:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">c, d</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> + c + d;<br>&#125;<br><br><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-comment">// 第一个参数被绑定到隐式的 &#x27;this&#x27; 参数；</span><br><span class="hljs-comment">// 第二个参数是一个数组，其成员被绑定到命名参数。</span><br>add.<span class="hljs-title function_">apply</span>(o, [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>]); <span class="hljs-comment">// 34</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><ul><li>形式: <code>f.bind(someObject)</code>;</li><li><strong>作用</strong>: <ul><li>创建一个新的函数(需要重新赋值), 具有与<code>f</code>相同的函数体和作用域;</li><li>新函数的<code>this</code>被 <strong>永久地</strong> 绑定到<code>someObject</code>, 不随调用方式的变化而变化.</li></ul></li><li><strong>限制</strong>: <ul><li><code>bind</code>无法多次生效. 即对函数f<code>bind</code>得到的g, 无法继续用<code>bind</code>得到期望的h;</li></ul></li><li><p>e.g. 多次<code>bind</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = f.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;azerty&quot;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">g</span>()); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> h = g.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;yoo&quot;</span> &#125;); <span class="hljs-comment">// bind 只能生效一次！</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">h</span>()); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">37</span>, f, g, h &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">a</span>, o.<span class="hljs-title function_">f</span>(), o.<span class="hljs-title function_">g</span>(), o.<span class="hljs-title function_">h</span>()); <span class="hljs-comment">// 37 37 undefined undefined</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>由于<code>bind</code>只能对一个原始函数作用, 因此由f得到的g无法继续由<code>bind</code>绑定<code>this</code>得到期望的h, 此处h的<code>this</code>依旧是<code>&#123;b: &quot;azerty&quot;&#125;</code>, 因此在输出对象<code>a</code>时显示<code>undefined</code>;</li><li><code>o.f()</code>的调用是普通函数的调用, 因此其<code>this</code>继承自对象<code>o</code>, 输出<code>37</code>;</li></ul></blockquote></li><li><p>e.g. 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">c</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> g = f.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">b</span>: <span class="hljs-string">&quot;azerty&quot;</span> , <span class="hljs-attr">c</span>:<span class="hljs-string">&quot;ccc&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">g</span>()); <span class="hljs-comment">// &quot;undefined ccc&quot;</span><br><br><span class="hljs-keyword">const</span> h = g.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;yoo&quot;</span> &#125;); <span class="hljs-comment">// bind 只能生效一次！</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">h</span>()); <span class="hljs-comment">// &quot;undefined ccc&quot;</span><br><br><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">37</span>, f, g, h &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">a</span>, o.<span class="hljs-title function_">f</span>(), o.<span class="hljs-title function_">g</span>(), o.<span class="hljs-title function_">h</span>()); <span class="hljs-comment">// 37 37 azerty azerty</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><code>bind</code>绑定的<code>this</code>是永久覆盖, 而非简单叠加;</li><li>由于<code>bind</code>绑定的<code>this</code>不随者调用方式的变化而变化, 因此即使处于对象<code>o</code>当中, <code>g</code>,<code>h</code>依旧不会输出<code>o</code>中的<code>a</code>.</li></ul></blockquote></li></ul><h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h3><p>使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。</p><p>普通函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;a in the global&quot;</span>;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br> <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br> <span class="hljs-attr">f</span>: foo<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">f</span>()); <span class="hljs-comment">// &quot;a in the obj&quot;</span><br></code></pre></td></tr></table></figure></p><p><code>call()</code>、 <code>apply()</code>、 <code>bind()</code> 无法改变箭头函数的<code>this</code>(但是call与apply的其他参数可以正常传递:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">foo</span> = (<span class="hljs-params"></span>)=&gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br> <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br> <span class="hljs-attr">f</span>: foo.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&quot;a in the bind&quot;</span>&#125;) <span class="hljs-comment">// 显式绑定 this 到 obj, 但是无法生效</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">f</span>()); <span class="hljs-comment">// undefined</span><br><br></code></pre></td></tr></table></figure></p><blockquote><p>换成普通函数则输出<code>a in the obj</code>.</p></blockquote><ul><li>全局作用域<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;a in the global&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">foo1</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br><span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br><span class="hljs-attr">f</span>: <span class="hljs-function">()=&gt;</span> a<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">f</span>());<br></code></pre></td></tr></table></figure></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>$\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. </p><ul><li>全局作用域: 脚本模式运行所有代码的默认作用域;</li><li>模块作用域: 模块模式中运行代码的作用域;</li><li>函数作用域: 由函数创建的作用域</li><li>块级作用域: 由<code>let</code>或<code>const</code>声明的变量的作用域.(对于<code>var</code>无效);</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 1</span><br><br>&#123;<br>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>Notices:</p><ul><li>对象本身并不会创建作用域, 只是一个键值对的集合;</li><li>箭头函数也不会创建自己的作用域, 而是 <strong>继承</strong> 外层作用域中的<code>this</code>;</li></ul><h3 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h3><ul><li><code>var</code>在全局作用域中声明时会成为 <strong>全局对象</strong> (<code>window</code>或<code>global</code>)的属性;</li><li><code>let</code>和<code>const</code>即使在全局作用域中声明, 也不会成为全局对象的属性;<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;2&quot;</span>;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>; <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><blockquote><p>因此, 建议在全局作用域中不要使用<code>var</code>声明变量, 而使用<code>let</code>或<code>const</code>声明变量. 从而避免导致意外的覆盖和冲突.</p></blockquote></li></ul><h3 id="函数与作用域"><a href="#函数与作用域" class="headerlink" title="函数与作用域"></a>函数与作用域</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>普通函数和匿名函数的作用域继承自其定义时的作用域.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br>    <span class="hljs-attr">insideObj</span>: &#123;<br>        <span class="hljs-attr">g</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>; <span class="hljs-comment">// 普通函数，this 动态绑定到 insideObj</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>; <span class="hljs-comment">// 普通函数，this 动态绑定到 obj</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">f</span>());        <span class="hljs-comment">// &quot;a in the obj&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">insideObj</span>.<span class="hljs-title function_">g</span>()); <span class="hljs-comment">// undefined，因为 insideObj 中没有 a</span><br></code></pre></td></tr></table></figure></p><h4 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>e.g. <strong>箭头函数继承外层作用域</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;a in the global&quot;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;a in the obj&quot;</span>,<br>    <span class="hljs-attr">insideObj</span>: &#123;<br>        <span class="hljs-attr">g</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span><br>    &#125;,<br>    <span class="hljs-attr">f</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span><br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">f</span>());        <span class="hljs-comment">// &quot;a in the global&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">insideObj</span>.<span class="hljs-title function_">g</span>()); <span class="hljs-comment">//&quot;a in the global&quot;</span><br></code></pre></td></tr></table></figure><br>由于对象不会创建作用域, 因此此处的箭头函数的<code>this</code>继承了外层作用域(window)的<code>this</code>, 且<code>var</code>创建的变量存在于全局作用域中.</p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>$\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.</p><ul><li>本质上没有增加语言的功能, 而是对已有功能的 <strong>包装</strong> 或者优化;</li><li><strong>可读性提升</strong>: <del>让代码更填</del> 使得代码更加容易理解和书写;</li><li><strong>底层实现</strong>: 实质上依旧用基础的语法实现.</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类 <code>class</code> 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承<code>prototype</code>的封装.</p><p>使用<code>class</code>的写法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p><p>等价的原型写法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br>person.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice</span><br></code></pre></td></tr></table></figure></p><h3 id="箭头函数-2"><a href="#箭头函数-2" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.</p><ul><li>e.g.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-comment">// 等价的普通函数</span><br><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h3><p>$\underline{结构赋值}$ 手动提取<strong>对象</strong>属性的语法糖.</p><ul><li><p>使用结构赋值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Zhuo&quot;</span>, <span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;male&quot;</span>&#125;;<br><br><span class="hljs-keyword">const</span> &#123;name, gender&#125; = person;<br></code></pre></td></tr></table></figure></li><li><p>等价的原型写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Zhuo&quot;</span>, <span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;male&quot;</span>&#125;;<br><br><span class="hljs-keyword">const</span> name = person.<span class="hljs-property">name</span>;<br><span class="hljs-keyword">const</span> gender = person.<span class="hljs-property">gender</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="赋值规则"><a href="#赋值规则" class="headerlink" title="赋值规则"></a>赋值规则</h4><p>结构赋值时, 基于 <strong>属性名匹配</strong> 而非顺序.<br>因此, 对象结构的<code>&#123;&#125;</code>内部属性必须和 <strong>对象的属性名</strong> 相对应.</p><p><strong>错误</strong>的示例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; a, b &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 输出：undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 输出：undefined</span><br></code></pre></td></tr></table></figure></p><p><strong>重命名属性</strong>的写法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>: a, <span class="hljs-attr">age</span>: b &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 输出：Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 输出：25</span><br></code></pre></td></tr></table></figure></p><p><strong>手动赋值</strong>: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; name, age = <span class="hljs-number">30</span> &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// 输出：Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);  <span class="hljs-comment">// 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）</span><br></code></pre></td></tr></table></figure></p><h4 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h4><p>上述讨论的结构赋值都是对 <strong>对象</strong> 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— <strong>基于顺序</strong>赋值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>];<br><span class="hljs-keyword">const</span> [a, b] = arr;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 输出：Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 输出：25</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社会心理学</title>
    <link href="/2025/01/09/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    <url>/2025/01/09/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="社会知觉"><a href="#社会知觉" class="headerlink" title="社会知觉"></a>社会知觉</h1><h2 id="非语言线索"><a href="#非语言线索" class="headerlink" title="非语言线索"></a>非语言线索</h2><p><strong>面部表情反馈假设</strong>: 人为表现某种面部表情, 可以导致相应情绪体验的产生或增强;</p><h2 id="印象形成"><a href="#印象形成" class="headerlink" title="印象形成"></a>印象形成</h2><p>顺序效应</p><ul><li>首因效应: 最初获得的信息影响更大, 即第一印象效应;</li><li>近因效应: 后来获得的信息影响更大, 即新颖效应;</li></ul><p>晕轮效应</p><ul><li>对一个人的某种特征 <strong>形成</strong> 好或坏的印象 <strong>之后</strong>, 据此推论其他方面的特征;</li><li>与首因效应的区别: <blockquote><p>前者发生在初步印象形成之后, 后者发生在初步印象形成之前;</p></blockquote></li></ul><p>投射效应</p><ul><li>在认知和形成他人印象时，认为他人与自己具有<strong>相似</strong>的特性;</li><li>将自己的情感、特性投射到他人身上并强加于他人;</li></ul><h3 id="期望效应"><a href="#期望效应" class="headerlink" title="期望效应"></a>期望效应</h3><p><strong><em>Self-fulfilling prophecy</em></strong></p><blockquote><p>自我实现预言 </p></blockquote><ul><li>“预测”或期待某事的社会心理现象，而这种“预测”或期望之所以成真，只是因为该人相信或预期它会发生;</li><li>人们的信念会影响他们的行为;</li></ul><p>可见迹象,感知和信念共同影响自我实现预言成为现实的可能性. </p><h2 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h2><blockquote><p>Attribution theory</p></blockquote><p><strong>归因</strong>, 指观察者从他人的行为推论出行为原因、因果关系。</p><p><strong>归因理论</strong>, 指研究人们如何做出归因，以及为何在某情况做出某种归因，在另一情况做出另种归因的理论。</p><ul><li>$\underline{情境归因}$: 将行为发生解释为情境（环境）因素使然者 —外因</li><li>$\underline{性格归因}$: 指个体将行为之发生解释为自己性格使然 —内因</li></ul><h3 id="归因偏差"><a href="#归因偏差" class="headerlink" title="归因偏差"></a>归因偏差</h3><p><strong>基本归因错误</strong>: 解释他人行为时, 高估特质和态度的作用, 而低估情境的影响;</p><p><strong>行为者-观察者偏差</strong>: </p><ul><li>归因他人的行为时, 倾向于内部归因;归因自身行为时, 倾向于外部归因;</li><li>为什么会产生上述区别?<ul><li>对于行为的信息数量和类型, 因自身和他人的区别在了解程度上存在差异;</li><li>人们倾向于利用 <strong>可得性</strong> 高的信息来处理问题<blockquote><p>根据$\underline{格式塔原理}$, 可得性高,即与背景形成 <strong>鲜明对比</strong>;<br>对于行为者,它代表着外部环境; 对于观察者, 他人的行为则构成了注意的中心.</p></blockquote></li></ul></li></ul><hr><p><strong>错误共识效应</strong>(False consensus effect): </p><ul><li>也称为 <strong>虚假一致性效应</strong>;</li><li>指倾向于认为自己的观点、信念、特征或行为比实际情况更广泛地被认同, 从而倾向于根据自己的信念进行推论;</li><li>这同时导致人们倾向于与自己 <strong>相似</strong> 的个体交往;</li></ul><hr><p><strong>公平世界信念</strong>: 指的是相信”善有善报,恶有恶报”而导致的归因偏差.</p><ul><li>认为每个人都应该为自己的行为负责;</li><li>分析行为的原因时, 倾向于追溯个人自身的原因;</li></ul><hr><p><strong>动机性归因偏差</strong>: </p><ul><li>倾向于将自己的成功归因于内在因素、失败归因于外在因素;</li><li>而观察和评价他人的行为时，倾向于将成功归因于外在因素，将失败归因于内在因素;</li></ul><h1 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h1><h2 id="自我概念"><a href="#自我概念" class="headerlink" title="自我概念"></a>自我概念</h2><ul><li>$\underline{自我知觉}$: 对自己持有的信念之集合;</li><li>$\underline{自我中心思维}$: 对自我的感觉处于意识的核心;</li><li>$\underline{虚假一致性效应}$: </li></ul>]]></content>
    
    
    <categories>
      
      <category>兴趣阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心理学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>媒体查询</title>
    <link href="/2025/01/08/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"/>
    <url>/2025/01/08/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/CSS_layout/Media_queries">媒体查询入门指南</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries/Testing_media_queries">使用编程方法测试媒体查询</a></p></blockquote><h1 id="媒体查询入门"><a href="#媒体查询入门" class="headerlink" title="媒体查询入门"></a>媒体查询入门</h1><p>对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.</p><p>媒体查询的范式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> media-type <span class="hljs-keyword">and</span> (media-feature) &#123;<br>    <span class="hljs-comment">/*css rules*/</span><br>&#125;<br></code></pre></td></tr></table></figure></p><blockquote><ol><li>媒体类型用于声明css文件被用作什么类型的媒体;</li><li>媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;</li><li>通过测试且符合媒体类型的情况下应用内部的CSS样式.</li></ol></blockquote><p><strong>media-type</strong>: all, print, screen, speech.</p><h2 id="媒体特征"><a href="#媒体特征" class="headerlink" title="媒体特征"></a>媒体特征</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>使用<code>min</code>,<code>max</code>在一定的数值范围内启用当前的CSS样式.</p><blockquote><p>如果去掉前缀, 将仅在恰好为当前数值中启用.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 启用宽度大于或等于600px的屏幕 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">/* 启用宽度小于或等于600px的屏幕 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">600px</span>)&#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">/* 窗口恰好等于600px时 */</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h3><p><code>orientation</code>可以检测设备的方向, 如竖屏或横屏.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: portrait) &#123;<br>    <span class="hljs-comment">/* 竖放时的CSS样式 */</span><br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>    <span class="hljs-comment">/* 横屏时的CSS样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="更复杂的媒体查询"><a href="#更复杂的媒体查询" class="headerlink" title="更复杂的媒体查询"></a>更复杂的媒体查询</h2><ul><li><p><code>and</code>实现与逻辑:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">400px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>,</code>实现或逻辑:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape), (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;<br>  <span class="hljs-comment">/* </span><br><span class="hljs-comment">  (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)</span><br><span class="hljs-comment">  */</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>与C中的<code>&amp;</code>和<code>|</code>类似, 与的优先级更高, 先将<code>and</code>的条件进行判断, 然后视作整体.</p></blockquote></li><li><p><code>not</code>实现非逻辑:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> all <span class="hljs-keyword">and</span> (<span class="hljs-attribute">orientation</span>: landscape) &#123;<br><span class="hljs-comment">/* 非全部屏幕且屏幕方向为横向 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>not</code>实现 <strong>反转查询</strong>:</p><blockquote><p>与最近的<code>and</code>组合所绑定, 注意优先级</p></blockquote></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">not</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">color</span>), print <span class="hljs-keyword">and</span> (<span class="hljs-attribute">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure><p><code>,</code>将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-keyword">not</span> (screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">color</span>))), print <span class="hljs-keyword">and</span> (<span class="hljs-attribute">color</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure></p><hr><h1 id="利用查询结果扩展设计"><a href="#利用查询结果扩展设计" class="headerlink" title="利用查询结果扩展设计"></a>利用查询结果扩展设计</h1><p>上述在CSS中利用<code>@media</code>可以实现响应式的设计, 如果我们希望在js/ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.</p><ul><li><p>使用<code>window.matchMedia()</code>方法存放媒体查询结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 检测设备的旋转方向是否为纵向</span><br><span class="hljs-keyword">var</span> mediaQueryList = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(<span class="hljs-string">&quot;(orientation: portrait)&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>检查属性<code>matches</code>获取对应的查询结果:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">if (mediaQueryList<span class="hljs-selector-class">.matches</span>) &#123;<br>  <span class="hljs-comment">/* 设备的旋转方向为纵向 portrait */</span><br>&#125; else &#123;<br>  <span class="hljs-comment">/* 设备的旋转方向不是纵向，也就是横向 landscape */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过<code>addListener()</code>方法注册监听器, 持续监听查询列表的结果</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义媒体查询字符串</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">mediaQueryString</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;(orientation: portrait)&quot;</span>;<br><br><span class="hljs-comment">// 创建查询列表</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">mediaQueryList</span>: <span class="hljs-title class_">MediaQueryList</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(mediaQueryString);<br><br><span class="hljs-comment">// 定义回调函数，使用 MediaQueryListEvent 类型</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleOrientationChange</span>(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">MediaQueryListEvent</span></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">matches</span>) &#123;<br>    <span class="hljs-comment">// 媒体查询匹配（竖屏）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Orientation changed to portrait&quot;</span>);<br>    <span class="hljs-comment">// 在这里执行竖屏时的逻辑</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 媒体查询不匹配（横屏）</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Orientation changed to landscape&quot;</span>);<br>    <span class="hljs-comment">// 在这里执行横屏时的逻辑</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 先运行一次回调函数，传入 MediaQueryList 对象</span><br><span class="hljs-title function_">handleOrientationChange</span>(&#123;<br>    <span class="hljs-attr">matches</span>: mediaQueryList.<span class="hljs-property">matches</span>,<br>    <span class="hljs-attr">media</span>: mediaQueryList.<span class="hljs-property">media</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;change&#x27;</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">MediaQueryListEvent</span>);<br><br><span class="hljs-comment">// 为查询列表注册监听器，同时将回调函数传给监听器</span><br>mediaQueryList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, handleOrientationChange);<br><br><span class="hljs-comment">// (可选) 在组件卸载时或不再需要监听时，移除事件监听器</span><br><span class="hljs-comment">// mediaQueryList.removeEventListener(&#x27;change&#x27;, handleOrientationChange);</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css笔记</title>
    <link href="/2025/01/08/css%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/08/css%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://jsfiddle.net/?locale=zh_CN">在线编辑平台</a></p></blockquote><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>使用伪元素<code>before</code>和<code>after</code>可以为元素添加内容.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;author&quot;</span>&gt;</span>待抉<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.author</span><span class="hljs-selector-pseudo">:before</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Author: &quot;</span>;</span><br><span class="language-css">  <span class="hljs-attribute">font-weight</span>: bold; <span class="hljs-comment">/* 加粗字体 */</span></span><br><span class="language-css">  <span class="hljs-attribute">color</span>: blue; <span class="hljs-comment">/* 文本颜色为蓝色 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.author</span><span class="hljs-selector-pseudo">:after</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot; ✍️&quot;</span>;</span><br><span class="language-css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>; <span class="hljs-comment">/* 调整图标大小 */</span></span><br><span class="language-css">  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* 添加左边距 */</span></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><code>:nth-child</code>可用于对序列中不同的元素进行有序的样式设计:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;index-card&quot;</span>&gt;</span>内容1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;index-card&quot;</span>&gt;</span>内容2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;index-card&quot;</span>&gt;</span>内容3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;index-card&quot;</span>&gt;</span>内容4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.index-card</span><span class="hljs-selector-pseudo">:nth-child</span>(odd) &#123;</span><br><span class="language-css">  <span class="hljs-attribute">flex-direction</span>: row-reverse;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></p><ul><li>选择所有类名为 “index-card” 的元素;</li><li><code>row-reverse</code> 会让 flex 容器中的项目从右到左排列;<blockquote><p>同理, <code>even</code>选择偶数位置的元素; <code>3n+1</code>等函数表达式也可以起作用.</p></blockquote></li></ul><h3 id="基本的元素属性"><a href="#基本的元素属性" class="headerlink" title="基本的元素属性"></a>基本的元素属性</h3><h4 id="布局属性"><a href="#布局属性" class="headerlink" title="布局属性"></a>布局属性</h4><ul><li><code>margin</code>: 控制元素的外边距;</li><li><code>padding</code>: 控制元素的内边距;</li></ul><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><ul><li><code>font-size</code>: 控制字体大小;</li><li><code>font-weight</code>: 控制字体粗细;</li><li><code>text-align</code>: 控制文本的对齐方式;</li><li><code>text-decoration</code>: 控制文本的装饰;</li><li><code>line-height</code>: 控制行高;</li><li><code>letter-spacing</code>: 控制字符间距;</li><li><code>text-transform</code>: 控制文本的大小写;</li></ul><h4 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h4><ul><li><code>border</code>: e.g. <code>border: 1px solid red;</code> 简写属性;</li><li><code>border-radius</code>: 控制元素的圆角;</li><li><code>border-style</code>: solid, dashed, dotted…</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><code>overflow</code>: visible, hidden, scroll, auto;</li><li><code>opacity</code>: 控制元素的透明度;</li><li><code>cursor</code>: pointer, default, move, not-allowed…</li></ul><h3 id="动感魔法"><a href="#动感魔法" class="headerlink" title="动感魔法"></a>动感魔法</h3><h4 id="hover效果"><a href="#hover效果" class="headerlink" title="hover效果"></a>hover效果</h4><p>通过为class设置<code>:hover</code>伪类，可以为元素添加鼠标悬停时的效果。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.my-element</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: green;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>  <span class="hljs-attribute">font-size</span>:<span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><blockquote><p>空格将不会被忽略, 需要确保类名与<code>:hover</code>之间不存在空格;</p></blockquote><p>其他的一些常用的伪类:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>    <span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br>    <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:focus</span> &#123;<br>      <span class="hljs-attribute">border-color</span>: blue;<br>    &#125;<br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>      <span class="hljs-attribute">color</span>: purple;<br>    &#125;<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<br>      <span class="hljs-attribute">font-weight</span>: bold;<br>    &#125;<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>      <span class="hljs-attribute">font-style</span>: italic;<br>    &#125;<br>    <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>    <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:only-child</span> &#123;<br>      <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>    <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:empty</span> &#123;<br>      <span class="hljs-attribute">background-color</span>: yellow;<br>    &#125;<br></code></pre></td></tr></table></figure></p><h3 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/* 定义Flex容器 */</span></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 将容器设置为Flexbox容器 */</span></span><br><span class="language-css">      </span><br><span class="language-css">      <span class="hljs-comment">/* flex-direction: 定义主轴方向 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* row: 水平从左到右（默认） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* row-reverse: 水平从右到左 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* column: 垂直从上到下 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* column-reverse: 垂直从下到上 */</span></span><br><span class="language-css">      <span class="hljs-attribute">flex-direction</span>: row; <span class="hljs-comment">/* 可以改为row-reverse, column, column-reverse */</span></span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* flex-wrap: 定义是否换行 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* nowrap: 不换行（默认） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* wrap: 换行 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* wrap-reverse: 反向换行 */</span></span><br><span class="language-css">      <span class="hljs-attribute">flex-wrap</span>: wrap; <span class="hljs-comment">/* 可以改为nowrap, wrap-reverse */</span></span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* flex-flow: flex-direction 和 flex-wrap 的简写 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */</span></span><br><span class="language-css">      <span class="hljs-attribute">flex-flow</span>: row wrap; <span class="hljs-comment">/* 可以改为column nowrap等组合 */</span></span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* justify-content: 定义在主轴上的对齐方式 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-start: 起始对齐（默认） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-end: 末端对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* center: 居中对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* space-between: 两端对齐，项目之间间隔相等 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* space-around: 项目之间间隔相等，项目两边有半个间隔 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */</span></span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: space-between; <span class="hljs-comment">/* 可以改为flex-start, flex-end, center, space-around, space-evenly */</span></span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* align-items: 定义在交叉轴上的对齐方式 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* center: 交叉轴居中对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* baseline: 项目基线对齐 */</span></span><br><span class="language-css">      <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 可以改为flex-start, flex-end, stretch, baseline */</span></span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* stretch: 拉伸适应容器（默认） */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-start: 交叉轴起始对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* flex-end: 交叉轴末端对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* center: 交叉轴居中对齐 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* space-between: 多行两端对齐，行之间间隔相等 */</span></span><br><span class="language-css">      <span class="hljs-comment">/* space-around: 多行之间间隔相等，行两边有半个间隔 */</span></span><br><span class="language-css">      <span class="hljs-attribute">align-content</span>: space-between; <span class="hljs-comment">/* 可以改为flex-start, flex-end, center, space-around */</span></span><br><span class="language-css">      </span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>; <span class="hljs-comment">/* 设置容器高度 */</span></span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>; <span class="hljs-comment">/* 设置容器背景颜色 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">    </span><br><span class="language-css">    <span class="hljs-comment">/* 定义Flex项目 */</span></span><br><span class="language-css">    <span class="hljs-selector-class">.item</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 设置项目的flex属性，项目平分空间 */</span></span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 设置项目内边距 */</span></span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: lightblue; <span class="hljs-comment">/* 设置项目背景颜色 */</span></span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 设置项目外边距 */</span></span><br><span class="language-css">      <span class="hljs-attribute">text-align</span>: center; <span class="hljs-comment">/* 设置项目文本居中 */</span></span><br><span class="language-css">      <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<span class="hljs-comment">/*尝试向flex容器扩展空间*/</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>倦鸟</title>
    <link href="/2025/01/08/poets/bird/"/>
    <url>/2025/01/08/poets/bird/</url>
    
    <content type="html"><![CDATA[<p><br></p><p style = "     font-size: 1.3em;    text-align: center;    line-height: 2em;">我盘旋的目光是漂泊不息的倦鸟<br>越过人海 坠入你乌黑瞳仁中的夜</p><p><img src = "/img/倦鸟.png" width ="70%"></p><blockquote><p>下附最初的三节诗, 以及灵感来源.</p></blockquote><details><summary> 完整三节诗</summary><p style = "     font-size: 1em;    text-align: center;    line-height: 1.5em;">我盘旋的目光是漂泊不息的倦鸟 <br>越过人海终于落入你乌黑瞳仁中的夜<br><br>你澄澈的眼眸映照着闪烁明灭的晨星<br>你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br><br>我们的目光还是悄然相遇了<br>你温和的凝视又让我想起黎明的微光<br>我漆黑的羽翼微微颤动 随后灼灼燃烧<br>于是 我的目光载着余烬 再度飞远了<br></p></details><details><summary> 「灵感」Tagore's</summary><p style = "     font-size: 1.1em;    text-align: center;    line-height: 2em;">My heart, the bird of the wilderness, <br>has found its sky in your eyes.<br><p style = "     font-size: 1em;    text-align: center;    color: grey;    line-height: 2em;">(出自泰戈尔的园丁集)</p></p></details>]]></content>
    
    
    <categories>
      
      <category>随机掉落的文字碎片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短诗</tag>
      
      <tag>她</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站第一天</title>
    <link href="/2025/01/08/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2025/01/08/%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>原本在倒腾Astro框架的, 想着用自己一些微薄的前端经验可以更自由地在react框架下自定义博客.</p><p>然而发现Astro的文档<del>还不够丰富, 配置起来还真是麻烦</del>.折腾了几天, 还是放弃了. <strong>还是hexo真香</strong>.😊</p><h2 id="为什么搭建这个博客-😋"><a href="#为什么搭建这个博客-😋" class="headerlink" title="为什么搭建这个博客?😋"></a>为什么搭建这个博客?😋</h2><ul><li>记录一下自己的学习历程</li><li>为生活的碎片留档, <del>越来越不想用puq了</del></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
